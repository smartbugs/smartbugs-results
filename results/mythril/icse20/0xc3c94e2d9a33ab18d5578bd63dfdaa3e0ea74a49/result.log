{"error": null, "issues": [{"address": 1377, "code": "educt 1 chat message allowence from the sender\n        addressesToChatMessagesLeft[msg.sender]--;\n        \n        // Add the chat message\n        chatMessages.push(ChatMessage(msg.sender, message));\n    }\n    \n    function getTotalAmountOfChatMessages() public view returns (uint256)\n    {\n        return chatMessages.length;\n    }\n    \n    function getChatMessageAtIndex(uint256 index) public view returns (address, byt", "debug": "calldata_PyramidGame_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_PyramidGame_0: 0xa7e33a0c00000000000000000000000000000000000000000000000000000000\ncalldatasize_PyramidGame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `sendChatMessage(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/4/0xc3c94e2d9a33ab18d5578bd63dfdaa3e0ea74a49.sol", "function": "sendChatMessage(string)", "lineno": 212, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3007, "code": "ate\n    // content,", "debug": "The exception is triggered under the following conditions:\n\ncalldata_PyramidGame_4: 0x0\nstorage_9: 0x0\ncalldata_PyramidGame_0: 0x9148018a00000000000000000000000000000000000000000000000000000000\ncalldatasize_PyramidGame: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/4/0xc3c94e2d9a33ab18d5578bd63dfdaa3e0ea74a49.sol", "function": "getChatMessageAtIndex(uint256)", "lineno": 231, "title": "Exception state", "type": "Informational"}, {"address": 3679, "code": ";\n\ncontract Pyrami", "debug": "storage_9: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x100\ncalldata_PyramidGame_0: 0xa7e33a0c00000000000000000000000000000000000000000000000000000000\ncalldatasize_PyramidGame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `sendChatMessage(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/4/0xc3c94e2d9a33ab18d5578bd63dfdaa3e0ea74a49.sol", "function": "sendChatMessage(string)", "lineno": 1, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3849, "code": "gisterUsername(bytes32 username) ", "debug": "The exception is triggered under the following conditions:\n\ncalldata_PyramidGame_4: 0x0\nstorage_9: 0x0\ncalldata_PyramidGame_0: 0xc49d9ff800000000000000000000000000000000000000000000000000000000\ncalldatasize_PyramidGame: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/4/0xc3c94e2d9a33ab18d5578bd63dfdaa3e0ea74a49.sol", "function": "_function_0xc49d9ff8", "lineno": 194, "title": "Exception state", "type": "Informational"}, {"address": 4412, "code": "t the specified layer\n        uint256 be", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xa8795cd3fffffffffffffffffffffffffffffffffffffffffffffffffffffffe\ncallvalue: 0x57f25cd000000000000000000000000000000000000000000000000000000000\nstorage_keccac_4294967295_&\n4294967295_&\n(65536*Concat(0,_Extract(15,_0,_calldata_PyramidGame_4))_|\n_65535_&_65535_&_calldata_PyramidGame_32_+_4): 0x0\ncalldata_PyramidGame_0: 0xda918f7600000000000000000000000000000000000000000000000000000000\ncalldatasize_PyramidGame: 0x4\n", "description": "A possible integer overflow exists in the function `placeBlock(uint16,uint16)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/4/0xc3c94e2d9a33ab18d5578bd63dfdaa3e0ea74a49.sol", "function": "placeBlock(uint16,uint16)", "lineno": 100, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5799, "code": "ordinates;\n    \n    // In the user ", "debug": "The exception is triggered under the following conditions:\n\ncalldata_PyramidGame_4: 0x0\nstorage_3: 0x0\ncalldata_PyramidGame_0: 0xe9ffd6de00000000000000000000000000000000000000000000000000000000\ncalldatasize_PyramidGame: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/4/0xc3c94e2d9a33ab18d5578bd63dfdaa3e0ea74a49.sol", "function": "_function_0xe9ffd6de", "lineno": 27, "title": "Exception state", "type": "Informational"}, {"address": 6124, "code": "ntract PyramidGame\n{\n    /////////////////////////////////////////////\n    // Game parameters\n    uint256 private constant BOTTOM_LAYER_BET_AMOUNT = 0.005 ether;\n    uint256 private adminFeeDivisor; // e.g. 100 means a 1% fee, 200 means a 0.5% fee\n    \n    /////////////////////////////////////////////\n    // Game owner\n    address private administrator;\n    \n    /////////////////////////////////////////////\n    // Pyramid grid data\n    //\n    // The uint32 is the coordinates.\n    // It consists of two uint16's:\n    // The x is the most significant 2 bytes (16 bits)\n    // The y is the least significant 2 bytes (16 bits)\n    // x = coordinates >> 16\n    // y = coordinates & 0xFFFF\n    // coordinates = (x << 16) | y\n    // x is a 16-bit unsigned integer\n    // y is a 16-bit unsigned integer\n    mapping(uint32 => address) public coordinatesToAddresses;\n    uint32[] public allBlockCoordinates;\n    \n    // In the user interface, the rows of blocks will be\n    // progressively shifted more to the right, as y increases\n    // \n    // For example, these blocks in the contract's coordinate system:\n    //         ______\n    //      2 |__A__|______\n    // /|\\  1 |__B__|__D__|______\n    //  |   0 |__C__|__E__|__F__|\n    //  y        0     1     2\n    // \n    //        x -->\n    // \n    // \n    // Become these blocks in the user interface:\n    //    __        ______\n    //    /|     __|__A__|___\n    //   /    __|__B__|__D__|___\n    //  y    |__C__|__E__|__F__|\n    // \n    //   x -->\n    // \n    // \n    \n    /////////////////////////////////////////////\n    // Address properties\n    mapping(address => uint256) public addressesToTotalWeiPlaced;\n    mapping(address => uint256) public addressBalances;\n    \n    ////////////////////////////////////////////\n    // Game Constructor\n    function PyramidGame() public\n    {\n        administrator = msg.sender;\n        adminFeeDivisor = 200; // Default fee is 0.5%\n        \n        // The administrator gets a few free chat messages :-)\n        addressesToChatMessagesLeft[administrator] += 5;\n        \n        // Set the first block in the middle of the bottom row\n        coordinatesToAddresses[uint32(1 << 15) << 16] = msg.sender;\n        allBlockCoordinates.push(uint32(1 << 15) << 16);\n    }\n    \n    ////////////////////////////////////////////\n    // Pyramid grid reading functions\n    function getBetAmountAtLayer(uint16 y) public pure returns (uint256)\n    {\n        // The minimum bet doubles every time you go up 1 layer\n        return BOTTOM_LAYER_BET_AMOUNT * (uint256(1) << y);\n    }\n    \n    function isThereABlockAtCoordinates(uint16 x, uint16 y) public view returns (bool)\n    {\n        return coordinatesToAddresses[(uint32(x) << 16) | uint16(y)] != 0;\n    }\n    \n    function getTotalAmountOfBlocks() public view returns (uint256)\n    {\n        return allBlockCoordinates.length;\n    }\n    \n    ////////////////////////////////////////////\n    // Pyramid grid writing functions\n    function placeBlock(uint16 x, uint16 y) external payable\n    {\n        // You may only place a block on an empty spot\n        require(!isThereABlockAtCoordinates(x, y));\n        \n        // Add the transaction amount to the person's balance\n        addressBalances[msg.sender] += msg.value;\n        \n        // Calculate the required bet amount at the specified layer\n        uint256 betAmount = getBetAmountAtLayer(y);\n\n        // If the block is at the lowest layer...\n        if (y == 0)\n        {\n            // There must be a block to the left or to the right of it\n            require(isThereABlockAtCoordinates(x-1, y) ||\n                    isThereABlockAtCoordinates(x+1, y));\n        }\n        \n        // If the block is NOT at the lowest layer...\n        else\n        {\n            // There must be two existing blocks below it:\n            require(isThereABlockAtCoordinates(x  , y-1) &&\n                    isThereABlockAtCoordinates(x+1, y-1));\n        }\n        \n        // Subtract the bet amount from the person's balance\n        addressBalances[msg.sender] -= betAmount;\n        \n        // Place the block\n        coordinatesToAddresses[(uint32(x) << 16) | y] = msg.sender;\n        allBlockCoordinates.push((uint32(x) << 16) | y);\n        \n        // If the block is at the lowest layer...\n        if (y == 0)\n        {\n            // The bet goes to the administrator\n            addressBalances[administrator] += betAmount;\n        }\n        \n        // If the block is NOT at the lowest layer...\n        else\n        {\n            // Calculate the administrator fee\n            uint256 adminFee = betAmount / adminFeeDivisor;\n            \n            // Calculate the bet amount minus the admin fee\n            uint256 betAmountMinusAdminFee = betAmount - adminFee;\n            \n            // Add the money to the balances of the people below\n            addressBalances[coordinatesToAddresses[(uint32(x  ) << 16) | (y-1)]] += betAmountMinusAdminFee / 2;\n            addressBalances[coordinatesToAddresses[(uint32(x+1) << 16) | (y-1)]] += betAmountMinusAdminFee / 2;\n            \n            // Give the admin fee to the admin\n            addressBalances[administrator] += adminFee;\n        }\n        \n        // The new sender's balance must not have underflowed\n        // (this verifies that the sender has enough balance to place the block)\n        require(addressBalances[msg.sender] < (1 << 255));\n        \n        // Give the sender their chat message rights\n        addressesToChatMessagesLeft[msg.sender] += uint32(1) << y;\n        \n        // Register the sender's total bets placed\n        addressesToTotalWeiPlaced[msg.sender] += betAmount;\n    }\n    \n    ////////////////////////////////////////////\n    // Withdrawing balance\n    function withdrawBalance(uint256 amountToWithdraw) external\n    {\n        require(amountToWithdraw != 0);\n        \n        // The user must have enough balance to withdraw\n        require(addressBalances[msg.sender] >= amountToWithdraw);\n        \n        // Subtract the withdrawn amount from the user's balance\n        addressBalances[msg.sender] -= amountToWithdraw;\n        \n        // Transfer the amount to the user's address\n        // If the transfer() call fails an exception will be thrown,\n        // and therefore the user's balance will be automatically restored\n        msg.sender.transfer(amountToWithdraw);\n    }\n    \n    /////////////////////////////////////////////\n    // Chatbox data\n    struct ChatMessage\n    {\n        address person;\n        string message;\n    }\n    mapping(bytes32 => address) public usernamesToAddresses;\n    mapping(address => bytes32) public addressesToUsernames;\n    mapping(address => uint32) public addressesToChatMessagesLeft;\n    ChatMessage[] public chatMessages;\n    mapping(uint256 => bool) public censoredChatMessages;\n    \n    /////////////////////////////////////////////\n    // Chatbox functions\n    function registerUsername(bytes32 username) external\n    {\n        // The username must not already be token\n        require(usernamesToAddresses[username] == 0);\n        \n        // The address must not already have a username\n        require(addressesToUsernames[msg.sender] == 0);\n        \n        // Register the new username & address combination\n        usernamesToAddresses[username] = msg.sender;\n        addressesToUsernames[msg.sender] = username;\n    }\n    \n    function sendChatMessage(string message) external\n    {\n        // The sender must have at least 1 chat message allowance\n        require(addressesToChatMessagesLeft[msg.sender] >= 1);\n        \n        // Deduct 1 chat message allowence from the sender\n        addressesToChatMessagesLeft[msg.sender]--;\n        \n        // Add the chat message\n        chatMessages.push(ChatMessage(msg.sender, message));\n    }\n    \n    function getTotalAmountOfChatMessages() public view returns (uint256)\n    {\n        return chatMessages.length;\n    }\n    \n    function getChatMessageAtIndex(uint256 index) public view returns (address, bytes32, string)\n    {\n        address person = chatMessages[index].person;\n        bytes32 username = addressesToUsernames[person];\n        return (person, username, chatMessages[index].message);\n    }\n    \n    // In case of chat messages with extremely rude or inappropriate\n    // content, the administrator can censor a chat message.\n    function censorChatMessage(uint256 chatMessageIndex) public\n    {\n        require(msg.sender == administrator);\n        censoredChatMessages[chatMessageIndex] = true;\n    }\n    \n    /////////////////////////////////////////////\n    // Game ownership functions\n    function transferOwnership(address newAdministrator) external\n    {\n        require(msg.sender == administrator);\n        administrator = newAdministrator;\n    }\n    \n    function setFeeDivisor(uint256 newFeeDivisor) external\n    {\n        require(msg.sender == administrator);\n        require(newFeeDivisor >= 20); // The fee may never exceed 5%\n        adminFeeDivisor = newFeeDivisor;\n    }\n}", "debug": "keccac_1_+\n49791959467252497455735130940088646708311117250336157395101362029847983277999_+\n2*storage_9: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_1 +\n49791959467252497455735130940088646708311117250336157395101362029847983277999 +\n2*storage_9: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x100\ncalldata_PyramidGame_0: 0xa7e33a0c00000000000000000000000000000000000000000000000000000000\ncalldatasize_PyramidGame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `sendChatMessage(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/4/0xc3c94e2d9a33ab18d5578bd63dfdaa3e0ea74a49.sol", "function": "sendChatMessage(string)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 6153, "code": "ntract PyramidGame\n{\n    /////////////////////////////////////////////\n    // Game parameters\n    uint256 private constant BOTTOM_LAYER_BET_AMOUNT = 0.005 ether;\n    uint256 private adminFeeDivisor; // e.g. 100 means a 1% fee, 200 means a 0.5% fee\n    \n    /////////////////////////////////////////////\n    // Game owner\n    address private administrator;\n    \n    /////////////////////////////////////////////\n    // Pyramid grid data\n    //\n    // The uint32 is the coordinates.\n    // It consists of two uint16's:\n    // The x is the most significant 2 bytes (16 bits)\n    // The y is the least significant 2 bytes (16 bits)\n    // x = coordinates >> 16\n    // y = coordinates & 0xFFFF\n    // coordinates = (x << 16) | y\n    // x is a 16-bit unsigned integer\n    // y is a 16-bit unsigned integer\n    mapping(uint32 => address) public coordinatesToAddresses;\n    uint32[] public allBlockCoordinates;\n    \n    // In the user interface, the rows of blocks will be\n    // progressively shifted more to the right, as y increases\n    // \n    // For example, these blocks in the contract's coordinate system:\n    //         ______\n    //      2 |__A__|______\n    // /|\\  1 |__B__|__D__|______\n    //  |   0 |__C__|__E__|__F__|\n    //  y        0     1     2\n    // \n    //        x -->\n    // \n    // \n    // Become these blocks in the user interface:\n    //    __        ______\n    //    /|     __|__A__|___\n    //   /    __|__B__|__D__|___\n    //  y    |__C__|__E__|__F__|\n    // \n    //   x -->\n    // \n    // \n    \n    /////////////////////////////////////////////\n    // Address properties\n    mapping(address => uint256) public addressesToTotalWeiPlaced;\n    mapping(address => uint256) public addressBalances;\n    \n    ////////////////////////////////////////////\n    // Game Constructor\n    function PyramidGame() public\n    {\n        administrator = msg.sender;\n        adminFeeDivisor = 200; // Default fee is 0.5%\n        \n        // The administrator gets a few free chat messages :-)\n        addressesToChatMessagesLeft[administrator] += 5;\n        \n        // Set the first block in the middle of the bottom row\n        coordinatesToAddresses[uint32(1 << 15) << 16] = msg.sender;\n        allBlockCoordinates.push(uint32(1 << 15) << 16);\n    }\n    \n    ////////////////////////////////////////////\n    // Pyramid grid reading functions\n    function getBetAmountAtLayer(uint16 y) public pure returns (uint256)\n    {\n        // The minimum bet doubles every time you go up 1 layer\n        return BOTTOM_LAYER_BET_AMOUNT * (uint256(1) << y);\n    }\n    \n    function isThereABlockAtCoordinates(uint16 x, uint16 y) public view returns (bool)\n    {\n        return coordinatesToAddresses[(uint32(x) << 16) | uint16(y)] != 0;\n    }\n    \n    function getTotalAmountOfBlocks() public view returns (uint256)\n    {\n        return allBlockCoordinates.length;\n    }\n    \n    ////////////////////////////////////////////\n    // Pyramid grid writing functions\n    function placeBlock(uint16 x, uint16 y) external payable\n    {\n        // You may only place a block on an empty spot\n        require(!isThereABlockAtCoordinates(x, y));\n        \n        // Add the transaction amount to the person's balance\n        addressBalances[msg.sender] += msg.value;\n        \n        // Calculate the required bet amount at the specified layer\n        uint256 betAmount = getBetAmountAtLayer(y);\n\n        // If the block is at the lowest layer...\n        if (y == 0)\n        {\n            // There must be a block to the left or to the right of it\n            require(isThereABlockAtCoordinates(x-1, y) ||\n                    isThereABlockAtCoordinates(x+1, y));\n        }\n        \n        // If the block is NOT at the lowest layer...\n        else\n        {\n            // There must be two existing blocks below it:\n            require(isThereABlockAtCoordinates(x  , y-1) &&\n                    isThereABlockAtCoordinates(x+1, y-1));\n        }\n        \n        // Subtract the bet amount from the person's balance\n        addressBalances[msg.sender] -= betAmount;\n        \n        // Place the block\n        coordinatesToAddresses[(uint32(x) << 16) | y] = msg.sender;\n        allBlockCoordinates.push((uint32(x) << 16) | y);\n        \n        // If the block is at the lowest layer...\n        if (y == 0)\n        {\n            // The bet goes to the administrator\n            addressBalances[administrator] += betAmount;\n        }\n        \n        // If the block is NOT at the lowest layer...\n        else\n        {\n            // Calculate the administrator fee\n            uint256 adminFee = betAmount / adminFeeDivisor;\n            \n            // Calculate the bet amount minus the admin fee\n            uint256 betAmountMinusAdminFee = betAmount - adminFee;\n            \n            // Add the money to the balances of the people below\n            addressBalances[coordinatesToAddresses[(uint32(x  ) << 16) | (y-1)]] += betAmountMinusAdminFee / 2;\n            addressBalances[coordinatesToAddresses[(uint32(x+1) << 16) | (y-1)]] += betAmountMinusAdminFee / 2;\n            \n            // Give the admin fee to the admin\n            addressBalances[administrator] += adminFee;\n        }\n        \n        // The new sender's balance must not have underflowed\n        // (this verifies that the sender has enough balance to place the block)\n        require(addressBalances[msg.sender] < (1 << 255));\n        \n        // Give the sender their chat message rights\n        addressesToChatMessagesLeft[msg.sender] += uint32(1) << y;\n        \n        // Register the sender's total bets placed\n        addressesToTotalWeiPlaced[msg.sender] += betAmount;\n    }\n    \n    ////////////////////////////////////////////\n    // Withdrawing balance\n    function withdrawBalance(uint256 amountToWithdraw) external\n    {\n        require(amountToWithdraw != 0);\n        \n        // The user must have enough balance to withdraw\n        require(addressBalances[msg.sender] >= amountToWithdraw);\n        \n        // Subtract the withdrawn amount from the user's balance\n        addressBalances[msg.sender] -= amountToWithdraw;\n        \n        // Transfer the amount to the user's address\n        // If the transfer() call fails an exception will be thrown,\n        // and therefore the user's balance will be automatically restored\n        msg.sender.transfer(amountToWithdraw);\n    }\n    \n    /////////////////////////////////////////////\n    // Chatbox data\n    struct ChatMessage\n    {\n        address person;\n        string message;\n    }\n    mapping(bytes32 => address) public usernamesToAddresses;\n    mapping(address => bytes32) public addressesToUsernames;\n    mapping(address => uint32) public addressesToChatMessagesLeft;\n    ChatMessage[] public chatMessages;\n    mapping(uint256 => bool) public censoredChatMessages;\n    \n    /////////////////////////////////////////////\n    // Chatbox functions\n    function registerUsername(bytes32 username) external\n    {\n        // The username must not already be token\n        require(usernamesToAddresses[username] == 0);\n        \n        // The address must not already have a username\n        require(addressesToUsernames[msg.sender] == 0);\n        \n        // Register the new username & address combination\n        usernamesToAddresses[username] = msg.sender;\n        addressesToUsernames[msg.sender] = username;\n    }\n    \n    function sendChatMessage(string message) external\n    {\n        // The sender must have at least 1 chat message allowance\n        require(addressesToChatMessagesLeft[msg.sender] >= 1);\n        \n        // Deduct 1 chat message allowence from the sender\n        addressesToChatMessagesLeft[msg.sender]--;\n        \n        // Add the chat message\n        chatMessages.push(ChatMessage(msg.sender, message));\n    }\n    \n    function getTotalAmountOfChatMessages() public view returns (uint256)\n    {\n        return chatMessages.length;\n    }\n    \n    function getChatMessageAtIndex(uint256 index) public view returns (address, bytes32, string)\n    {\n        address person = chatMessages[index].person;\n        bytes32 username = addressesToUsernames[person];\n        return (person, username, chatMessages[index].message);\n    }\n    \n    // In case of chat messages with extremely rude or inappropriate\n    // content, the administrator can censor a chat message.\n    function censorChatMessage(uint256 chatMessageIndex) public\n    {\n        require(msg.sender == administrator);\n        censoredChatMessages[chatMessageIndex] = true;\n    }\n    \n    /////////////////////////////////////////////\n    // Game ownership functions\n    function transferOwnership(address newAdministrator) external\n    {\n        require(msg.sender == administrator);\n        administrator = newAdministrator;\n    }\n    \n    function setFeeDivisor(uint256 newFeeDivisor) external\n    {\n        require(msg.sender == administrator);\n        require(newFeeDivisor >= 20); // The fee may never exceed 5%\n        adminFeeDivisor = newFeeDivisor;\n    }\n}", "debug": "calldata_PyramidGame_4 + calldata_PyramidGame_4: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x100\ncalldata_PyramidGame_0: 0xa7e33a0c00000000000000000000000000000000000000000000000000000000\ncalldatasize_PyramidGame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `sendChatMessage(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/4/0xc3c94e2d9a33ab18d5578bd63dfdaa3e0ea74a49.sol", "function": "sendChatMessage(string)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 6167, "code": "ntract PyramidGame\n{\n    /////////////////////////////////////////////\n    // Game parameters\n    uint256 private constant BOTTOM_LAYER_BET_AMOUNT = 0.005 ether;\n    uint256 private adminFeeDivisor; // e.g. 100 means a 1% fee, 200 means a 0.5% fee\n    \n    /////////////////////////////////////////////\n    // Game owner\n    address private administrator;\n    \n    /////////////////////////////////////////////\n    // Pyramid grid data\n    //\n    // The uint32 is the coordinates.\n    // It consists of two uint16's:\n    // The x is the most significant 2 bytes (16 bits)\n    // The y is the least significant 2 bytes (16 bits)\n    // x = coordinates >> 16\n    // y = coordinates & 0xFFFF\n    // coordinates = (x << 16) | y\n    // x is a 16-bit unsigned integer\n    // y is a 16-bit unsigned integer\n    mapping(uint32 => address) public coordinatesToAddresses;\n    uint32[] public allBlockCoordinates;\n    \n    // In the user interface, the rows of blocks will be\n    // progressively shifted more to the right, as y increases\n    // \n    // For example, these blocks in the contract's coordinate system:\n    //         ______\n    //      2 |__A__|______\n    // /|\\  1 |__B__|__D__|______\n    //  |   0 |__C__|__E__|__F__|\n    //  y        0     1     2\n    // \n    //        x -->\n    // \n    // \n    // Become these blocks in the user interface:\n    //    __        ______\n    //    /|     __|__A__|___\n    //   /    __|__B__|__D__|___\n    //  y    |__C__|__E__|__F__|\n    // \n    //   x -->\n    // \n    // \n    \n    /////////////////////////////////////////////\n    // Address properties\n    mapping(address => uint256) public addressesToTotalWeiPlaced;\n    mapping(address => uint256) public addressBalances;\n    \n    ////////////////////////////////////////////\n    // Game Constructor\n    function PyramidGame() public\n    {\n        administrator = msg.sender;\n        adminFeeDivisor = 200; // Default fee is 0.5%\n        \n        // The administrator gets a few free chat messages :-)\n        addressesToChatMessagesLeft[administrator] += 5;\n        \n        // Set the first block in the middle of the bottom row\n        coordinatesToAddresses[uint32(1 << 15) << 16] = msg.sender;\n        allBlockCoordinates.push(uint32(1 << 15) << 16);\n    }\n    \n    ////////////////////////////////////////////\n    // Pyramid grid reading functions\n    function getBetAmountAtLayer(uint16 y) public pure returns (uint256)\n    {\n        // The minimum bet doubles every time you go up 1 layer\n        return BOTTOM_LAYER_BET_AMOUNT * (uint256(1) << y);\n    }\n    \n    function isThereABlockAtCoordinates(uint16 x, uint16 y) public view returns (bool)\n    {\n        return coordinatesToAddresses[(uint32(x) << 16) | uint16(y)] != 0;\n    }\n    \n    function getTotalAmountOfBlocks() public view returns (uint256)\n    {\n        return allBlockCoordinates.length;\n    }\n    \n    ////////////////////////////////////////////\n    // Pyramid grid writing functions\n    function placeBlock(uint16 x, uint16 y) external payable\n    {\n        // You may only place a block on an empty spot\n        require(!isThereABlockAtCoordinates(x, y));\n        \n        // Add the transaction amount to the person's balance\n        addressBalances[msg.sender] += msg.value;\n        \n        // Calculate the required bet amount at the specified layer\n        uint256 betAmount = getBetAmountAtLayer(y);\n\n        // If the block is at the lowest layer...\n        if (y == 0)\n        {\n            // There must be a block to the left or to the right of it\n            require(isThereABlockAtCoordinates(x-1, y) ||\n                    isThereABlockAtCoordinates(x+1, y));\n        }\n        \n        // If the block is NOT at the lowest layer...\n        else\n        {\n            // There must be two existing blocks below it:\n            require(isThereABlockAtCoordinates(x  , y-1) &&\n                    isThereABlockAtCoordinates(x+1, y-1));\n        }\n        \n        // Subtract the bet amount from the person's balance\n        addressBalances[msg.sender] -= betAmount;\n        \n        // Place the block\n        coordinatesToAddresses[(uint32(x) << 16) | y] = msg.sender;\n        allBlockCoordinates.push((uint32(x) << 16) | y);\n        \n        // If the block is at the lowest layer...\n        if (y == 0)\n        {\n            // The bet goes to the administrator\n            addressBalances[administrator] += betAmount;\n        }\n        \n        // If the block is NOT at the lowest layer...\n        else\n        {\n            // Calculate the administrator fee\n            uint256 adminFee = betAmount / adminFeeDivisor;\n            \n            // Calculate the bet amount minus the admin fee\n            uint256 betAmountMinusAdminFee = betAmount - adminFee;\n            \n            // Add the money to the balances of the people below\n            addressBalances[coordinatesToAddresses[(uint32(x  ) << 16) | (y-1)]] += betAmountMinusAdminFee / 2;\n            addressBalances[coordinatesToAddresses[(uint32(x+1) << 16) | (y-1)]] += betAmountMinusAdminFee / 2;\n            \n            // Give the admin fee to the admin\n            addressBalances[administrator] += adminFee;\n        }\n        \n        // The new sender's balance must not have underflowed\n        // (this verifies that the sender has enough balance to place the block)\n        require(addressBalances[msg.sender] < (1 << 255));\n        \n        // Give the sender their chat message rights\n        addressesToChatMessagesLeft[msg.sender] += uint32(1) << y;\n        \n        // Register the sender's total bets placed\n        addressesToTotalWeiPlaced[msg.sender] += betAmount;\n    }\n    \n    ////////////////////////////////////////////\n    // Withdrawing balance\n    function withdrawBalance(uint256 amountToWithdraw) external\n    {\n        require(amountToWithdraw != 0);\n        \n        // The user must have enough balance to withdraw\n        require(addressBalances[msg.sender] >= amountToWithdraw);\n        \n        // Subtract the withdrawn amount from the user's balance\n        addressBalances[msg.sender] -= amountToWithdraw;\n        \n        // Transfer the amount to the user's address\n        // If the transfer() call fails an exception will be thrown,\n        // and therefore the user's balance will be automatically restored\n        msg.sender.transfer(amountToWithdraw);\n    }\n    \n    /////////////////////////////////////////////\n    // Chatbox data\n    struct ChatMessage\n    {\n        address person;\n        string message;\n    }\n    mapping(bytes32 => address) public usernamesToAddresses;\n    mapping(address => bytes32) public addressesToUsernames;\n    mapping(address => uint32) public addressesToChatMessagesLeft;\n    ChatMessage[] public chatMessages;\n    mapping(uint256 => bool) public censoredChatMessages;\n    \n    /////////////////////////////////////////////\n    // Chatbox functions\n    function registerUsername(bytes32 username) external\n    {\n        // The username must not already be token\n        require(usernamesToAddresses[username] == 0);\n        \n        // The address must not already have a username\n        require(addressesToUsernames[msg.sender] == 0);\n        \n        // Register the new username & address combination\n        usernamesToAddresses[username] = msg.sender;\n        addressesToUsernames[msg.sender] = username;\n    }\n    \n    function sendChatMessage(string message) external\n    {\n        // The sender must have at least 1 chat message allowance\n        require(addressesToChatMessagesLeft[msg.sender] >= 1);\n        \n        // Deduct 1 chat message allowence from the sender\n        addressesToChatMessagesLeft[msg.sender]--;\n        \n        // Add the chat message\n        chatMessages.push(ChatMessage(msg.sender, message));\n    }\n    \n    function getTotalAmountOfChatMessages() public view returns (uint256)\n    {\n        return chatMessages.length;\n    }\n    \n    function getChatMessageAtIndex(uint256 index) public view returns (address, bytes32, string)\n    {\n        address person = chatMessages[index].person;\n        bytes32 username = addressesToUsernames[person];\n        return (person, username, chatMessages[index].message);\n    }\n    \n    // In case of chat messages with extremely rude or inappropriate\n    // content, the administrator can censor a chat message.\n    function censorChatMessage(uint256 chatMessageIndex) public\n    {\n        require(msg.sender == administrator);\n        censoredChatMessages[chatMessageIndex] = true;\n    }\n    \n    /////////////////////////////////////////////\n    // Game ownership functions\n    function transferOwnership(address newAdministrator) external\n    {\n        require(msg.sender == administrator);\n        administrator = newAdministrator;\n    }\n    \n    function setFeeDivisor(uint256 newFeeDivisor) external\n    {\n        require(msg.sender == administrator);\n        require(newFeeDivisor >= 20); // The fee may never exceed 5%\n        adminFeeDivisor = newFeeDivisor;\n    }\n}", "debug": "calldata_PyramidGame_4 + calldata_PyramidGame_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x100\ncalldata_PyramidGame_0: 0xa7e33a0c00000000000000000000000000000000000000000000000000000000\ncalldatasize_PyramidGame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `sendChatMessage(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/4/0xc3c94e2d9a33ab18d5578bd63dfdaa3e0ea74a49.sol", "function": "sendChatMessage(string)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}], "success": true}