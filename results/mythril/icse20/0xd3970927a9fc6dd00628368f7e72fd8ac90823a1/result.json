{
  "contract": "0xd3970927a9fc6dd00628368f7e72fd8ac90823a1",
  "tool": "mythril",
  "start": 1563561004.9687653,
  "end": 1563561086.3092773,
  "duration": 81.34051203727722,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 12870,
        "code": "ol token Symbol.\n     * @field voters Proposers.\n     * @field weight The weight value of the completed time.\n     */\n    struct Proposal {\n\n        bool status;\n\n        address fromAccount;\n\n        address toAccount;\n\n        uint value;\n\n        bytes32 tokenSymbol;\n\n        address[] voters;\n\n        uint weight;\n    }\n\n    /**\n     * Trusted Platform\n     * @field status Trusted platform state(false:no trusted,true:trusted).\n     * @field weight weight of platform.\n     * @field publicKeys list of public key.\n     * @field proposals list of proposal.\n     */\n    struct Platform {\n\n        bool status;\n\n        uint weight;\n\n        address[] publicKeys;\n\n        mapping(string => Proposal) proposals;\n    }\n\n    Admin private admin;\n\n    address[] private callers;\n\n    mapping(bytes32 => Platform) private platforms;\n\n    function XCPlugin() public {\n\n        init();\n    }\n\n    function init() internal {\n        // Admin { status | platformName | tokenSymbol | account}\n        admin.status = true;\n\n        admin.platformName = \"ETH\";\n\n        admin.tokenSymbol = \"INK\";\n\n        admin.account = msg.sender;\n\n        bytes32 platformName = \"INK\";\n\n        platforms[platformName].status = true;\n\n        platforms[platformName].weight = 1;\n\n        platforms[platformName].publicKeys.push(0x4230a12f5b0693dd88bb35c79d7e56a68614b199);\n\n        platforms[platformName].publicKeys.push(0x07caf88941eafcaaa3370657fccc261acb75dfba);\n    }\n\n    function start() external {\n\n        require(admin.account == msg.sender);\n\n        if (!admin.status) {\n\n            admin.status = true;\n        }\n    }\n\n    function stop() external {\n\n        require(admin.account == msg.sender);\n\n        if (admin.status) {\n\n            admin.status = false;\n        }\n    }\n\n    function getStatus() external view returns (bool) {\n\n        return admin.status;\n    }\n\n    function getPlatformName() external view returns (bytes32) {\n\n        return admin.platformName;\n    }\n\n    function setAdmin(address account) external {\n\n        require(account != address(0));\n\n        require(admin.account == msg.sender);\n\n        if (admin.account != account) {\n\n            admin.account = account;\n        }\n    }\n\n    function getAdmin() external view returns (address) {\n\n        return admin.account;\n    }\n\n    function addCaller(address caller) external {\n\n        require(admin.account == msg.sender);\n\n        if (!_existCaller(caller)) {\n\n            callers.push(caller);\n        }\n    }\n\n    function deleteCaller(address caller) external {\n\n        require(admin.account == msg.sender);\n\n        if (_existCaller(caller)) {\n\n            bool exist;\n\n            for (uint i = 0; i <= callers.length; i++) {\n\n                if (exist) {\n\n                    if (i == callers.length) {\n\n                        delete callers[i - 1];\n\n                        callers.length--;\n                    } else {\n\n                        callers[i - 1] = callers[i];\n                    }\n                } else if (callers[i] == caller) {\n\n                    exist = true;\n                }\n            }\n\n        }\n    }\n\n    function existCaller(address caller) external view returns (bool) {\n\n        return _existCaller(caller);\n    }\n\n    function getCallers() external view returns (address[]) {\n\n        require(admin.account == msg.sender);\n\n        return callers;\n    }\n\n    function addPlatform(bytes32 name) external {\n\n        require(admin.account == msg.sender);\n\n        require(name != \"\");\n\n        require(name != admin.platformName);\n\n        if (!_existPlatform(name)) {\n\n            platforms[name].status = true;\n\n            if (platforms[name].weight == 0) {\n\n                platforms[name].weight = 1;\n            }\n        }\n    }\n\n    function deletePlatform(bytes32 name) external {\n\n        require(admin.account == msg.sender);\n\n        require(name != admin.platformName);\n\n        if (_existPlatform(name)) {\n\n            platforms[name].status = false;\n        }\n    }\n\n    function existPlatform(bytes32 name) external view returns (bool){\n\n        return _existPlatform(name);\n    }\n\n    function setWeight(bytes32 platformName, uint weight) external {\n\n        require(admin.account == msg.sender);\n\n        require(_existPlatform(platformName));\n\n        require(weight > 0);\n\n        if (platforms[platformName].weight != weight) {\n\n            platforms[platformName].weight = weight;\n        }\n    }\n\n    function getWeight(bytes32 platformName) external view returns (uint) {\n\n        require(admin.account == msg.sender);\n\n        require(_existPlatform(platformName));\n\n        return platforms[platformName].weight;\n    }\n\n    function addPublicKey(bytes32 platformName, address publicKey) external {\n\n        require(admin.account == msg.sender);\n\n        require(_existPlatform(platformName));\n\n        require(publicKey != address(0));\n\n        address[] storage listOfPublicKey = platforms[platformName].publicKeys;\n\n        for (uint i; i < listOfPublicKey.length; i++) {\n\n            if (publicKey == listOfPublicKey[i]) {\n\n                return;\n            }\n        }\n\n        listOfPublicKey.push(publicKey);\n    }\n\n    function deletePublicKey(bytes32 platformName, address publickey) external {\n\n        require(admin.account == msg.sender);\n\n        require(_existPlatform(platformName));\n\n        address[] storage listOfPublicKey = platforms[platformName].publicKeys;\n\n        bool exist;\n\n        for (uint i = 0; i <= listOfPublicKey.length; i++) {\n\n            if (exist) {\n                if (i == listOfPublicKey.length) {\n\n                    delete listOfPublicKey[i - 1];\n\n                    listOfPublicKey.length--;\n                } else {\n\n                    listOfPublicKey[i - 1] = listOfPublicKey[i];\n                }\n            } else if (listOfPublicKey[i] == publickey) {\n\n                exist = true;\n            }\n        }\n    }\n\n    function existPublicKey(bytes32 platformName, address publicKey) external view returns (bool) {\n\n        require(admin.account == msg.sender);\n\n        return _existPublicKey(platformName, publicKey);\n    }\n\n    function countOfPublicKey(bytes32 platformName) external view returns (uint){\n\n        require(admin.account == msg.sender);\n\n        require(_existPlatform(platformName));\n\n        return platforms[platformName].publicKeys.length;\n    }\n\n    function publicKeys(bytes32 platformName) external view returns (address[]){\n\n        require(admin.account == msg.sender);\n\n        require(_existPlatform(platformName));\n\n        return platforms[platformName].publicKeys;\n    }\n\n    function voteProposal(bytes32 fromPlatform, address fromAccount, address toAccount, uint value, bytes32 tokenSymbol, string txid, bytes sig) external {\n\n        require(admin.status);\n\n        require(_existPlatform(fromPlatform));\n\n        bytes32 msgHash = hashMsg(fromPlatform, fromAccount, admin.platformName, toAccount, value, tokenSymbol, txid);\n\n        // address publicKey = ecrecover(msgHash, v, r, s);\n        address publicKey = recover(msgHash, sig);\n\n        require(_existPublicKey(fromPlatform, publicKey));\n\n        Proposal storage proposal = platforms[fromPlatform].proposals[txid];\n\n        if (proposal.value == 0) {\n\n            proposal.fromAccount = fromAccount;\n\n            proposal.toAccount = toAccount;\n\n            proposal.value = value;\n\n            proposal.tokenSymbol = tokenSymbol;\n        } else {\n\n            require(proposal.fromAccount == fromAccount && proposal.toAccount == toAccount && proposal.value == value && proposal.tokenSymbol == tokenSymbol);\n        }\n\n        changeVoters(fromPlatform, publicKey, txid);\n    }\n\n    function verifyProposal(bytes32 fromPlatform, address fromAccount, address toAccount, uint value, bytes32 tokenSymbol, string txid) external view returns (bool, bool) {\n\n        require(admin.status);\n\n        require(_existPlatform(fromPlatform));\n\n        Proposal storage proposal = platforms[fromPlatform].proposals[txid];\n\n        if (proposal.status) {\n\n            return (true, (proposal.voters.length >= proposal.weight));\n        }\n\n        if (proposal.value == 0) {\n\n            return (false, false);\n        }\n\n        require(proposal.fromAccount == fromAccount && proposal.toAccount == toAccount && proposal.value == value && proposal.tokenSymbol == tokenSymbol);\n\n        return (false, (proposal.voters.length >= platforms[fromPlatform].weight));\n    }\n\n    function commitProposal(bytes32 platformName, string txid) external returns (bool) {\n\n        require(admin.status);\n\n        require(_existCaller(msg.sender) || msg.sender == admin.account);\n\n        require(_existPlatform(platformName));\n\n        require(!platforms[platformName].proposals[txid].status);\n\n        platforms[platformName].proposals[txid].status = true;\n\n        platforms[platformName].proposals[txid].weight = platforms[platformName].proposals[txid].voters.length;\n\n        return true;\n    }\n\n    function getProposal(bytes32 platformName, string txid) external view returns (bool status, address fromAccount, address toAccount, uint value, address[] voters, uint weight){\n\n        require(admin.status);\n\n        require(_existPlatform(platformName));\n\n        fromAccount = platforms[platformName].proposals[txid].fromAccount;\n\n        toAccount = platforms[platformName].proposals[txid].toAccount;\n\n        value = platforms[platformName].proposals[txid].value;\n\n        voters = platforms[platformName].proposals[txid].voters;\n\n        status = platforms[platformName].proposals[txid].status;\n\n        weight = platforms[platformName].proposals[txid].weight;\n\n        return;\n    }\n\n    function deleteProposal(bytes32 platformName, string txid) external {\n\n        require(msg.sender == admin.account);\n\n        require(_existPlatform(platformName));\n\n        delete platforms[platformName].proposals[txid];\n    }\n\n    function transfer(address account, uint value) external payable {\n\n        require(admin.account == msg.sender);\n\n        require(account != address(0));\n\n        require(value > 0 && value >= address(this).balance);\n\n        this.transfer(account, value);\n    }\n\n    /**\n     *   ######################\n     *  #  private function  #\n     * ######################\n     */\n\n    function hashMsg(bytes32 fromPlatform, address fromAccount, bytes32 toPlatform, address toAccount, uint value, bytes32 tokenSymbol, string txid) internal pure returns (bytes32) {\n\n        return sha256(bytes32ToStr(fromPlatform), \":0x\", uintToStr(uint160(fromAccount), 16), \":\", bytes32ToStr(toPlatform), \":0x\", uintToStr(uint160(toAccount), 16), \":\", uintToStr(value, 10), \":\", bytes32ToStr(tokenSymbol), \":\", txid);\n    }\n\n    function changeVoters(bytes32 platformName, address publicKey, string txid) internal {\n\n        address[] storage voters = platforms[platformName].proposals[txid].voters;\n\n        bool change = true;\n\n        for (uint i = 0; i < voters.length; i++) {\n\n            if (voters[i] == publicKey) {\n\n                change = false;\n            }\n        }\n\n        if (change) {\n\n            voters.push(publicKey);\n        }\n    }\n\n    function bytes32ToStr(bytes32 b) internal pure returns (string) {\n\n        uint length = b.length;\n\n        for (uint i = 0; i < b.length; i++) {\n\n            if (b[b.length - 1 - i] == \"\") {\n\n                length -= 1;\n            } else {\n\n                break;\n            }\n        }\n\n        bytes memory bs = new bytes(length);\n\n        for (uint j = 0; j < length; j++) {\n\n            bs[j] = b[j];\n        }\n\n        return string(bs);\n    }\n\n    function uintToStr(uint value, uint base) internal pure returns (string) {\n\n        uint _value = value;\n\n        uint length = 0;\n\n        bytes16 tenStr = \"0123456789abcdef\";\n\n        while (true) {\n\n            if (_value > 0) {\n\n                length ++;\n\n                _value = _value / base;\n            } else {\n\n                break;\n            }\n        }\n\n        if (base == 16) {\n            length = 40;\n        }\n\n        bytes memory bs = new bytes(length);\n\n        for (uint i = 0; i < length; i++) {\n\n            bs[length - 1 - i] = tenStr[value % base];\n\n            value = value / base;\n        }\n\n        return string(bs);\n    }\n\n    function _existCaller(address caller) internal view returns (bool) {\n\n        for (uint i = 0; i < callers.length; i++) {\n\n            if (callers[i] == caller) {\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function _existPlatform(bytes32 name) internal view returns (bool){\n\n        return platforms[name].status;\n    }\n\n    function _existPublicKey(bytes32 platformName, address publicKey) internal view returns (bool) {\n\n\n        address[] memory listOfPublicKey = platforms[platformName].publicKeys;\n\n        for (uint i = 0; i < listOfPublicKey.length; i++) {\n\n            if (listOfPublicKey[i] == publicKey) {\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function recover(bytes32 hash, bytes sig) internal pure returns (address) {\n\n        bytes32 r;\n\n        bytes32 s;\n\n        uint8 v;\n\n        assembly {\n\n            r := mload(add(sig, 32))\n\n            s := mload(add(sig, 64))\n\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        if (v < 27) {\n\n            v += 27;\n        }\n\n        return ecrecover(hash, v, r, s);\n    }\n}",
        "debug": "storage_KECCAC_mem_128) + 4: 0x57f25cd000000000000000000000000000000000000000000000000000000000\nkeccac_KECCAC_mem_128)_+_4: 0xa8795cd3fffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_0 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_XCPluginInterface_4: 0xff00\nstorage_3: 0x0\ncaller: 0x0\ncalldata_XCPluginInterface_0: 0x4d7ad1dd00000000000000000000000000000000000000000000000000000000\ncalldatasize_XCPluginInterface: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `deleteProposal(bytes32,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/17/0xd3970927a9fc6dd00628368f7e72fd8ac90823a1.sol",
        "function": "deleteProposal(bytes32,string)",
        "lineno": 733,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}