{
  "contract": "0x1f988b4ee752826e834f478b7668725ae7ecf53c",
  "tool": "mythril",
  "start": 1563525477.238081,
  "end": 1563525756.2283363,
  "duration": 278.99025535583496,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 1736,
        "code": "tion address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\tservices[_targetApplicationAddress][_serviceId].serviceDescription=_serviceDescription;\n\t\t\n\t\temit ServiceChanged(_targetApplicationAddress, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction updateServiceTokensPerCredit (\n\t\t\taddress _targetApplicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tuint256 _tokensPerCredit ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_targetApplicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if ",
        "debug": "calldata_U42_32 + 36: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_U42_0: 0x274fadf600000000000000000000000000000000000000000000000000000000\ncalldatasize_U42: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x274fadf6`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/10/0x1f988b4ee752826e834f478b7668725ae7ecf53c.sol",
        "function": "_function_0x274fadf6",
        "lineno": 388,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2037,
        "code": "//returns true if service has been removed\n\t\treturn services[_applicationAddress][_serviceId].isRemoved;\n\t}\n\n\tfunction getServiceInformation ( \n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _se",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_U42_4: 0x800000000000000000000000000000000000000000000000000000000000000\ncalldata_U42_0: 0x28f22cc100000000000000000000000000000000000000000000000000000000\ncalldatasize_U42: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x28f22cc1`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/10/0x1f988b4ee752826e834f478b7668725ae7ecf53c.sol",
        "function": "_function_0x28f22cc1",
        "lineno": 324,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 7438,
        "code": "servicesLists[msg.sender].push(_serviceId);\n\n\t\t//emit NewService\n\t\temit NewService(msg.sender, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction getServicesForApplication ( \n\t\t\taddress _applicationAddress ) \n\t\tpublic view returns (\n\t\t\tuint32[]",
        "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_U42_4 + calldata_U42_32 + 4)) +\n96: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\ncaller: 0x0\ncalldata_U42_32 + 100: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_U42_32 + 132: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_U42_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0 +\nkeccac_4294967295_&_4294967295_&_4294967295_&_calldata_U42_4: 0x0\ncalldata_U42_4: 0xffffffff\ncalldata_U42_0: 0x16a7859b00000000000000000000000000000000000000000000000000000000\ncalldatasize_U42: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x16a7859b`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/10/0x1f988b4ee752826e834f478b7668725ae7ecf53c.sol",
        "function": "_function_0x16a7859b",
        "lineno": 294,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 7731,
        "code": "e U42 Token Specif",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nkeccac_1_+\nkeccac_4294967295_&_4294967295_&_4294967295_&_calldata_U42_4: 0xfe300e18c158ec412f5c4ede49124210c0840a26d60f2007ff5ff3ffff7ffd4e\nstorage_1 +\nkeccac_4294967295_&_4294967295_&_4294967295_&_calldata_U42_4: 0xdd83f7f8af5940bbbafeca9a46defb91bd4a9c9c8467e400400300002000f0c5\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_U42_4 + calldata_U42_32 + 4)) +\n96: 0x0\ncaller: 0x0\ncalldata_U42_32 + 100: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_U42_32 + 132: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_U42_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0 +\nkeccac_4294967295_&_4294967295_&_4294967295_&_calldata_U42_4: 0x0\ncalldata_U42_4: 0xffffffff\ncalldata_U42_0: 0x16a7859b00000000000000000000000000000000000000000000000000000000\ncalldatasize_U42: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x16a7859b`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/10/0x1f988b4ee752826e834f478b7668725ae7ecf53c.sol",
        "function": "_function_0x16a7859b",
        "lineno": 1,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 7743,
        "code": "ss];\n\t}\n\n\tfunction getRemovedServicesForAp",
        "debug": "keccac_1_+\nkeccac_4294967295_&_4294967295_&_4294967295_&_calldata_U42_4: 0xff8243e83475260000000000292c41a054453f7aa00003033bb91097d7984bab\nstorage_1 +\nkeccac_4294967295_&_4294967295_&_4294967295_&_calldata_U42_4: 0xc3a51fffffffffffffffffffffffffffffffffffffffffffffffffffffffffc9\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_U42_4 + calldata_U42_32 + 4)) +\n96: 0x0\ncaller: 0x0\ncalldata_U42_32 + 100: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_U42_32 + 132: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_U42_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0 +\nkeccac_4294967295_&_4294967295_&_4294967295_&_calldata_U42_4: 0x0\ncalldata_U42_4: 0xffffffff\ncalldata_U42_0: 0x16a7859b00000000000000000000000000000000000000000000000000000000\ncalldatasize_U42: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `_function_0x16a7859b`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_chucks/10/0x1f988b4ee752826e834f478b7668725ae7ecf53c.sol",
        "function": "_function_0x16a7859b",
        "lineno": 307,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 10823,
        "code": "ion ( \n\t\t\taddress _applicationAddress, \n\t\t\tuint3",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_U42_4: 0x8421003f084001f4210815cf88407c00000000000000037c1d000e8d178001f\ncalldata_U42_0: 0x28f22cc100000000000000000000000000000000000000000000000000000000\ncalldatasize_U42: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x28f22cc1`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/10/0x1f988b4ee752826e834f478b7668725ae7ecf53c.sol",
        "function": "_function_0x28f22cc1",
        "lineno": 328,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 10825,
        "code": "ion ( \n\t\t\taddress _applicationAddress, \n\t\t\tuint3",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_U42_4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\ncalldata_U42_0: 0x28f22cc100000000000000000000000000000000000000000000000000000000\ncalldatasize_U42: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x28f22cc1`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/10/0x1f988b4ee752826e834f478b7668725ae7ecf53c.sol",
        "function": "_function_0x28f22cc1",
        "lineno": 328,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 21858,
        "code": "act U",
        "debug": "calldata_U42_32 + 36: 0xfe51000008ce80008001c1d33616877ffffffffffffff7ffffe10000398d50ac\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_U42_32_+_4: 0xc050fffff320c00020003d81af848540000000000000040000110001bd062022\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xfe51000008ce80008001c1d33616877ffffffffffffff7ffffe10000398d50ac\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_U42_4: 0xfe51000008ce80008001c1d33616877ffffffffffffff7ffffe10000398d50ac\ncalldata_U42_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_U42_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncalldatasize_U42: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x23b872dd`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/10/0x1f988b4ee752826e834f478b7668725ae7ecf53c.sol",
        "function": "_function_0x23b872dd",
        "lineno": 60,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 21871,
        "code": "/use OZ SafeMa",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_U42_32 + 36: 0x53632f08ddbb360427befb69cb0d577a76825c1eb02b4cefbf971939ae256117\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_U42_32_+_4: 0xd32ba62e013a1e544c40f8298f8c838ef0ca495e903244487f8ba1f8c2a013e7\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x53632f08ddbb360427befb69cb0d577a76825c1eb02b4cefbf971939ae256117\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_U42_4: 0x53632f08ddbb360427befb69cb0d577a76825c1eb02b4cefbf971939ae256117\ncalldata_U42_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_U42_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncalldatasize_U42: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/10/0x1f988b4ee752826e834f478b7668725ae7ecf53c.sol",
        "function": "_function_0x23b872dd",
        "lineno": 61,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 21976,
        "code": "s\n\tusing SafeMath for uint256;\n\n\tstring public constant name = \"U42\";\n\tstring public constant symbol = \"U42\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant initialSupply = 525000000 * (10 ** uint256(decimals));\n\tuint256 internal totalSupply_ = initialSupply;\n\taddress public contractOwner;\n\n\t//token balances\n\tmapping(address => uint256) balances;\n\n\t//for each balance address, map allowed addresses to amount allowed\n\tmapping (address => mapping (address => uint256)) internal allowed;\n\n\t//each service is represented by a Service struct \n\tstruct Service {\n\t\taddress applicationAddress;\n\t\tuint32 serviceId;\n\t\tbool isSimple;\n\t\tstring serviceDescription;\n\t\tuint256 tokensPerCredit;\n\t\tuint256 maxCreditsPerProvision;\n\t\taddress updateAddress;\n\t\taddress receiptAddress;\n\t\tbool isRemoved;\n\t\tuint256 provisionHead;\n\t}\n\n\tstruct Provision {\n\t\tuint256 tokensPerCredit;\n\t\tuint256 creditsRemaining;\n\t\tuint256 applicationReference;\n\t\taddress userAddress;\n\t\tuint256 creditsProvisioned;\n\t}\n\n\t//mapping of application addresses to service structs\n\tmapping (address => mapping (uint32 => Service)) services;\n\n\t//mapping of application addresses to service structs to provisions\n\tmapping (address => mapping (uint32 => mapping (uint256 => Provision))) provisions;\n\n\t//mapping of application addresses to lists of services\n\tmapping (address => uint32[]) servicesLists;\n\n\t//mapping of application addresses to lists of removed services\n\tmapping (address => uint32[]) servicesRemovedLists;\n\n\t//methods emit the following events\n\tevent Transfer (\n\t\taddress indexed from, \n\t\taddress indexed to, \n\t\tuint256 value );\n\n\tevent TokensBurned (\n\t\taddress indexed burner, \n\t\tuint256 value );\n\n\tevent Approval (\n\t\taddress indexed owner,\n\t\taddress indexed spender,\n\t\tuint256 value );\n\n\tevent NewService (\n\t\taddress indexed applicationAddress,\n\t\tuint32 serviceId );\n\n\tevent ServiceChanged (\n\t\taddress indexed applicationAddress,\n\t\tuint32 serviceId );\n\n\tevent ServiceRemoved (\n\t\taddress indexed applicationAddress,\n\t\tuint32 serviceId );\n\n\tevent CompleteSimpleProvision (\n\t\taddress indexed applicationAddress,\n\t\tuint32 indexed serviceId,\n\t\taddress indexed userAddress,\n\t\tuint256 multiple,\n\t\tuint256 applicationReference );\n\n\tevent ReferenceConfirmed (\n\t\taddress indexed applicationAddress,\n\t\tuint256 indexed applicationReference, \n\t\taddress indexed confirmedBy, \n\t\tuint256 confirmerTokensMinimum );\n\n\tevent StartProvision (\n\t    address indexed applicationAddress, \n\t    uint32 indexed serviceId, \n\t    address indexed userAddress,\n\t    uint256 provisionId,\n\t    uint256 serviceCredits,\n\t    uint256 tokensPerCredit, \n\t    uint256 applicationReference );\n\n\tevent UpdateProvision (\n\t    address indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    uint256 creditsRemaining );\n\n\tevent CompleteProvision (\n\t    address indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    uint256 creditsOutstanding );\n\n\tevent SignalProvisionRefund (\n\t    address indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    uint256 tokenValue );\n\n\tevent TransferBecauseOf (\n\t\taddress indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    address from,\n\t    address to,\n\t    uint256 value );\n\n\tevent TransferBecauseOfAggregate (\n\t\taddress indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256[] provisionIds,\n\t    uint256[] tokenAmounts,\n\t    address from,\n\t    address to,\n\t    uint256 value );\n\n\n\tconstructor() public {\n\t\t//contract creator holds all tokens at creation\n\t\tbalances[msg.sender] = totalSupply_;\n\n\t\t//record contract owner for later reference (e.g. in ownerBurn)\n\t\tcontractOwner=msg.sender;\n\n\t\t//indicate all tokens were sent to contract address\n\t\temit Transfer(address(0), msg.sender, totalSupply_);\n\t}\n\n\tfunction listSimpleService ( \n\t\t\tuint32 _serviceId, \n\t\t\tstring _serviceDescription,\n\t\t\tuint256 _tokensRequired,\n\t\t\taddress _updateAddress,\n\t\t\taddress _receiptAddress\t) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//check service id is not 0\n\t\trequire(_serviceId != 0);\n\n\t\t//check service doesn't already exist for this application id\n\t\trequire(services[msg.sender][_serviceId].applicationAddress == 0);\n\n\t\t//check cost of the service is >0 \n\t\trequire(_tokensRequired != 0);\n\n\t\t//check receiptAddress is not address(0)\n\t\trequire(_receiptAddress != address(0));\n\n\t\t//update address should be address(0) or a non-sender address\n\t\trequire(_updateAddress != msg.sender);\n\n\t\t//add service to services mapping\n\t\tservices[msg.sender][_serviceId] = Service(\n\t\t\t\tmsg.sender,\n\t\t\t\t_serviceId,\n\t\t\t\ttrue,\n\t\t\t\t_serviceDescription,\n\t\t\t\t_tokensRequired,\n\t\t\t\t1,\n\t\t\t\t_updateAddress,\n\t\t\t\t_receiptAddress,\n\t\t\t\tfalse,\n\t\t\t\t0\n\t\t\t);\n\n\t\t//add service to servicesLists for application\n\t\tservicesLists[msg.sender].push(_serviceId);\n\n\t\t//emit NewService\n\t\temit NewService(msg.sender, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction listService ( \n\t\t\tuint32 _serviceId, \n\t\t\tstring _serviceDescription,\n\t\t\tuint256 _tokensPerCredit,\n\t\t\tuint256 _maxCreditsPerProvision,\n\t\t\taddress _updateAddress,\n\t\t\taddress _receiptAddress\t) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//check service id is not 0\n\t\trequire(_serviceId != 0);\n\n\t\t//check service doesn't already exist for this application id\n\t\trequire(services[msg.sender][_serviceId].applicationAddress == 0);\n\n\t\t//check cost of the service is >0 \n\t\trequire(_tokensPerCredit != 0);\n\n\t\t//check receiptAddress is not address(0)\n\t\trequire(_receiptAddress != address(0));\n\n\t\t//update address should be address(0) or a non-sender address\n\t\trequire(_updateAddress != msg.sender);\n\n\t\t//add service to services mapping\n\t\tservices[msg.sender][_serviceId] = Service(\n\t\t\t\tmsg.sender,\n\t\t\t\t_serviceId,\n\t\t\t\tfalse,\n\t\t\t\t_serviceDescription,\n\t\t\t\t_tokensPerCredit,\n\t\t\t\t_maxCreditsPerProvision,\n\t\t\t\t_updateAddress,\n\t\t\t\t_receiptAddress,\n\t\t\t\tfalse,\n\t\t\t\t0\n\t\t\t);\n\n\t\t//add service to servicesLists for application\n\t\tservicesLists[msg.sender].push(_serviceId);\n\n\t\t//emit NewService\n\t\temit NewService(msg.sender, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction getServicesForApplication ( \n\t\t\taddress _applicationAddress ) \n\t\tpublic view returns (\n\t\t\tuint32[] serviceIds ) {\n\n\t\treturn servicesLists[_applicationAddress];\n\t}\n\n\tfunction getRemovedServicesForApplication (\n\t\t\taddress _applicationAddress ) \n\t\tpublic view returns (\n\t\t\tuint32[] serviceIds ) {\n\n\t\treturn servicesRemovedLists[_applicationAddress];\n\t}\n\n\tfunction isServiceRemoved (\n\t\t\taddress _applicationAddress,\n\t\t\tuint32 _serviceId )\n\t\tpublic view returns (\n\t\t\tbool ) {\n\n\t\t//returns true if service has been removed\n\t\treturn services[_applicationAddress][_serviceId].isRemoved;\n\t}\n\n\tfunction getServiceInformation ( \n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId )\n\t\tpublic view returns (\n\t\t\tbool exists,\n\t\t\tbool isSimple,\n\t\t\tstring serviceDescription,\n\t\t\tuint256 tokensPerCredit,\n\t\t\tuint256 maxCreditsPerProvision,\n\t\t\taddress receiptAddress,\n\t\t\tbool isRemoved,\n\t\t\tuint256 provisionHead ) {\n\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//services with unset application address indicates an empty/unset struct in the mapping\n\t\tif(s.applicationAddress == 0) {\n\t\t\t//first return parameter indicates whether the service exists\n\t\t\texists=false;\n\t\t\treturn;\n\n\t\t} else {\n\t\t\texists=true;\n\t\t\tisSimple=s.isSimple;\n\t\t\t//note that the returned service description can't be read in solidity funtion call\n\t\t\tserviceDescription=s.serviceDescription;\n\t\t\ttokensPerCredit=s.tokensPerCredit;\n\t\t\tmaxCreditsPerProvision=s.maxCreditsPerProvision;\n\t\t\treceiptAddress=s.receiptAddress;\n\t\t\tisRemoved=s.isRemoved;\n\t\t\tprovisionHead=s.provisionHead;\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfunction getServiceUpdateAddress (\n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId ) \n\t\tpublic view returns (\n\t\t\taddress updateAddress ) {\n\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\treturn s.updateAddress;\n\t}\n\n\tfunction updateServiceDescription (\n\t\t\taddress _targetApplicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tstring _serviceDescription ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_targetApplicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\tservices[_targetApplicationAddress][_serviceId].serviceDescription=_serviceDescription;\n\t\t\n\t\temit ServiceChanged(_targetApplicationAddress, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction updateServiceTokensPerCredit (\n\t\t\taddress _targetApplicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tuint256 _tokensPerCredit ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_targetApplicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//check changed cost of the service is >0 \n\t\trequire(_tokensPerCredit != 0);\n\n\t\tservices[_targetApplicationAddress][_serviceId].tokensPerCredit=_tokensPerCredit;\n\t\t\n\t\temit ServiceChanged(_targetApplicationAddress, _serviceId);\n\n\t\treturn true;\t\t\n\t}\n\n\tfunction updateServiceMaxCreditsPerProvision (\n\t\t\taddress _targetApplicationAddress,\n\t\t\tuint32 _serviceId,\n\t\t\tuint256 _maxCreditsPerProvision )\n\t\tpublic returns (\n\t\t\tbool sucess ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_targetApplicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//note that credits per provision can be == 0 (no limit)\n\n\t\t//change max credits per provision for this service\n\t\tservices[_targetApplicationAddress][_serviceId].maxCreditsPerProvision=_maxCreditsPerProvision;\n\n\t\temit ServiceChanged(_targetApplicationAddress, _serviceId);\n\t\n\t\treturn true;\t\t\n\t}\n\n\tfunction changeServiceReceiptAddress(\n\t\t\tuint32 _serviceId, \n\t\t\taddress _receiptAddress ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//receipt address can only be changed by application address\n\n\t\t//check that service exists\n\t\trequire(services[msg.sender][_serviceId].applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[msg.sender][_serviceId].isRemoved == false);\n\n\t\t//check changed receiptAddress is not address(0)\n\t\trequire(_receiptAddress != address(0));\n\n\t\tservices[msg.sender][_serviceId].receiptAddress=_receiptAddress;\n\t\t\n\t\temit ServiceChanged(msg.sender, _serviceId);\n\n\t\treturn true;\t\t\n\t}\n\n\tfunction changeServiceUpdateAddress (\n\t\t\tuint32 _serviceId,\n\t\t\taddress _updateAddress )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//update address can only be changed by application address\n\n\t\t//check that service exists\n\t\trequire(services[msg.sender][_serviceId].applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[msg.sender][_serviceId].isRemoved == false);\n\n\t\t//note: update address can be address(0)\n\t\t//change the update address\n\t\tservices[msg.sender][_serviceId].updateAddress=_updateAddress;\n\n\t\temit ServiceChanged(msg.sender, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction removeService (\n\t\t\taddress _targetApplicationAddress, \n\t\t\tuint32 _serviceId ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//check that service exists\n\t\trequire(services[_targetApplicationAddress][_serviceId].applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( services[_targetApplicationAddress][_serviceId].updateAddress != address(0) \n\t\t\t   && msg.sender == services[_targetApplicationAddress][_serviceId].updateAddress \n\t\t\t  ));\n\n\t\t//check that service is not already removed\n\t\trequire(services[_targetApplicationAddress][_serviceId].isRemoved == false);\n\n\t\t//add to removed array\n\t\tservicesRemovedLists[_targetApplicationAddress].push(_serviceId);\n\n\t\t//change value of isRemoved to true\n\t\tservices[_targetApplicationAddress][_serviceId].isRemoved = true;\n\n\t\temit ServiceRemoved(_targetApplicationAddress, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction transferToSimpleService (\n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tuint256 _tokenValue, \n\t\t\tuint256 _applicationReference, \n\t\t\tuint256 _multiple ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//requested multiple must be >= 1\n\t\trequire(_multiple > 0);\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//service must exist\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[_applicationAddress][_serviceId].isRemoved == false);\n\n\t\t//check that service is a simple service\n\t\trequire(s.isSimple == true);\n\n\t\t//expected value is the token cost of the service multiplied by the requested multiple\n\t\tuint256 expectedValue=s.tokensPerCredit.mul(_multiple);\n\n\t\t//supplied token value must equal expected value\n\t\trequire(expectedValue == _tokenValue);\n\n\t\t//transfer the tokens -- this verifies the sender owns the tokens\n\t\ttransfer(s.receiptAddress, _tokenValue);\n\n\t\t//this starts and ends a simple provision at a single point in time \n\t\temit CompleteSimpleProvision(_applicationAddress, _serviceId, msg.sender, _multiple, _applicationReference);\n\n\t\treturn true;\n\t}\n\n\n\tfunction transferToService (\n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tuint256 _tokenValue, \n\t\t\tuint256 _credits,\n\t\t\tuint256 _applicationReference ) \n\t\tpublic returns (\n\t\t\tuint256 provisionId ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//service must exist\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[_applicationAddress][_serviceId].isRemoved == false);\n\n\t\t//check that service is not a simple service\n\t\trequire(s.isSimple == false);\n\n\t\t//verify: value == credits * tokens per credit\n\t\trequire(_tokenValue == (_credits.mul(s.tokensPerCredit)));\n\n\t\t//verify: max credits == 0 OR (value/tokens per credit) <= max credits per provision\n\t\trequire( s.maxCreditsPerProvision == 0 ||\n\t\t\t_credits <= s.maxCreditsPerProvision);\n\n\t\t//increment provision head and use as provision id\n\t\ts.provisionHead++;\n\t\tuint256 pid = s.provisionHead;\n\n\t\t//create provision in mapping\n\t\tprovisions[_applicationAddress][_serviceId][pid] = Provision (\n\t\t\t\ts.tokensPerCredit,\n\t\t\t\t_credits,\n\t\t\t\t_applicationReference,\n\t\t\t\tmsg.sender,\n\t\t\t\t_credits\t\t\n\t\t\t);\n\n\t\t//transfer the tokens\n\t\ttransfer(s.receiptAddress, _tokenValue);\n\n\t\t//emits a start provision \n\t\temit StartProvision(_applicationAddress, _serviceId, msg.sender, pid, _credits, s.tokensPerCredit, _applicationReference);\n\n\t\t//return provision id\n\t\treturn pid;\n\t}\n\n\tfunction getProvisionCreditsRemaining (\n\t\t\taddress _applicationAddress,\n\t\t\tuint32 _serviceId,\n\t\t    uint256 _provisionId )\n\t\tpublic view returns (\n\t\t\tuint256 credits) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//service must exist\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[_applicationAddress][_serviceId].isRemoved == false);\t\t\n\n\t\t//get & check that the provision exists (address at userAddress)\n\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\trequire(p.userAddress != 0);\n\n\t\t//return the credits remaining for this provision\n\t\treturn p.creditsRemaining;\n\t}\n\n\tfunction updateProvision (\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256 _provisionId,\n\t\t    uint256 _creditsRemaining )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//credits remaining must be >0, complete provision should be used to set to 0\n\t\trequire(_creditsRemaining > 0);\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _applicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//get & check that the provision exists (address at userAddress)\n\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\trequire(p.userAddress != 0);\n\n\t\t//update the credits remaining\n\t\tp.creditsRemaining=_creditsRemaining;\n\t\n\t\t//fires UpdateProvision\n\t\temit UpdateProvision(_applicationAddress, _serviceId, _provisionId, _creditsRemaining);\n\n\t\treturn true;\t\t\n\t}\n\n\tfunction completeProvision (\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256 _provisionId,\n\t\t    uint256 _creditsOutstanding )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _applicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//get & check that the provision exists (address at userAddress)\n\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\trequire(p.userAddress != 0);\n\n\t\tif(_creditsOutstanding > 0) {\n\t\t\t//can only signal refund total of credits originally provisioned\n\t\t\trequire(_creditsOutstanding <= p.creditsProvisioned);\n\n\t\t\temit SignalProvisionRefund(_applicationAddress, _serviceId, _provisionId, _creditsOutstanding.mul(p.tokensPerCredit));\n\t\t}\n\n\t\t//credits remaining on service is set to 0\n\t\tp.creditsRemaining=0;\n\n\t\t//fires CompleteProvision\n\t\temit CompleteProvision(_applicationAddress, _serviceId, _provisionId, _creditsOutstanding);\n\n\t\treturn true;\n\t}\n\n\n\tfunction confirmReference (\n\t\t\taddress _applicationAddress,\n\t\t\tuint256 _applicationReference,\n\t\t\tuint256 _senderTokensMinimum )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//sender must have some tokens - if 0 is passed to _senderTokensMinimum\n\t\t//then it is assumed that the method is checking that the sender has any amount\n\t\t//of tokens (>0)\n\t\trequire(balances[msg.sender] > 0);\n\n\t\t//sender must have min tokens if specified\n\t\trequire(_senderTokensMinimum == 0 \n\t\t\t|| balances[msg.sender] >= _senderTokensMinimum);\n\n\t\temit ReferenceConfirmed(_applicationAddress, _applicationReference, msg.sender, _senderTokensMinimum);\n\n\t\treturn true;\n\t}\n\n\n\tfunction transferBecauseOf (\n\t\t    address _to,\n\t\t    uint256 _value,\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256 _provisionId )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//provision ID can be optional, but if it's supplied it must exist\n\t\tif(_provisionId != 0) {\n\t\t\t//get & check that the provision exists (address at userAddress)\n\t\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\t\trequire(p.userAddress != 0);\n\t\t}\n\n\t\t//do the transfer\n\t\ttransfer(_to, _value);\n\n\t\temit TransferBecauseOf(_applicationAddress, _serviceId, _provisionId, msg.sender, _to, _value);\n\n\t\treturn true;\n\t}\n\n\n\tfunction transferBecauseOfAggregate (\n\t\t    address _to,\n\t\t    uint256 _value,\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256[] _provisionIds,\n\t\t    uint256[] _tokenAmounts )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//do the transfer\n\t\ttransfer(_to, _value);\n\n\t\temit TransferBecauseOfAggregate(_applicationAddress, _serviceId, _provisionIds, _tokenAmounts, msg.sender, _to, _value);\n\n\t\treturn true;\n\t}\n\n\tfunction ownerBurn ( \n\t\t\tuint256 _value )\n\t\tpublic returns (\n\t\t\tbool success) {\n\n\t\t//only the contract owner can burn tokens\n\t\trequire(msg.sender == contractOwner);\n\n\t\t//can only burn tokens held by the owner\n\t\trequire(_value <= balances[contractOwner]);\n\n\t\t//total supply of tokens is decremented when burned\n\t\ttotalSupply_ = totalSupply_.sub(_value);\n\n\t\t//balance of the contract owner is reduced (the contract owner's tokens are burned)\n\t\tbalances[contractOwner] = balances[contractOwner].sub(_value);\n\n\t\t//burning tokens emits a transfer to 0, as well as TokensBurned\n\t\temit Transfer(contractOwner, address(0), _value);\n\t\temit TokensBurned(contractOwner, _value);\n\n\t\treturn true;\n\n\t}\n\t\n\t\n\tfunction totalSupply ( ) public view returns (\n\t\tuint256 ) {\n\n\t\treturn totalSupply_;\n\t}\n\n\tfunction balanceOf (\n\t\t\taddress _owner ) \n\t\tpublic view returns (\n\t\t\tuint256 ) {\n\n\t\treturn balances[_owner];\n\t}\n\n\tfunction transfer (\n\t\t\taddress _to, \n\t\t\tuint256 _value ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[msg.sender]);\n\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n   \t//changing approval with this method has the same underlying issue as https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   \t//in that transaction order can be modified in a block to spend, change approval, spend again\n   \t//the method is kept for ERC-20 compatibility, but a set to zero, set again or use of the below increase/decrease should be used instead\n\tfunction approve (\n\t\t\taddress _spender, \n\t\t\tuint256 _value ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\tallowed[msg.sender][_spender] = _value;\n\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\tfunction increaseApproval (\n\t\t\taddress _spender, \n\t\t\tuint256 _addedValue ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\tfunction decreaseApproval (\n\t\t\taddress _spender,\n\t\t\tuint256 _subtractedValue ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\tuint256 oldValue = allowed[msg.sender][_spender];\n\n\t\tif (_subtractedValue > oldValue) {\n\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t} else {\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\t\t}\n\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\tfunction allowance (\n\t\t\taddress _owner, \n\t\t\taddress _spender ) \n\t\tpublic view returns (\n\t\t\tuint256 remaining ) {\n\n\t\treturn allowed[_owner][_spender];\n\t}\n\n\tfunction transferFrom (\n\t\t\taddress _from, \n\t\t\taddress _to, \n\t\t\tuint256 _value ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[_from]);\n\t\trequire(_value <= allowed[_from][msg.sender]);\n\n\t\tbalances[_from] = balances[_from].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n}",
        "debug": "keccac_1_+\nkeccac_4294967295_&_4294967295_&_4294967295_&_calldata_U42_4: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_1 +\nkeccac_4294967295_&_4294967295_&_4294967295_&_calldata_U42_4: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\ncaller: 0x0\ncalldata_U42_32 + 100: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_U42_32 + 132: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_U42_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0 +\nkeccac_4294967295_&_4294967295_&_4294967295_&_calldata_U42_4: 0x0\ncalldata_U42_4: 0xffffffff\ncalldata_U42_0: 0x16a7859b00000000000000000000000000000000000000000000000000000000\ncalldatasize_U42: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x16a7859b`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/10/0x1f988b4ee752826e834f478b7668725ae7ecf53c.sol",
        "function": "_function_0x16a7859b",
        "lineno": 61,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 22005,
        "code": "s\n\tusing SafeMath for uint256;\n\n\tstring public constant name = \"U42\";\n\tstring public constant symbol = \"U42\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant initialSupply = 525000000 * (10 ** uint256(decimals));\n\tuint256 internal totalSupply_ = initialSupply;\n\taddress public contractOwner;\n\n\t//token balances\n\tmapping(address => uint256) balances;\n\n\t//for each balance address, map allowed addresses to amount allowed\n\tmapping (address => mapping (address => uint256)) internal allowed;\n\n\t//each service is represented by a Service struct \n\tstruct Service {\n\t\taddress applicationAddress;\n\t\tuint32 serviceId;\n\t\tbool isSimple;\n\t\tstring serviceDescription;\n\t\tuint256 tokensPerCredit;\n\t\tuint256 maxCreditsPerProvision;\n\t\taddress updateAddress;\n\t\taddress receiptAddress;\n\t\tbool isRemoved;\n\t\tuint256 provisionHead;\n\t}\n\n\tstruct Provision {\n\t\tuint256 tokensPerCredit;\n\t\tuint256 creditsRemaining;\n\t\tuint256 applicationReference;\n\t\taddress userAddress;\n\t\tuint256 creditsProvisioned;\n\t}\n\n\t//mapping of application addresses to service structs\n\tmapping (address => mapping (uint32 => Service)) services;\n\n\t//mapping of application addresses to service structs to provisions\n\tmapping (address => mapping (uint32 => mapping (uint256 => Provision))) provisions;\n\n\t//mapping of application addresses to lists of services\n\tmapping (address => uint32[]) servicesLists;\n\n\t//mapping of application addresses to lists of removed services\n\tmapping (address => uint32[]) servicesRemovedLists;\n\n\t//methods emit the following events\n\tevent Transfer (\n\t\taddress indexed from, \n\t\taddress indexed to, \n\t\tuint256 value );\n\n\tevent TokensBurned (\n\t\taddress indexed burner, \n\t\tuint256 value );\n\n\tevent Approval (\n\t\taddress indexed owner,\n\t\taddress indexed spender,\n\t\tuint256 value );\n\n\tevent NewService (\n\t\taddress indexed applicationAddress,\n\t\tuint32 serviceId );\n\n\tevent ServiceChanged (\n\t\taddress indexed applicationAddress,\n\t\tuint32 serviceId );\n\n\tevent ServiceRemoved (\n\t\taddress indexed applicationAddress,\n\t\tuint32 serviceId );\n\n\tevent CompleteSimpleProvision (\n\t\taddress indexed applicationAddress,\n\t\tuint32 indexed serviceId,\n\t\taddress indexed userAddress,\n\t\tuint256 multiple,\n\t\tuint256 applicationReference );\n\n\tevent ReferenceConfirmed (\n\t\taddress indexed applicationAddress,\n\t\tuint256 indexed applicationReference, \n\t\taddress indexed confirmedBy, \n\t\tuint256 confirmerTokensMinimum );\n\n\tevent StartProvision (\n\t    address indexed applicationAddress, \n\t    uint32 indexed serviceId, \n\t    address indexed userAddress,\n\t    uint256 provisionId,\n\t    uint256 serviceCredits,\n\t    uint256 tokensPerCredit, \n\t    uint256 applicationReference );\n\n\tevent UpdateProvision (\n\t    address indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    uint256 creditsRemaining );\n\n\tevent CompleteProvision (\n\t    address indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    uint256 creditsOutstanding );\n\n\tevent SignalProvisionRefund (\n\t    address indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    uint256 tokenValue );\n\n\tevent TransferBecauseOf (\n\t\taddress indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    address from,\n\t    address to,\n\t    uint256 value );\n\n\tevent TransferBecauseOfAggregate (\n\t\taddress indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256[] provisionIds,\n\t    uint256[] tokenAmounts,\n\t    address from,\n\t    address to,\n\t    uint256 value );\n\n\n\tconstructor() public {\n\t\t//contract creator holds all tokens at creation\n\t\tbalances[msg.sender] = totalSupply_;\n\n\t\t//record contract owner for later reference (e.g. in ownerBurn)\n\t\tcontractOwner=msg.sender;\n\n\t\t//indicate all tokens were sent to contract address\n\t\temit Transfer(address(0), msg.sender, totalSupply_);\n\t}\n\n\tfunction listSimpleService ( \n\t\t\tuint32 _serviceId, \n\t\t\tstring _serviceDescription,\n\t\t\tuint256 _tokensRequired,\n\t\t\taddress _updateAddress,\n\t\t\taddress _receiptAddress\t) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//check service id is not 0\n\t\trequire(_serviceId != 0);\n\n\t\t//check service doesn't already exist for this application id\n\t\trequire(services[msg.sender][_serviceId].applicationAddress == 0);\n\n\t\t//check cost of the service is >0 \n\t\trequire(_tokensRequired != 0);\n\n\t\t//check receiptAddress is not address(0)\n\t\trequire(_receiptAddress != address(0));\n\n\t\t//update address should be address(0) or a non-sender address\n\t\trequire(_updateAddress != msg.sender);\n\n\t\t//add service to services mapping\n\t\tservices[msg.sender][_serviceId] = Service(\n\t\t\t\tmsg.sender,\n\t\t\t\t_serviceId,\n\t\t\t\ttrue,\n\t\t\t\t_serviceDescription,\n\t\t\t\t_tokensRequired,\n\t\t\t\t1,\n\t\t\t\t_updateAddress,\n\t\t\t\t_receiptAddress,\n\t\t\t\tfalse,\n\t\t\t\t0\n\t\t\t);\n\n\t\t//add service to servicesLists for application\n\t\tservicesLists[msg.sender].push(_serviceId);\n\n\t\t//emit NewService\n\t\temit NewService(msg.sender, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction listService ( \n\t\t\tuint32 _serviceId, \n\t\t\tstring _serviceDescription,\n\t\t\tuint256 _tokensPerCredit,\n\t\t\tuint256 _maxCreditsPerProvision,\n\t\t\taddress _updateAddress,\n\t\t\taddress _receiptAddress\t) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//check service id is not 0\n\t\trequire(_serviceId != 0);\n\n\t\t//check service doesn't already exist for this application id\n\t\trequire(services[msg.sender][_serviceId].applicationAddress == 0);\n\n\t\t//check cost of the service is >0 \n\t\trequire(_tokensPerCredit != 0);\n\n\t\t//check receiptAddress is not address(0)\n\t\trequire(_receiptAddress != address(0));\n\n\t\t//update address should be address(0) or a non-sender address\n\t\trequire(_updateAddress != msg.sender);\n\n\t\t//add service to services mapping\n\t\tservices[msg.sender][_serviceId] = Service(\n\t\t\t\tmsg.sender,\n\t\t\t\t_serviceId,\n\t\t\t\tfalse,\n\t\t\t\t_serviceDescription,\n\t\t\t\t_tokensPerCredit,\n\t\t\t\t_maxCreditsPerProvision,\n\t\t\t\t_updateAddress,\n\t\t\t\t_receiptAddress,\n\t\t\t\tfalse,\n\t\t\t\t0\n\t\t\t);\n\n\t\t//add service to servicesLists for application\n\t\tservicesLists[msg.sender].push(_serviceId);\n\n\t\t//emit NewService\n\t\temit NewService(msg.sender, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction getServicesForApplication ( \n\t\t\taddress _applicationAddress ) \n\t\tpublic view returns (\n\t\t\tuint32[] serviceIds ) {\n\n\t\treturn servicesLists[_applicationAddress];\n\t}\n\n\tfunction getRemovedServicesForApplication (\n\t\t\taddress _applicationAddress ) \n\t\tpublic view returns (\n\t\t\tuint32[] serviceIds ) {\n\n\t\treturn servicesRemovedLists[_applicationAddress];\n\t}\n\n\tfunction isServiceRemoved (\n\t\t\taddress _applicationAddress,\n\t\t\tuint32 _serviceId )\n\t\tpublic view returns (\n\t\t\tbool ) {\n\n\t\t//returns true if service has been removed\n\t\treturn services[_applicationAddress][_serviceId].isRemoved;\n\t}\n\n\tfunction getServiceInformation ( \n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId )\n\t\tpublic view returns (\n\t\t\tbool exists,\n\t\t\tbool isSimple,\n\t\t\tstring serviceDescription,\n\t\t\tuint256 tokensPerCredit,\n\t\t\tuint256 maxCreditsPerProvision,\n\t\t\taddress receiptAddress,\n\t\t\tbool isRemoved,\n\t\t\tuint256 provisionHead ) {\n\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//services with unset application address indicates an empty/unset struct in the mapping\n\t\tif(s.applicationAddress == 0) {\n\t\t\t//first return parameter indicates whether the service exists\n\t\t\texists=false;\n\t\t\treturn;\n\n\t\t} else {\n\t\t\texists=true;\n\t\t\tisSimple=s.isSimple;\n\t\t\t//note that the returned service description can't be read in solidity funtion call\n\t\t\tserviceDescription=s.serviceDescription;\n\t\t\ttokensPerCredit=s.tokensPerCredit;\n\t\t\tmaxCreditsPerProvision=s.maxCreditsPerProvision;\n\t\t\treceiptAddress=s.receiptAddress;\n\t\t\tisRemoved=s.isRemoved;\n\t\t\tprovisionHead=s.provisionHead;\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfunction getServiceUpdateAddress (\n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId ) \n\t\tpublic view returns (\n\t\t\taddress updateAddress ) {\n\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\treturn s.updateAddress;\n\t}\n\n\tfunction updateServiceDescription (\n\t\t\taddress _targetApplicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tstring _serviceDescription ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_targetApplicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\tservices[_targetApplicationAddress][_serviceId].serviceDescription=_serviceDescription;\n\t\t\n\t\temit ServiceChanged(_targetApplicationAddress, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction updateServiceTokensPerCredit (\n\t\t\taddress _targetApplicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tuint256 _tokensPerCredit ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_targetApplicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//check changed cost of the service is >0 \n\t\trequire(_tokensPerCredit != 0);\n\n\t\tservices[_targetApplicationAddress][_serviceId].tokensPerCredit=_tokensPerCredit;\n\t\t\n\t\temit ServiceChanged(_targetApplicationAddress, _serviceId);\n\n\t\treturn true;\t\t\n\t}\n\n\tfunction updateServiceMaxCreditsPerProvision (\n\t\t\taddress _targetApplicationAddress,\n\t\t\tuint32 _serviceId,\n\t\t\tuint256 _maxCreditsPerProvision )\n\t\tpublic returns (\n\t\t\tbool sucess ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_targetApplicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//note that credits per provision can be == 0 (no limit)\n\n\t\t//change max credits per provision for this service\n\t\tservices[_targetApplicationAddress][_serviceId].maxCreditsPerProvision=_maxCreditsPerProvision;\n\n\t\temit ServiceChanged(_targetApplicationAddress, _serviceId);\n\t\n\t\treturn true;\t\t\n\t}\n\n\tfunction changeServiceReceiptAddress(\n\t\t\tuint32 _serviceId, \n\t\t\taddress _receiptAddress ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//receipt address can only be changed by application address\n\n\t\t//check that service exists\n\t\trequire(services[msg.sender][_serviceId].applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[msg.sender][_serviceId].isRemoved == false);\n\n\t\t//check changed receiptAddress is not address(0)\n\t\trequire(_receiptAddress != address(0));\n\n\t\tservices[msg.sender][_serviceId].receiptAddress=_receiptAddress;\n\t\t\n\t\temit ServiceChanged(msg.sender, _serviceId);\n\n\t\treturn true;\t\t\n\t}\n\n\tfunction changeServiceUpdateAddress (\n\t\t\tuint32 _serviceId,\n\t\t\taddress _updateAddress )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//update address can only be changed by application address\n\n\t\t//check that service exists\n\t\trequire(services[msg.sender][_serviceId].applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[msg.sender][_serviceId].isRemoved == false);\n\n\t\t//note: update address can be address(0)\n\t\t//change the update address\n\t\tservices[msg.sender][_serviceId].updateAddress=_updateAddress;\n\n\t\temit ServiceChanged(msg.sender, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction removeService (\n\t\t\taddress _targetApplicationAddress, \n\t\t\tuint32 _serviceId ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//check that service exists\n\t\trequire(services[_targetApplicationAddress][_serviceId].applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( services[_targetApplicationAddress][_serviceId].updateAddress != address(0) \n\t\t\t   && msg.sender == services[_targetApplicationAddress][_serviceId].updateAddress \n\t\t\t  ));\n\n\t\t//check that service is not already removed\n\t\trequire(services[_targetApplicationAddress][_serviceId].isRemoved == false);\n\n\t\t//add to removed array\n\t\tservicesRemovedLists[_targetApplicationAddress].push(_serviceId);\n\n\t\t//change value of isRemoved to true\n\t\tservices[_targetApplicationAddress][_serviceId].isRemoved = true;\n\n\t\temit ServiceRemoved(_targetApplicationAddress, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction transferToSimpleService (\n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tuint256 _tokenValue, \n\t\t\tuint256 _applicationReference, \n\t\t\tuint256 _multiple ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//requested multiple must be >= 1\n\t\trequire(_multiple > 0);\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//service must exist\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[_applicationAddress][_serviceId].isRemoved == false);\n\n\t\t//check that service is a simple service\n\t\trequire(s.isSimple == true);\n\n\t\t//expected value is the token cost of the service multiplied by the requested multiple\n\t\tuint256 expectedValue=s.tokensPerCredit.mul(_multiple);\n\n\t\t//supplied token value must equal expected value\n\t\trequire(expectedValue == _tokenValue);\n\n\t\t//transfer the tokens -- this verifies the sender owns the tokens\n\t\ttransfer(s.receiptAddress, _tokenValue);\n\n\t\t//this starts and ends a simple provision at a single point in time \n\t\temit CompleteSimpleProvision(_applicationAddress, _serviceId, msg.sender, _multiple, _applicationReference);\n\n\t\treturn true;\n\t}\n\n\n\tfunction transferToService (\n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tuint256 _tokenValue, \n\t\t\tuint256 _credits,\n\t\t\tuint256 _applicationReference ) \n\t\tpublic returns (\n\t\t\tuint256 provisionId ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//service must exist\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[_applicationAddress][_serviceId].isRemoved == false);\n\n\t\t//check that service is not a simple service\n\t\trequire(s.isSimple == false);\n\n\t\t//verify: value == credits * tokens per credit\n\t\trequire(_tokenValue == (_credits.mul(s.tokensPerCredit)));\n\n\t\t//verify: max credits == 0 OR (value/tokens per credit) <= max credits per provision\n\t\trequire( s.maxCreditsPerProvision == 0 ||\n\t\t\t_credits <= s.maxCreditsPerProvision);\n\n\t\t//increment provision head and use as provision id\n\t\ts.provisionHead++;\n\t\tuint256 pid = s.provisionHead;\n\n\t\t//create provision in mapping\n\t\tprovisions[_applicationAddress][_serviceId][pid] = Provision (\n\t\t\t\ts.tokensPerCredit,\n\t\t\t\t_credits,\n\t\t\t\t_applicationReference,\n\t\t\t\tmsg.sender,\n\t\t\t\t_credits\t\t\n\t\t\t);\n\n\t\t//transfer the tokens\n\t\ttransfer(s.receiptAddress, _tokenValue);\n\n\t\t//emits a start provision \n\t\temit StartProvision(_applicationAddress, _serviceId, msg.sender, pid, _credits, s.tokensPerCredit, _applicationReference);\n\n\t\t//return provision id\n\t\treturn pid;\n\t}\n\n\tfunction getProvisionCreditsRemaining (\n\t\t\taddress _applicationAddress,\n\t\t\tuint32 _serviceId,\n\t\t    uint256 _provisionId )\n\t\tpublic view returns (\n\t\t\tuint256 credits) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//service must exist\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[_applicationAddress][_serviceId].isRemoved == false);\t\t\n\n\t\t//get & check that the provision exists (address at userAddress)\n\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\trequire(p.userAddress != 0);\n\n\t\t//return the credits remaining for this provision\n\t\treturn p.creditsRemaining;\n\t}\n\n\tfunction updateProvision (\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256 _provisionId,\n\t\t    uint256 _creditsRemaining )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//credits remaining must be >0, complete provision should be used to set to 0\n\t\trequire(_creditsRemaining > 0);\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _applicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//get & check that the provision exists (address at userAddress)\n\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\trequire(p.userAddress != 0);\n\n\t\t//update the credits remaining\n\t\tp.creditsRemaining=_creditsRemaining;\n\t\n\t\t//fires UpdateProvision\n\t\temit UpdateProvision(_applicationAddress, _serviceId, _provisionId, _creditsRemaining);\n\n\t\treturn true;\t\t\n\t}\n\n\tfunction completeProvision (\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256 _provisionId,\n\t\t    uint256 _creditsOutstanding )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _applicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//get & check that the provision exists (address at userAddress)\n\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\trequire(p.userAddress != 0);\n\n\t\tif(_creditsOutstanding > 0) {\n\t\t\t//can only signal refund total of credits originally provisioned\n\t\t\trequire(_creditsOutstanding <= p.creditsProvisioned);\n\n\t\t\temit SignalProvisionRefund(_applicationAddress, _serviceId, _provisionId, _creditsOutstanding.mul(p.tokensPerCredit));\n\t\t}\n\n\t\t//credits remaining on service is set to 0\n\t\tp.creditsRemaining=0;\n\n\t\t//fires CompleteProvision\n\t\temit CompleteProvision(_applicationAddress, _serviceId, _provisionId, _creditsOutstanding);\n\n\t\treturn true;\n\t}\n\n\n\tfunction confirmReference (\n\t\t\taddress _applicationAddress,\n\t\t\tuint256 _applicationReference,\n\t\t\tuint256 _senderTokensMinimum )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//sender must have some tokens - if 0 is passed to _senderTokensMinimum\n\t\t//then it is assumed that the method is checking that the sender has any amount\n\t\t//of tokens (>0)\n\t\trequire(balances[msg.sender] > 0);\n\n\t\t//sender must have min tokens if specified\n\t\trequire(_senderTokensMinimum == 0 \n\t\t\t|| balances[msg.sender] >= _senderTokensMinimum);\n\n\t\temit ReferenceConfirmed(_applicationAddress, _applicationReference, msg.sender, _senderTokensMinimum);\n\n\t\treturn true;\n\t}\n\n\n\tfunction transferBecauseOf (\n\t\t    address _to,\n\t\t    uint256 _value,\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256 _provisionId )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//provision ID can be optional, but if it's supplied it must exist\n\t\tif(_provisionId != 0) {\n\t\t\t//get & check that the provision exists (address at userAddress)\n\t\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\t\trequire(p.userAddress != 0);\n\t\t}\n\n\t\t//do the transfer\n\t\ttransfer(_to, _value);\n\n\t\temit TransferBecauseOf(_applicationAddress, _serviceId, _provisionId, msg.sender, _to, _value);\n\n\t\treturn true;\n\t}\n\n\n\tfunction transferBecauseOfAggregate (\n\t\t    address _to,\n\t\t    uint256 _value,\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256[] _provisionIds,\n\t\t    uint256[] _tokenAmounts )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//do the transfer\n\t\ttransfer(_to, _value);\n\n\t\temit TransferBecauseOfAggregate(_applicationAddress, _serviceId, _provisionIds, _tokenAmounts, msg.sender, _to, _value);\n\n\t\treturn true;\n\t}\n\n\tfunction ownerBurn ( \n\t\t\tuint256 _value )\n\t\tpublic returns (\n\t\t\tbool success) {\n\n\t\t//only the contract owner can burn tokens\n\t\trequire(msg.sender == contractOwner);\n\n\t\t//can only burn tokens held by the owner\n\t\trequire(_value <= balances[contractOwner]);\n\n\t\t//total supply of tokens is decremented when burned\n\t\ttotalSupply_ = totalSupply_.sub(_value);\n\n\t\t//balance of the contract owner is reduced (the contract owner's tokens are burned)\n\t\tbalances[contractOwner] = balances[contractOwner].sub(_value);\n\n\t\t//burning tokens emits a transfer to 0, as well as TokensBurned\n\t\temit Transfer(contractOwner, address(0), _value);\n\t\temit TokensBurned(contractOwner, _value);\n\n\t\treturn true;\n\n\t}\n\t\n\t\n\tfunction totalSupply ( ) public view returns (\n\t\tuint256 ) {\n\n\t\treturn totalSupply_;\n\t}\n\n\tfunction balanceOf (\n\t\t\taddress _owner ) \n\t\tpublic view returns (\n\t\t\tuint256 ) {\n\n\t\treturn balances[_owner];\n\t}\n\n\tfunction transfer (\n\t\t\taddress _to, \n\t\t\tuint256 _value ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[msg.sender]);\n\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n   \t//changing approval with this method has the same underlying issue as https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   \t//in that transaction order can be modified in a block to spend, change approval, spend again\n   \t//the method is kept for ERC-20 compatibility, but a set to zero, set again or use of the below increase/decrease should be used instead\n\tfunction approve (\n\t\t\taddress _spender, \n\t\t\tuint256 _value ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\tallowed[msg.sender][_spender] = _value;\n\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\tfunction increaseApproval (\n\t\t\taddress _spender, \n\t\t\tuint256 _addedValue ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\tfunction decreaseApproval (\n\t\t\taddress _spender,\n\t\t\tuint256 _subtractedValue ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\tuint256 oldValue = allowed[msg.sender][_spender];\n\n\t\tif (_subtractedValue > oldValue) {\n\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t} else {\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\t\t}\n\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\tfunction allowance (\n\t\t\taddress _owner, \n\t\t\taddress _spender ) \n\t\tpublic view returns (\n\t\t\tuint256 remaining ) {\n\n\t\treturn allowed[_owner][_spender];\n\t}\n\n\tfunction transferFrom (\n\t\t\taddress _from, \n\t\t\taddress _to, \n\t\t\tuint256 _value ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[_from]);\n\t\trequire(_value <= allowed[_from][msg.sender]);\n\n\t\tbalances[_from] = balances[_from].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n}",
        "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_U42_4 + calldata_U42_32 + 4)) +\n96: 0x8000000000000000000000000000000000000000000000000000000000000000\ncaller: 0x0\ncalldata_U42_32 + 100: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_U42_32 + 132: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_U42_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0 +\nkeccac_4294967295_&_4294967295_&_4294967295_&_calldata_U42_4: 0x0\ncalldata_U42_4: 0xffffffff\ncalldata_U42_0: 0x16a7859b00000000000000000000000000000000000000000000000000000000\ncalldatasize_U42: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x16a7859b`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/10/0x1f988b4ee752826e834f478b7668725ae7ecf53c.sol",
        "function": "_function_0x16a7859b",
        "lineno": 61,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 22019,
        "code": "s\n\tusing SafeMath for uint256;\n\n\tstring public constant name = \"U42\";\n\tstring public constant symbol = \"U42\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant initialSupply = 525000000 * (10 ** uint256(decimals));\n\tuint256 internal totalSupply_ = initialSupply;\n\taddress public contractOwner;\n\n\t//token balances\n\tmapping(address => uint256) balances;\n\n\t//for each balance address, map allowed addresses to amount allowed\n\tmapping (address => mapping (address => uint256)) internal allowed;\n\n\t//each service is represented by a Service struct \n\tstruct Service {\n\t\taddress applicationAddress;\n\t\tuint32 serviceId;\n\t\tbool isSimple;\n\t\tstring serviceDescription;\n\t\tuint256 tokensPerCredit;\n\t\tuint256 maxCreditsPerProvision;\n\t\taddress updateAddress;\n\t\taddress receiptAddress;\n\t\tbool isRemoved;\n\t\tuint256 provisionHead;\n\t}\n\n\tstruct Provision {\n\t\tuint256 tokensPerCredit;\n\t\tuint256 creditsRemaining;\n\t\tuint256 applicationReference;\n\t\taddress userAddress;\n\t\tuint256 creditsProvisioned;\n\t}\n\n\t//mapping of application addresses to service structs\n\tmapping (address => mapping (uint32 => Service)) services;\n\n\t//mapping of application addresses to service structs to provisions\n\tmapping (address => mapping (uint32 => mapping (uint256 => Provision))) provisions;\n\n\t//mapping of application addresses to lists of services\n\tmapping (address => uint32[]) servicesLists;\n\n\t//mapping of application addresses to lists of removed services\n\tmapping (address => uint32[]) servicesRemovedLists;\n\n\t//methods emit the following events\n\tevent Transfer (\n\t\taddress indexed from, \n\t\taddress indexed to, \n\t\tuint256 value );\n\n\tevent TokensBurned (\n\t\taddress indexed burner, \n\t\tuint256 value );\n\n\tevent Approval (\n\t\taddress indexed owner,\n\t\taddress indexed spender,\n\t\tuint256 value );\n\n\tevent NewService (\n\t\taddress indexed applicationAddress,\n\t\tuint32 serviceId );\n\n\tevent ServiceChanged (\n\t\taddress indexed applicationAddress,\n\t\tuint32 serviceId );\n\n\tevent ServiceRemoved (\n\t\taddress indexed applicationAddress,\n\t\tuint32 serviceId );\n\n\tevent CompleteSimpleProvision (\n\t\taddress indexed applicationAddress,\n\t\tuint32 indexed serviceId,\n\t\taddress indexed userAddress,\n\t\tuint256 multiple,\n\t\tuint256 applicationReference );\n\n\tevent ReferenceConfirmed (\n\t\taddress indexed applicationAddress,\n\t\tuint256 indexed applicationReference, \n\t\taddress indexed confirmedBy, \n\t\tuint256 confirmerTokensMinimum );\n\n\tevent StartProvision (\n\t    address indexed applicationAddress, \n\t    uint32 indexed serviceId, \n\t    address indexed userAddress,\n\t    uint256 provisionId,\n\t    uint256 serviceCredits,\n\t    uint256 tokensPerCredit, \n\t    uint256 applicationReference );\n\n\tevent UpdateProvision (\n\t    address indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    uint256 creditsRemaining );\n\n\tevent CompleteProvision (\n\t    address indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    uint256 creditsOutstanding );\n\n\tevent SignalProvisionRefund (\n\t    address indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    uint256 tokenValue );\n\n\tevent TransferBecauseOf (\n\t\taddress indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    address from,\n\t    address to,\n\t    uint256 value );\n\n\tevent TransferBecauseOfAggregate (\n\t\taddress indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256[] provisionIds,\n\t    uint256[] tokenAmounts,\n\t    address from,\n\t    address to,\n\t    uint256 value );\n\n\n\tconstructor() public {\n\t\t//contract creator holds all tokens at creation\n\t\tbalances[msg.sender] = totalSupply_;\n\n\t\t//record contract owner for later reference (e.g. in ownerBurn)\n\t\tcontractOwner=msg.sender;\n\n\t\t//indicate all tokens were sent to contract address\n\t\temit Transfer(address(0), msg.sender, totalSupply_);\n\t}\n\n\tfunction listSimpleService ( \n\t\t\tuint32 _serviceId, \n\t\t\tstring _serviceDescription,\n\t\t\tuint256 _tokensRequired,\n\t\t\taddress _updateAddress,\n\t\t\taddress _receiptAddress\t) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//check service id is not 0\n\t\trequire(_serviceId != 0);\n\n\t\t//check service doesn't already exist for this application id\n\t\trequire(services[msg.sender][_serviceId].applicationAddress == 0);\n\n\t\t//check cost of the service is >0 \n\t\trequire(_tokensRequired != 0);\n\n\t\t//check receiptAddress is not address(0)\n\t\trequire(_receiptAddress != address(0));\n\n\t\t//update address should be address(0) or a non-sender address\n\t\trequire(_updateAddress != msg.sender);\n\n\t\t//add service to services mapping\n\t\tservices[msg.sender][_serviceId] = Service(\n\t\t\t\tmsg.sender,\n\t\t\t\t_serviceId,\n\t\t\t\ttrue,\n\t\t\t\t_serviceDescription,\n\t\t\t\t_tokensRequired,\n\t\t\t\t1,\n\t\t\t\t_updateAddress,\n\t\t\t\t_receiptAddress,\n\t\t\t\tfalse,\n\t\t\t\t0\n\t\t\t);\n\n\t\t//add service to servicesLists for application\n\t\tservicesLists[msg.sender].push(_serviceId);\n\n\t\t//emit NewService\n\t\temit NewService(msg.sender, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction listService ( \n\t\t\tuint32 _serviceId, \n\t\t\tstring _serviceDescription,\n\t\t\tuint256 _tokensPerCredit,\n\t\t\tuint256 _maxCreditsPerProvision,\n\t\t\taddress _updateAddress,\n\t\t\taddress _receiptAddress\t) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//check service id is not 0\n\t\trequire(_serviceId != 0);\n\n\t\t//check service doesn't already exist for this application id\n\t\trequire(services[msg.sender][_serviceId].applicationAddress == 0);\n\n\t\t//check cost of the service is >0 \n\t\trequire(_tokensPerCredit != 0);\n\n\t\t//check receiptAddress is not address(0)\n\t\trequire(_receiptAddress != address(0));\n\n\t\t//update address should be address(0) or a non-sender address\n\t\trequire(_updateAddress != msg.sender);\n\n\t\t//add service to services mapping\n\t\tservices[msg.sender][_serviceId] = Service(\n\t\t\t\tmsg.sender,\n\t\t\t\t_serviceId,\n\t\t\t\tfalse,\n\t\t\t\t_serviceDescription,\n\t\t\t\t_tokensPerCredit,\n\t\t\t\t_maxCreditsPerProvision,\n\t\t\t\t_updateAddress,\n\t\t\t\t_receiptAddress,\n\t\t\t\tfalse,\n\t\t\t\t0\n\t\t\t);\n\n\t\t//add service to servicesLists for application\n\t\tservicesLists[msg.sender].push(_serviceId);\n\n\t\t//emit NewService\n\t\temit NewService(msg.sender, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction getServicesForApplication ( \n\t\t\taddress _applicationAddress ) \n\t\tpublic view returns (\n\t\t\tuint32[] serviceIds ) {\n\n\t\treturn servicesLists[_applicationAddress];\n\t}\n\n\tfunction getRemovedServicesForApplication (\n\t\t\taddress _applicationAddress ) \n\t\tpublic view returns (\n\t\t\tuint32[] serviceIds ) {\n\n\t\treturn servicesRemovedLists[_applicationAddress];\n\t}\n\n\tfunction isServiceRemoved (\n\t\t\taddress _applicationAddress,\n\t\t\tuint32 _serviceId )\n\t\tpublic view returns (\n\t\t\tbool ) {\n\n\t\t//returns true if service has been removed\n\t\treturn services[_applicationAddress][_serviceId].isRemoved;\n\t}\n\n\tfunction getServiceInformation ( \n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId )\n\t\tpublic view returns (\n\t\t\tbool exists,\n\t\t\tbool isSimple,\n\t\t\tstring serviceDescription,\n\t\t\tuint256 tokensPerCredit,\n\t\t\tuint256 maxCreditsPerProvision,\n\t\t\taddress receiptAddress,\n\t\t\tbool isRemoved,\n\t\t\tuint256 provisionHead ) {\n\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//services with unset application address indicates an empty/unset struct in the mapping\n\t\tif(s.applicationAddress == 0) {\n\t\t\t//first return parameter indicates whether the service exists\n\t\t\texists=false;\n\t\t\treturn;\n\n\t\t} else {\n\t\t\texists=true;\n\t\t\tisSimple=s.isSimple;\n\t\t\t//note that the returned service description can't be read in solidity funtion call\n\t\t\tserviceDescription=s.serviceDescription;\n\t\t\ttokensPerCredit=s.tokensPerCredit;\n\t\t\tmaxCreditsPerProvision=s.maxCreditsPerProvision;\n\t\t\treceiptAddress=s.receiptAddress;\n\t\t\tisRemoved=s.isRemoved;\n\t\t\tprovisionHead=s.provisionHead;\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfunction getServiceUpdateAddress (\n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId ) \n\t\tpublic view returns (\n\t\t\taddress updateAddress ) {\n\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\treturn s.updateAddress;\n\t}\n\n\tfunction updateServiceDescription (\n\t\t\taddress _targetApplicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tstring _serviceDescription ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_targetApplicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\tservices[_targetApplicationAddress][_serviceId].serviceDescription=_serviceDescription;\n\t\t\n\t\temit ServiceChanged(_targetApplicationAddress, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction updateServiceTokensPerCredit (\n\t\t\taddress _targetApplicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tuint256 _tokensPerCredit ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_targetApplicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//check changed cost of the service is >0 \n\t\trequire(_tokensPerCredit != 0);\n\n\t\tservices[_targetApplicationAddress][_serviceId].tokensPerCredit=_tokensPerCredit;\n\t\t\n\t\temit ServiceChanged(_targetApplicationAddress, _serviceId);\n\n\t\treturn true;\t\t\n\t}\n\n\tfunction updateServiceMaxCreditsPerProvision (\n\t\t\taddress _targetApplicationAddress,\n\t\t\tuint32 _serviceId,\n\t\t\tuint256 _maxCreditsPerProvision )\n\t\tpublic returns (\n\t\t\tbool sucess ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_targetApplicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//note that credits per provision can be == 0 (no limit)\n\n\t\t//change max credits per provision for this service\n\t\tservices[_targetApplicationAddress][_serviceId].maxCreditsPerProvision=_maxCreditsPerProvision;\n\n\t\temit ServiceChanged(_targetApplicationAddress, _serviceId);\n\t\n\t\treturn true;\t\t\n\t}\n\n\tfunction changeServiceReceiptAddress(\n\t\t\tuint32 _serviceId, \n\t\t\taddress _receiptAddress ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//receipt address can only be changed by application address\n\n\t\t//check that service exists\n\t\trequire(services[msg.sender][_serviceId].applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[msg.sender][_serviceId].isRemoved == false);\n\n\t\t//check changed receiptAddress is not address(0)\n\t\trequire(_receiptAddress != address(0));\n\n\t\tservices[msg.sender][_serviceId].receiptAddress=_receiptAddress;\n\t\t\n\t\temit ServiceChanged(msg.sender, _serviceId);\n\n\t\treturn true;\t\t\n\t}\n\n\tfunction changeServiceUpdateAddress (\n\t\t\tuint32 _serviceId,\n\t\t\taddress _updateAddress )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//update address can only be changed by application address\n\n\t\t//check that service exists\n\t\trequire(services[msg.sender][_serviceId].applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[msg.sender][_serviceId].isRemoved == false);\n\n\t\t//note: update address can be address(0)\n\t\t//change the update address\n\t\tservices[msg.sender][_serviceId].updateAddress=_updateAddress;\n\n\t\temit ServiceChanged(msg.sender, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction removeService (\n\t\t\taddress _targetApplicationAddress, \n\t\t\tuint32 _serviceId ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//check that service exists\n\t\trequire(services[_targetApplicationAddress][_serviceId].applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( services[_targetApplicationAddress][_serviceId].updateAddress != address(0) \n\t\t\t   && msg.sender == services[_targetApplicationAddress][_serviceId].updateAddress \n\t\t\t  ));\n\n\t\t//check that service is not already removed\n\t\trequire(services[_targetApplicationAddress][_serviceId].isRemoved == false);\n\n\t\t//add to removed array\n\t\tservicesRemovedLists[_targetApplicationAddress].push(_serviceId);\n\n\t\t//change value of isRemoved to true\n\t\tservices[_targetApplicationAddress][_serviceId].isRemoved = true;\n\n\t\temit ServiceRemoved(_targetApplicationAddress, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction transferToSimpleService (\n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tuint256 _tokenValue, \n\t\t\tuint256 _applicationReference, \n\t\t\tuint256 _multiple ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//requested multiple must be >= 1\n\t\trequire(_multiple > 0);\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//service must exist\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[_applicationAddress][_serviceId].isRemoved == false);\n\n\t\t//check that service is a simple service\n\t\trequire(s.isSimple == true);\n\n\t\t//expected value is the token cost of the service multiplied by the requested multiple\n\t\tuint256 expectedValue=s.tokensPerCredit.mul(_multiple);\n\n\t\t//supplied token value must equal expected value\n\t\trequire(expectedValue == _tokenValue);\n\n\t\t//transfer the tokens -- this verifies the sender owns the tokens\n\t\ttransfer(s.receiptAddress, _tokenValue);\n\n\t\t//this starts and ends a simple provision at a single point in time \n\t\temit CompleteSimpleProvision(_applicationAddress, _serviceId, msg.sender, _multiple, _applicationReference);\n\n\t\treturn true;\n\t}\n\n\n\tfunction transferToService (\n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tuint256 _tokenValue, \n\t\t\tuint256 _credits,\n\t\t\tuint256 _applicationReference ) \n\t\tpublic returns (\n\t\t\tuint256 provisionId ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//service must exist\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[_applicationAddress][_serviceId].isRemoved == false);\n\n\t\t//check that service is not a simple service\n\t\trequire(s.isSimple == false);\n\n\t\t//verify: value == credits * tokens per credit\n\t\trequire(_tokenValue == (_credits.mul(s.tokensPerCredit)));\n\n\t\t//verify: max credits == 0 OR (value/tokens per credit) <= max credits per provision\n\t\trequire( s.maxCreditsPerProvision == 0 ||\n\t\t\t_credits <= s.maxCreditsPerProvision);\n\n\t\t//increment provision head and use as provision id\n\t\ts.provisionHead++;\n\t\tuint256 pid = s.provisionHead;\n\n\t\t//create provision in mapping\n\t\tprovisions[_applicationAddress][_serviceId][pid] = Provision (\n\t\t\t\ts.tokensPerCredit,\n\t\t\t\t_credits,\n\t\t\t\t_applicationReference,\n\t\t\t\tmsg.sender,\n\t\t\t\t_credits\t\t\n\t\t\t);\n\n\t\t//transfer the tokens\n\t\ttransfer(s.receiptAddress, _tokenValue);\n\n\t\t//emits a start provision \n\t\temit StartProvision(_applicationAddress, _serviceId, msg.sender, pid, _credits, s.tokensPerCredit, _applicationReference);\n\n\t\t//return provision id\n\t\treturn pid;\n\t}\n\n\tfunction getProvisionCreditsRemaining (\n\t\t\taddress _applicationAddress,\n\t\t\tuint32 _serviceId,\n\t\t    uint256 _provisionId )\n\t\tpublic view returns (\n\t\t\tuint256 credits) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//service must exist\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[_applicationAddress][_serviceId].isRemoved == false);\t\t\n\n\t\t//get & check that the provision exists (address at userAddress)\n\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\trequire(p.userAddress != 0);\n\n\t\t//return the credits remaining for this provision\n\t\treturn p.creditsRemaining;\n\t}\n\n\tfunction updateProvision (\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256 _provisionId,\n\t\t    uint256 _creditsRemaining )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//credits remaining must be >0, complete provision should be used to set to 0\n\t\trequire(_creditsRemaining > 0);\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _applicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//get & check that the provision exists (address at userAddress)\n\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\trequire(p.userAddress != 0);\n\n\t\t//update the credits remaining\n\t\tp.creditsRemaining=_creditsRemaining;\n\t\n\t\t//fires UpdateProvision\n\t\temit UpdateProvision(_applicationAddress, _serviceId, _provisionId, _creditsRemaining);\n\n\t\treturn true;\t\t\n\t}\n\n\tfunction completeProvision (\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256 _provisionId,\n\t\t    uint256 _creditsOutstanding )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _applicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//get & check that the provision exists (address at userAddress)\n\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\trequire(p.userAddress != 0);\n\n\t\tif(_creditsOutstanding > 0) {\n\t\t\t//can only signal refund total of credits originally provisioned\n\t\t\trequire(_creditsOutstanding <= p.creditsProvisioned);\n\n\t\t\temit SignalProvisionRefund(_applicationAddress, _serviceId, _provisionId, _creditsOutstanding.mul(p.tokensPerCredit));\n\t\t}\n\n\t\t//credits remaining on service is set to 0\n\t\tp.creditsRemaining=0;\n\n\t\t//fires CompleteProvision\n\t\temit CompleteProvision(_applicationAddress, _serviceId, _provisionId, _creditsOutstanding);\n\n\t\treturn true;\n\t}\n\n\n\tfunction confirmReference (\n\t\t\taddress _applicationAddress,\n\t\t\tuint256 _applicationReference,\n\t\t\tuint256 _senderTokensMinimum )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//sender must have some tokens - if 0 is passed to _senderTokensMinimum\n\t\t//then it is assumed that the method is checking that the sender has any amount\n\t\t//of tokens (>0)\n\t\trequire(balances[msg.sender] > 0);\n\n\t\t//sender must have min tokens if specified\n\t\trequire(_senderTokensMinimum == 0 \n\t\t\t|| balances[msg.sender] >= _senderTokensMinimum);\n\n\t\temit ReferenceConfirmed(_applicationAddress, _applicationReference, msg.sender, _senderTokensMinimum);\n\n\t\treturn true;\n\t}\n\n\n\tfunction transferBecauseOf (\n\t\t    address _to,\n\t\t    uint256 _value,\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256 _provisionId )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//provision ID can be optional, but if it's supplied it must exist\n\t\tif(_provisionId != 0) {\n\t\t\t//get & check that the provision exists (address at userAddress)\n\t\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\t\trequire(p.userAddress != 0);\n\t\t}\n\n\t\t//do the transfer\n\t\ttransfer(_to, _value);\n\n\t\temit TransferBecauseOf(_applicationAddress, _serviceId, _provisionId, msg.sender, _to, _value);\n\n\t\treturn true;\n\t}\n\n\n\tfunction transferBecauseOfAggregate (\n\t\t    address _to,\n\t\t    uint256 _value,\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256[] _provisionIds,\n\t\t    uint256[] _tokenAmounts )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//do the transfer\n\t\ttransfer(_to, _value);\n\n\t\temit TransferBecauseOfAggregate(_applicationAddress, _serviceId, _provisionIds, _tokenAmounts, msg.sender, _to, _value);\n\n\t\treturn true;\n\t}\n\n\tfunction ownerBurn ( \n\t\t\tuint256 _value )\n\t\tpublic returns (\n\t\t\tbool success) {\n\n\t\t//only the contract owner can burn tokens\n\t\trequire(msg.sender == contractOwner);\n\n\t\t//can only burn tokens held by the owner\n\t\trequire(_value <= balances[contractOwner]);\n\n\t\t//total supply of tokens is decremented when burned\n\t\ttotalSupply_ = totalSupply_.sub(_value);\n\n\t\t//balance of the contract owner is reduced (the contract owner's tokens are burned)\n\t\tbalances[contractOwner] = balances[contractOwner].sub(_value);\n\n\t\t//burning tokens emits a transfer to 0, as well as TokensBurned\n\t\temit Transfer(contractOwner, address(0), _value);\n\t\temit TokensBurned(contractOwner, _value);\n\n\t\treturn true;\n\n\t}\n\t\n\t\n\tfunction totalSupply ( ) public view returns (\n\t\tuint256 ) {\n\n\t\treturn totalSupply_;\n\t}\n\n\tfunction balanceOf (\n\t\t\taddress _owner ) \n\t\tpublic view returns (\n\t\t\tuint256 ) {\n\n\t\treturn balances[_owner];\n\t}\n\n\tfunction transfer (\n\t\t\taddress _to, \n\t\t\tuint256 _value ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[msg.sender]);\n\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n   \t//changing approval with this method has the same underlying issue as https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   \t//in that transaction order can be modified in a block to spend, change approval, spend again\n   \t//the method is kept for ERC-20 compatibility, but a set to zero, set again or use of the below increase/decrease should be used instead\n\tfunction approve (\n\t\t\taddress _spender, \n\t\t\tuint256 _value ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\tallowed[msg.sender][_spender] = _value;\n\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\tfunction increaseApproval (\n\t\t\taddress _spender, \n\t\t\tuint256 _addedValue ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\tfunction decreaseApproval (\n\t\t\taddress _spender,\n\t\t\tuint256 _subtractedValue ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\tuint256 oldValue = allowed[msg.sender][_spender];\n\n\t\tif (_subtractedValue > oldValue) {\n\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t} else {\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\t\t}\n\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\tfunction allowance (\n\t\t\taddress _owner, \n\t\t\taddress _spender ) \n\t\tpublic view returns (\n\t\t\tuint256 remaining ) {\n\n\t\treturn allowed[_owner][_spender];\n\t}\n\n\tfunction transferFrom (\n\t\t\taddress _from, \n\t\t\taddress _to, \n\t\t\tuint256 _value ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[_from]);\n\t\trequire(_value <= allowed[_from][msg.sender]);\n\n\t\tbalances[_from] = balances[_from].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n}",
        "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_U42_4 + calldata_U42_32 + 4)) +\n96: 0xc48c04261444f7ce9c1a66f6c355debe3fffffffffffffffffffffffffffffed\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_U42_4 + calldata_U42_32 + 4)) +\n96: 0xe9ed542651000003d76906f7c018193fbfffffffffffffffffffffffffffffcb\ncaller: 0x0\ncalldata_U42_32 + 100: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_U42_32 + 132: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_U42_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0 +\nkeccac_4294967295_&_4294967295_&_4294967295_&_calldata_U42_4: 0x0\ncalldata_U42_4: 0xffffffff\ncalldata_U42_0: 0x16a7859b00000000000000000000000000000000000000000000000000000000\ncalldatasize_U42: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x16a7859b`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/10/0x1f988b4ee752826e834f478b7668725ae7ecf53c.sol",
        "function": "_function_0x16a7859b",
        "lineno": 61,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 22036,
        "code": "s\n\tusing SafeMath for uint256;\n\n\tstring public constant name = \"U42\";\n\tstring public constant symbol = \"U42\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant initialSupply = 525000000 * (10 ** uint256(decimals));\n\tuint256 internal totalSupply_ = initialSupply;\n\taddress public contractOwner;\n\n\t//token balances\n\tmapping(address => uint256) balances;\n\n\t//for each balance address, map allowed addresses to amount allowed\n\tmapping (address => mapping (address => uint256)) internal allowed;\n\n\t//each service is represented by a Service struct \n\tstruct Service {\n\t\taddress applicationAddress;\n\t\tuint32 serviceId;\n\t\tbool isSimple;\n\t\tstring serviceDescription;\n\t\tuint256 tokensPerCredit;\n\t\tuint256 maxCreditsPerProvision;\n\t\taddress updateAddress;\n\t\taddress receiptAddress;\n\t\tbool isRemoved;\n\t\tuint256 provisionHead;\n\t}\n\n\tstruct Provision {\n\t\tuint256 tokensPerCredit;\n\t\tuint256 creditsRemaining;\n\t\tuint256 applicationReference;\n\t\taddress userAddress;\n\t\tuint256 creditsProvisioned;\n\t}\n\n\t//mapping of application addresses to service structs\n\tmapping (address => mapping (uint32 => Service)) services;\n\n\t//mapping of application addresses to service structs to provisions\n\tmapping (address => mapping (uint32 => mapping (uint256 => Provision))) provisions;\n\n\t//mapping of application addresses to lists of services\n\tmapping (address => uint32[]) servicesLists;\n\n\t//mapping of application addresses to lists of removed services\n\tmapping (address => uint32[]) servicesRemovedLists;\n\n\t//methods emit the following events\n\tevent Transfer (\n\t\taddress indexed from, \n\t\taddress indexed to, \n\t\tuint256 value );\n\n\tevent TokensBurned (\n\t\taddress indexed burner, \n\t\tuint256 value );\n\n\tevent Approval (\n\t\taddress indexed owner,\n\t\taddress indexed spender,\n\t\tuint256 value );\n\n\tevent NewService (\n\t\taddress indexed applicationAddress,\n\t\tuint32 serviceId );\n\n\tevent ServiceChanged (\n\t\taddress indexed applicationAddress,\n\t\tuint32 serviceId );\n\n\tevent ServiceRemoved (\n\t\taddress indexed applicationAddress,\n\t\tuint32 serviceId );\n\n\tevent CompleteSimpleProvision (\n\t\taddress indexed applicationAddress,\n\t\tuint32 indexed serviceId,\n\t\taddress indexed userAddress,\n\t\tuint256 multiple,\n\t\tuint256 applicationReference );\n\n\tevent ReferenceConfirmed (\n\t\taddress indexed applicationAddress,\n\t\tuint256 indexed applicationReference, \n\t\taddress indexed confirmedBy, \n\t\tuint256 confirmerTokensMinimum );\n\n\tevent StartProvision (\n\t    address indexed applicationAddress, \n\t    uint32 indexed serviceId, \n\t    address indexed userAddress,\n\t    uint256 provisionId,\n\t    uint256 serviceCredits,\n\t    uint256 tokensPerCredit, \n\t    uint256 applicationReference );\n\n\tevent UpdateProvision (\n\t    address indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    uint256 creditsRemaining );\n\n\tevent CompleteProvision (\n\t    address indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    uint256 creditsOutstanding );\n\n\tevent SignalProvisionRefund (\n\t    address indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    uint256 tokenValue );\n\n\tevent TransferBecauseOf (\n\t\taddress indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    address from,\n\t    address to,\n\t    uint256 value );\n\n\tevent TransferBecauseOfAggregate (\n\t\taddress indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256[] provisionIds,\n\t    uint256[] tokenAmounts,\n\t    address from,\n\t    address to,\n\t    uint256 value );\n\n\n\tconstructor() public {\n\t\t//contract creator holds all tokens at creation\n\t\tbalances[msg.sender] = totalSupply_;\n\n\t\t//record contract owner for later reference (e.g. in ownerBurn)\n\t\tcontractOwner=msg.sender;\n\n\t\t//indicate all tokens were sent to contract address\n\t\temit Transfer(address(0), msg.sender, totalSupply_);\n\t}\n\n\tfunction listSimpleService ( \n\t\t\tuint32 _serviceId, \n\t\t\tstring _serviceDescription,\n\t\t\tuint256 _tokensRequired,\n\t\t\taddress _updateAddress,\n\t\t\taddress _receiptAddress\t) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//check service id is not 0\n\t\trequire(_serviceId != 0);\n\n\t\t//check service doesn't already exist for this application id\n\t\trequire(services[msg.sender][_serviceId].applicationAddress == 0);\n\n\t\t//check cost of the service is >0 \n\t\trequire(_tokensRequired != 0);\n\n\t\t//check receiptAddress is not address(0)\n\t\trequire(_receiptAddress != address(0));\n\n\t\t//update address should be address(0) or a non-sender address\n\t\trequire(_updateAddress != msg.sender);\n\n\t\t//add service to services mapping\n\t\tservices[msg.sender][_serviceId] = Service(\n\t\t\t\tmsg.sender,\n\t\t\t\t_serviceId,\n\t\t\t\ttrue,\n\t\t\t\t_serviceDescription,\n\t\t\t\t_tokensRequired,\n\t\t\t\t1,\n\t\t\t\t_updateAddress,\n\t\t\t\t_receiptAddress,\n\t\t\t\tfalse,\n\t\t\t\t0\n\t\t\t);\n\n\t\t//add service to servicesLists for application\n\t\tservicesLists[msg.sender].push(_serviceId);\n\n\t\t//emit NewService\n\t\temit NewService(msg.sender, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction listService ( \n\t\t\tuint32 _serviceId, \n\t\t\tstring _serviceDescription,\n\t\t\tuint256 _tokensPerCredit,\n\t\t\tuint256 _maxCreditsPerProvision,\n\t\t\taddress _updateAddress,\n\t\t\taddress _receiptAddress\t) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//check service id is not 0\n\t\trequire(_serviceId != 0);\n\n\t\t//check service doesn't already exist for this application id\n\t\trequire(services[msg.sender][_serviceId].applicationAddress == 0);\n\n\t\t//check cost of the service is >0 \n\t\trequire(_tokensPerCredit != 0);\n\n\t\t//check receiptAddress is not address(0)\n\t\trequire(_receiptAddress != address(0));\n\n\t\t//update address should be address(0) or a non-sender address\n\t\trequire(_updateAddress != msg.sender);\n\n\t\t//add service to services mapping\n\t\tservices[msg.sender][_serviceId] = Service(\n\t\t\t\tmsg.sender,\n\t\t\t\t_serviceId,\n\t\t\t\tfalse,\n\t\t\t\t_serviceDescription,\n\t\t\t\t_tokensPerCredit,\n\t\t\t\t_maxCreditsPerProvision,\n\t\t\t\t_updateAddress,\n\t\t\t\t_receiptAddress,\n\t\t\t\tfalse,\n\t\t\t\t0\n\t\t\t);\n\n\t\t//add service to servicesLists for application\n\t\tservicesLists[msg.sender].push(_serviceId);\n\n\t\t//emit NewService\n\t\temit NewService(msg.sender, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction getServicesForApplication ( \n\t\t\taddress _applicationAddress ) \n\t\tpublic view returns (\n\t\t\tuint32[] serviceIds ) {\n\n\t\treturn servicesLists[_applicationAddress];\n\t}\n\n\tfunction getRemovedServicesForApplication (\n\t\t\taddress _applicationAddress ) \n\t\tpublic view returns (\n\t\t\tuint32[] serviceIds ) {\n\n\t\treturn servicesRemovedLists[_applicationAddress];\n\t}\n\n\tfunction isServiceRemoved (\n\t\t\taddress _applicationAddress,\n\t\t\tuint32 _serviceId )\n\t\tpublic view returns (\n\t\t\tbool ) {\n\n\t\t//returns true if service has been removed\n\t\treturn services[_applicationAddress][_serviceId].isRemoved;\n\t}\n\n\tfunction getServiceInformation ( \n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId )\n\t\tpublic view returns (\n\t\t\tbool exists,\n\t\t\tbool isSimple,\n\t\t\tstring serviceDescription,\n\t\t\tuint256 tokensPerCredit,\n\t\t\tuint256 maxCreditsPerProvision,\n\t\t\taddress receiptAddress,\n\t\t\tbool isRemoved,\n\t\t\tuint256 provisionHead ) {\n\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//services with unset application address indicates an empty/unset struct in the mapping\n\t\tif(s.applicationAddress == 0) {\n\t\t\t//first return parameter indicates whether the service exists\n\t\t\texists=false;\n\t\t\treturn;\n\n\t\t} else {\n\t\t\texists=true;\n\t\t\tisSimple=s.isSimple;\n\t\t\t//note that the returned service description can't be read in solidity funtion call\n\t\t\tserviceDescription=s.serviceDescription;\n\t\t\ttokensPerCredit=s.tokensPerCredit;\n\t\t\tmaxCreditsPerProvision=s.maxCreditsPerProvision;\n\t\t\treceiptAddress=s.receiptAddress;\n\t\t\tisRemoved=s.isRemoved;\n\t\t\tprovisionHead=s.provisionHead;\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfunction getServiceUpdateAddress (\n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId ) \n\t\tpublic view returns (\n\t\t\taddress updateAddress ) {\n\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\treturn s.updateAddress;\n\t}\n\n\tfunction updateServiceDescription (\n\t\t\taddress _targetApplicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tstring _serviceDescription ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_targetApplicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\tservices[_targetApplicationAddress][_serviceId].serviceDescription=_serviceDescription;\n\t\t\n\t\temit ServiceChanged(_targetApplicationAddress, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction updateServiceTokensPerCredit (\n\t\t\taddress _targetApplicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tuint256 _tokensPerCredit ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_targetApplicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//check changed cost of the service is >0 \n\t\trequire(_tokensPerCredit != 0);\n\n\t\tservices[_targetApplicationAddress][_serviceId].tokensPerCredit=_tokensPerCredit;\n\t\t\n\t\temit ServiceChanged(_targetApplicationAddress, _serviceId);\n\n\t\treturn true;\t\t\n\t}\n\n\tfunction updateServiceMaxCreditsPerProvision (\n\t\t\taddress _targetApplicationAddress,\n\t\t\tuint32 _serviceId,\n\t\t\tuint256 _maxCreditsPerProvision )\n\t\tpublic returns (\n\t\t\tbool sucess ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_targetApplicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//note that credits per provision can be == 0 (no limit)\n\n\t\t//change max credits per provision for this service\n\t\tservices[_targetApplicationAddress][_serviceId].maxCreditsPerProvision=_maxCreditsPerProvision;\n\n\t\temit ServiceChanged(_targetApplicationAddress, _serviceId);\n\t\n\t\treturn true;\t\t\n\t}\n\n\tfunction changeServiceReceiptAddress(\n\t\t\tuint32 _serviceId, \n\t\t\taddress _receiptAddress ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//receipt address can only be changed by application address\n\n\t\t//check that service exists\n\t\trequire(services[msg.sender][_serviceId].applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[msg.sender][_serviceId].isRemoved == false);\n\n\t\t//check changed receiptAddress is not address(0)\n\t\trequire(_receiptAddress != address(0));\n\n\t\tservices[msg.sender][_serviceId].receiptAddress=_receiptAddress;\n\t\t\n\t\temit ServiceChanged(msg.sender, _serviceId);\n\n\t\treturn true;\t\t\n\t}\n\n\tfunction changeServiceUpdateAddress (\n\t\t\tuint32 _serviceId,\n\t\t\taddress _updateAddress )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//update address can only be changed by application address\n\n\t\t//check that service exists\n\t\trequire(services[msg.sender][_serviceId].applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[msg.sender][_serviceId].isRemoved == false);\n\n\t\t//note: update address can be address(0)\n\t\t//change the update address\n\t\tservices[msg.sender][_serviceId].updateAddress=_updateAddress;\n\n\t\temit ServiceChanged(msg.sender, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction removeService (\n\t\t\taddress _targetApplicationAddress, \n\t\t\tuint32 _serviceId ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//check that service exists\n\t\trequire(services[_targetApplicationAddress][_serviceId].applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( services[_targetApplicationAddress][_serviceId].updateAddress != address(0) \n\t\t\t   && msg.sender == services[_targetApplicationAddress][_serviceId].updateAddress \n\t\t\t  ));\n\n\t\t//check that service is not already removed\n\t\trequire(services[_targetApplicationAddress][_serviceId].isRemoved == false);\n\n\t\t//add to removed array\n\t\tservicesRemovedLists[_targetApplicationAddress].push(_serviceId);\n\n\t\t//change value of isRemoved to true\n\t\tservices[_targetApplicationAddress][_serviceId].isRemoved = true;\n\n\t\temit ServiceRemoved(_targetApplicationAddress, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction transferToSimpleService (\n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tuint256 _tokenValue, \n\t\t\tuint256 _applicationReference, \n\t\t\tuint256 _multiple ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//requested multiple must be >= 1\n\t\trequire(_multiple > 0);\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//service must exist\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[_applicationAddress][_serviceId].isRemoved == false);\n\n\t\t//check that service is a simple service\n\t\trequire(s.isSimple == true);\n\n\t\t//expected value is the token cost of the service multiplied by the requested multiple\n\t\tuint256 expectedValue=s.tokensPerCredit.mul(_multiple);\n\n\t\t//supplied token value must equal expected value\n\t\trequire(expectedValue == _tokenValue);\n\n\t\t//transfer the tokens -- this verifies the sender owns the tokens\n\t\ttransfer(s.receiptAddress, _tokenValue);\n\n\t\t//this starts and ends a simple provision at a single point in time \n\t\temit CompleteSimpleProvision(_applicationAddress, _serviceId, msg.sender, _multiple, _applicationReference);\n\n\t\treturn true;\n\t}\n\n\n\tfunction transferToService (\n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tuint256 _tokenValue, \n\t\t\tuint256 _credits,\n\t\t\tuint256 _applicationReference ) \n\t\tpublic returns (\n\t\t\tuint256 provisionId ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//service must exist\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[_applicationAddress][_serviceId].isRemoved == false);\n\n\t\t//check that service is not a simple service\n\t\trequire(s.isSimple == false);\n\n\t\t//verify: value == credits * tokens per credit\n\t\trequire(_tokenValue == (_credits.mul(s.tokensPerCredit)));\n\n\t\t//verify: max credits == 0 OR (value/tokens per credit) <= max credits per provision\n\t\trequire( s.maxCreditsPerProvision == 0 ||\n\t\t\t_credits <= s.maxCreditsPerProvision);\n\n\t\t//increment provision head and use as provision id\n\t\ts.provisionHead++;\n\t\tuint256 pid = s.provisionHead;\n\n\t\t//create provision in mapping\n\t\tprovisions[_applicationAddress][_serviceId][pid] = Provision (\n\t\t\t\ts.tokensPerCredit,\n\t\t\t\t_credits,\n\t\t\t\t_applicationReference,\n\t\t\t\tmsg.sender,\n\t\t\t\t_credits\t\t\n\t\t\t);\n\n\t\t//transfer the tokens\n\t\ttransfer(s.receiptAddress, _tokenValue);\n\n\t\t//emits a start provision \n\t\temit StartProvision(_applicationAddress, _serviceId, msg.sender, pid, _credits, s.tokensPerCredit, _applicationReference);\n\n\t\t//return provision id\n\t\treturn pid;\n\t}\n\n\tfunction getProvisionCreditsRemaining (\n\t\t\taddress _applicationAddress,\n\t\t\tuint32 _serviceId,\n\t\t    uint256 _provisionId )\n\t\tpublic view returns (\n\t\t\tuint256 credits) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//service must exist\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[_applicationAddress][_serviceId].isRemoved == false);\t\t\n\n\t\t//get & check that the provision exists (address at userAddress)\n\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\trequire(p.userAddress != 0);\n\n\t\t//return the credits remaining for this provision\n\t\treturn p.creditsRemaining;\n\t}\n\n\tfunction updateProvision (\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256 _provisionId,\n\t\t    uint256 _creditsRemaining )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//credits remaining must be >0, complete provision should be used to set to 0\n\t\trequire(_creditsRemaining > 0);\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _applicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//get & check that the provision exists (address at userAddress)\n\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\trequire(p.userAddress != 0);\n\n\t\t//update the credits remaining\n\t\tp.creditsRemaining=_creditsRemaining;\n\t\n\t\t//fires UpdateProvision\n\t\temit UpdateProvision(_applicationAddress, _serviceId, _provisionId, _creditsRemaining);\n\n\t\treturn true;\t\t\n\t}\n\n\tfunction completeProvision (\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256 _provisionId,\n\t\t    uint256 _creditsOutstanding )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _applicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//get & check that the provision exists (address at userAddress)\n\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\trequire(p.userAddress != 0);\n\n\t\tif(_creditsOutstanding > 0) {\n\t\t\t//can only signal refund total of credits originally provisioned\n\t\t\trequire(_creditsOutstanding <= p.creditsProvisioned);\n\n\t\t\temit SignalProvisionRefund(_applicationAddress, _serviceId, _provisionId, _creditsOutstanding.mul(p.tokensPerCredit));\n\t\t}\n\n\t\t//credits remaining on service is set to 0\n\t\tp.creditsRemaining=0;\n\n\t\t//fires CompleteProvision\n\t\temit CompleteProvision(_applicationAddress, _serviceId, _provisionId, _creditsOutstanding);\n\n\t\treturn true;\n\t}\n\n\n\tfunction confirmReference (\n\t\t\taddress _applicationAddress,\n\t\t\tuint256 _applicationReference,\n\t\t\tuint256 _senderTokensMinimum )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//sender must have some tokens - if 0 is passed to _senderTokensMinimum\n\t\t//then it is assumed that the method is checking that the sender has any amount\n\t\t//of tokens (>0)\n\t\trequire(balances[msg.sender] > 0);\n\n\t\t//sender must have min tokens if specified\n\t\trequire(_senderTokensMinimum == 0 \n\t\t\t|| balances[msg.sender] >= _senderTokensMinimum);\n\n\t\temit ReferenceConfirmed(_applicationAddress, _applicationReference, msg.sender, _senderTokensMinimum);\n\n\t\treturn true;\n\t}\n\n\n\tfunction transferBecauseOf (\n\t\t    address _to,\n\t\t    uint256 _value,\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256 _provisionId )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//provision ID can be optional, but if it's supplied it must exist\n\t\tif(_provisionId != 0) {\n\t\t\t//get & check that the provision exists (address at userAddress)\n\t\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\t\trequire(p.userAddress != 0);\n\t\t}\n\n\t\t//do the transfer\n\t\ttransfer(_to, _value);\n\n\t\temit TransferBecauseOf(_applicationAddress, _serviceId, _provisionId, msg.sender, _to, _value);\n\n\t\treturn true;\n\t}\n\n\n\tfunction transferBecauseOfAggregate (\n\t\t    address _to,\n\t\t    uint256 _value,\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256[] _provisionIds,\n\t\t    uint256[] _tokenAmounts )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//do the transfer\n\t\ttransfer(_to, _value);\n\n\t\temit TransferBecauseOfAggregate(_applicationAddress, _serviceId, _provisionIds, _tokenAmounts, msg.sender, _to, _value);\n\n\t\treturn true;\n\t}\n\n\tfunction ownerBurn ( \n\t\t\tuint256 _value )\n\t\tpublic returns (\n\t\t\tbool success) {\n\n\t\t//only the contract owner can burn tokens\n\t\trequire(msg.sender == contractOwner);\n\n\t\t//can only burn tokens held by the owner\n\t\trequire(_value <= balances[contractOwner]);\n\n\t\t//total supply of tokens is decremented when burned\n\t\ttotalSupply_ = totalSupply_.sub(_value);\n\n\t\t//balance of the contract owner is reduced (the contract owner's tokens are burned)\n\t\tbalances[contractOwner] = balances[contractOwner].sub(_value);\n\n\t\t//burning tokens emits a transfer to 0, as well as TokensBurned\n\t\temit Transfer(contractOwner, address(0), _value);\n\t\temit TokensBurned(contractOwner, _value);\n\n\t\treturn true;\n\n\t}\n\t\n\t\n\tfunction totalSupply ( ) public view returns (\n\t\tuint256 ) {\n\n\t\treturn totalSupply_;\n\t}\n\n\tfunction balanceOf (\n\t\t\taddress _owner ) \n\t\tpublic view returns (\n\t\t\tuint256 ) {\n\n\t\treturn balances[_owner];\n\t}\n\n\tfunction transfer (\n\t\t\taddress _to, \n\t\t\tuint256 _value ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[msg.sender]);\n\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n   \t//changing approval with this method has the same underlying issue as https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   \t//in that transaction order can be modified in a block to spend, change approval, spend again\n   \t//the method is kept for ERC-20 compatibility, but a set to zero, set again or use of the below increase/decrease should be used instead\n\tfunction approve (\n\t\t\taddress _spender, \n\t\t\tuint256 _value ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\tallowed[msg.sender][_spender] = _value;\n\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\tfunction increaseApproval (\n\t\t\taddress _spender, \n\t\t\tuint256 _addedValue ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\tfunction decreaseApproval (\n\t\t\taddress _spender,\n\t\t\tuint256 _subtractedValue ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\tuint256 oldValue = allowed[msg.sender][_spender];\n\n\t\tif (_subtractedValue > oldValue) {\n\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t} else {\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\t\t}\n\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\tfunction allowance (\n\t\t\taddress _owner, \n\t\t\taddress _spender ) \n\t\tpublic view returns (\n\t\t\tuint256 remaining ) {\n\n\t\treturn allowed[_owner][_spender];\n\t}\n\n\tfunction transferFrom (\n\t\t\taddress _from, \n\t\t\taddress _to, \n\t\t\tuint256 _value ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[_from]);\n\t\trequire(_value <= allowed[_from][msg.sender]);\n\n\t\tbalances[_from] = balances[_from].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n}",
        "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_U42_4 + calldata_U42_32 + 4)) +\n96: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_U42_4 + calldata_U42_32 + 4)) +\n96: 0x25\ncaller: 0x0\ncalldata_U42_32 + 100: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_U42_32 + 132: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_U42_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0 +\nkeccac_4294967295_&_4294967295_&_4294967295_&_calldata_U42_4: 0x0\ncalldata_U42_4: 0xffffffff\ncalldata_U42_0: 0x16a7859b00000000000000000000000000000000000000000000000000000000\ncalldatasize_U42: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x16a7859b`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/10/0x1f988b4ee752826e834f478b7668725ae7ecf53c.sol",
        "function": "_function_0x16a7859b",
        "lineno": 61,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 22041,
        "code": "s\n\tusing SafeMath for uint256;\n\n\tstring public constant name = \"U42\";\n\tstring public constant symbol = \"U42\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant initialSupply = 525000000 * (10 ** uint256(decimals));\n\tuint256 internal totalSupply_ = initialSupply;\n\taddress public contractOwner;\n\n\t//token balances\n\tmapping(address => uint256) balances;\n\n\t//for each balance address, map allowed addresses to amount allowed\n\tmapping (address => mapping (address => uint256)) internal allowed;\n\n\t//each service is represented by a Service struct \n\tstruct Service {\n\t\taddress applicationAddress;\n\t\tuint32 serviceId;\n\t\tbool isSimple;\n\t\tstring serviceDescription;\n\t\tuint256 tokensPerCredit;\n\t\tuint256 maxCreditsPerProvision;\n\t\taddress updateAddress;\n\t\taddress receiptAddress;\n\t\tbool isRemoved;\n\t\tuint256 provisionHead;\n\t}\n\n\tstruct Provision {\n\t\tuint256 tokensPerCredit;\n\t\tuint256 creditsRemaining;\n\t\tuint256 applicationReference;\n\t\taddress userAddress;\n\t\tuint256 creditsProvisioned;\n\t}\n\n\t//mapping of application addresses to service structs\n\tmapping (address => mapping (uint32 => Service)) services;\n\n\t//mapping of application addresses to service structs to provisions\n\tmapping (address => mapping (uint32 => mapping (uint256 => Provision))) provisions;\n\n\t//mapping of application addresses to lists of services\n\tmapping (address => uint32[]) servicesLists;\n\n\t//mapping of application addresses to lists of removed services\n\tmapping (address => uint32[]) servicesRemovedLists;\n\n\t//methods emit the following events\n\tevent Transfer (\n\t\taddress indexed from, \n\t\taddress indexed to, \n\t\tuint256 value );\n\n\tevent TokensBurned (\n\t\taddress indexed burner, \n\t\tuint256 value );\n\n\tevent Approval (\n\t\taddress indexed owner,\n\t\taddress indexed spender,\n\t\tuint256 value );\n\n\tevent NewService (\n\t\taddress indexed applicationAddress,\n\t\tuint32 serviceId );\n\n\tevent ServiceChanged (\n\t\taddress indexed applicationAddress,\n\t\tuint32 serviceId );\n\n\tevent ServiceRemoved (\n\t\taddress indexed applicationAddress,\n\t\tuint32 serviceId );\n\n\tevent CompleteSimpleProvision (\n\t\taddress indexed applicationAddress,\n\t\tuint32 indexed serviceId,\n\t\taddress indexed userAddress,\n\t\tuint256 multiple,\n\t\tuint256 applicationReference );\n\n\tevent ReferenceConfirmed (\n\t\taddress indexed applicationAddress,\n\t\tuint256 indexed applicationReference, \n\t\taddress indexed confirmedBy, \n\t\tuint256 confirmerTokensMinimum );\n\n\tevent StartProvision (\n\t    address indexed applicationAddress, \n\t    uint32 indexed serviceId, \n\t    address indexed userAddress,\n\t    uint256 provisionId,\n\t    uint256 serviceCredits,\n\t    uint256 tokensPerCredit, \n\t    uint256 applicationReference );\n\n\tevent UpdateProvision (\n\t    address indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    uint256 creditsRemaining );\n\n\tevent CompleteProvision (\n\t    address indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    uint256 creditsOutstanding );\n\n\tevent SignalProvisionRefund (\n\t    address indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    uint256 tokenValue );\n\n\tevent TransferBecauseOf (\n\t\taddress indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    address from,\n\t    address to,\n\t    uint256 value );\n\n\tevent TransferBecauseOfAggregate (\n\t\taddress indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256[] provisionIds,\n\t    uint256[] tokenAmounts,\n\t    address from,\n\t    address to,\n\t    uint256 value );\n\n\n\tconstructor() public {\n\t\t//contract creator holds all tokens at creation\n\t\tbalances[msg.sender] = totalSupply_;\n\n\t\t//record contract owner for later reference (e.g. in ownerBurn)\n\t\tcontractOwner=msg.sender;\n\n\t\t//indicate all tokens were sent to contract address\n\t\temit Transfer(address(0), msg.sender, totalSupply_);\n\t}\n\n\tfunction listSimpleService ( \n\t\t\tuint32 _serviceId, \n\t\t\tstring _serviceDescription,\n\t\t\tuint256 _tokensRequired,\n\t\t\taddress _updateAddress,\n\t\t\taddress _receiptAddress\t) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//check service id is not 0\n\t\trequire(_serviceId != 0);\n\n\t\t//check service doesn't already exist for this application id\n\t\trequire(services[msg.sender][_serviceId].applicationAddress == 0);\n\n\t\t//check cost of the service is >0 \n\t\trequire(_tokensRequired != 0);\n\n\t\t//check receiptAddress is not address(0)\n\t\trequire(_receiptAddress != address(0));\n\n\t\t//update address should be address(0) or a non-sender address\n\t\trequire(_updateAddress != msg.sender);\n\n\t\t//add service to services mapping\n\t\tservices[msg.sender][_serviceId] = Service(\n\t\t\t\tmsg.sender,\n\t\t\t\t_serviceId,\n\t\t\t\ttrue,\n\t\t\t\t_serviceDescription,\n\t\t\t\t_tokensRequired,\n\t\t\t\t1,\n\t\t\t\t_updateAddress,\n\t\t\t\t_receiptAddress,\n\t\t\t\tfalse,\n\t\t\t\t0\n\t\t\t);\n\n\t\t//add service to servicesLists for application\n\t\tservicesLists[msg.sender].push(_serviceId);\n\n\t\t//emit NewService\n\t\temit NewService(msg.sender, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction listService ( \n\t\t\tuint32 _serviceId, \n\t\t\tstring _serviceDescription,\n\t\t\tuint256 _tokensPerCredit,\n\t\t\tuint256 _maxCreditsPerProvision,\n\t\t\taddress _updateAddress,\n\t\t\taddress _receiptAddress\t) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//check service id is not 0\n\t\trequire(_serviceId != 0);\n\n\t\t//check service doesn't already exist for this application id\n\t\trequire(services[msg.sender][_serviceId].applicationAddress == 0);\n\n\t\t//check cost of the service is >0 \n\t\trequire(_tokensPerCredit != 0);\n\n\t\t//check receiptAddress is not address(0)\n\t\trequire(_receiptAddress != address(0));\n\n\t\t//update address should be address(0) or a non-sender address\n\t\trequire(_updateAddress != msg.sender);\n\n\t\t//add service to services mapping\n\t\tservices[msg.sender][_serviceId] = Service(\n\t\t\t\tmsg.sender,\n\t\t\t\t_serviceId,\n\t\t\t\tfalse,\n\t\t\t\t_serviceDescription,\n\t\t\t\t_tokensPerCredit,\n\t\t\t\t_maxCreditsPerProvision,\n\t\t\t\t_updateAddress,\n\t\t\t\t_receiptAddress,\n\t\t\t\tfalse,\n\t\t\t\t0\n\t\t\t);\n\n\t\t//add service to servicesLists for application\n\t\tservicesLists[msg.sender].push(_serviceId);\n\n\t\t//emit NewService\n\t\temit NewService(msg.sender, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction getServicesForApplication ( \n\t\t\taddress _applicationAddress ) \n\t\tpublic view returns (\n\t\t\tuint32[] serviceIds ) {\n\n\t\treturn servicesLists[_applicationAddress];\n\t}\n\n\tfunction getRemovedServicesForApplication (\n\t\t\taddress _applicationAddress ) \n\t\tpublic view returns (\n\t\t\tuint32[] serviceIds ) {\n\n\t\treturn servicesRemovedLists[_applicationAddress];\n\t}\n\n\tfunction isServiceRemoved (\n\t\t\taddress _applicationAddress,\n\t\t\tuint32 _serviceId )\n\t\tpublic view returns (\n\t\t\tbool ) {\n\n\t\t//returns true if service has been removed\n\t\treturn services[_applicationAddress][_serviceId].isRemoved;\n\t}\n\n\tfunction getServiceInformation ( \n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId )\n\t\tpublic view returns (\n\t\t\tbool exists,\n\t\t\tbool isSimple,\n\t\t\tstring serviceDescription,\n\t\t\tuint256 tokensPerCredit,\n\t\t\tuint256 maxCreditsPerProvision,\n\t\t\taddress receiptAddress,\n\t\t\tbool isRemoved,\n\t\t\tuint256 provisionHead ) {\n\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//services with unset application address indicates an empty/unset struct in the mapping\n\t\tif(s.applicationAddress == 0) {\n\t\t\t//first return parameter indicates whether the service exists\n\t\t\texists=false;\n\t\t\treturn;\n\n\t\t} else {\n\t\t\texists=true;\n\t\t\tisSimple=s.isSimple;\n\t\t\t//note that the returned service description can't be read in solidity funtion call\n\t\t\tserviceDescription=s.serviceDescription;\n\t\t\ttokensPerCredit=s.tokensPerCredit;\n\t\t\tmaxCreditsPerProvision=s.maxCreditsPerProvision;\n\t\t\treceiptAddress=s.receiptAddress;\n\t\t\tisRemoved=s.isRemoved;\n\t\t\tprovisionHead=s.provisionHead;\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfunction getServiceUpdateAddress (\n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId ) \n\t\tpublic view returns (\n\t\t\taddress updateAddress ) {\n\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\treturn s.updateAddress;\n\t}\n\n\tfunction updateServiceDescription (\n\t\t\taddress _targetApplicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tstring _serviceDescription ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_targetApplicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\tservices[_targetApplicationAddress][_serviceId].serviceDescription=_serviceDescription;\n\t\t\n\t\temit ServiceChanged(_targetApplicationAddress, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction updateServiceTokensPerCredit (\n\t\t\taddress _targetApplicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tuint256 _tokensPerCredit ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_targetApplicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//check changed cost of the service is >0 \n\t\trequire(_tokensPerCredit != 0);\n\n\t\tservices[_targetApplicationAddress][_serviceId].tokensPerCredit=_tokensPerCredit;\n\t\t\n\t\temit ServiceChanged(_targetApplicationAddress, _serviceId);\n\n\t\treturn true;\t\t\n\t}\n\n\tfunction updateServiceMaxCreditsPerProvision (\n\t\t\taddress _targetApplicationAddress,\n\t\t\tuint32 _serviceId,\n\t\t\tuint256 _maxCreditsPerProvision )\n\t\tpublic returns (\n\t\t\tbool sucess ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_targetApplicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//note that credits per provision can be == 0 (no limit)\n\n\t\t//change max credits per provision for this service\n\t\tservices[_targetApplicationAddress][_serviceId].maxCreditsPerProvision=_maxCreditsPerProvision;\n\n\t\temit ServiceChanged(_targetApplicationAddress, _serviceId);\n\t\n\t\treturn true;\t\t\n\t}\n\n\tfunction changeServiceReceiptAddress(\n\t\t\tuint32 _serviceId, \n\t\t\taddress _receiptAddress ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//receipt address can only be changed by application address\n\n\t\t//check that service exists\n\t\trequire(services[msg.sender][_serviceId].applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[msg.sender][_serviceId].isRemoved == false);\n\n\t\t//check changed receiptAddress is not address(0)\n\t\trequire(_receiptAddress != address(0));\n\n\t\tservices[msg.sender][_serviceId].receiptAddress=_receiptAddress;\n\t\t\n\t\temit ServiceChanged(msg.sender, _serviceId);\n\n\t\treturn true;\t\t\n\t}\n\n\tfunction changeServiceUpdateAddress (\n\t\t\tuint32 _serviceId,\n\t\t\taddress _updateAddress )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//update address can only be changed by application address\n\n\t\t//check that service exists\n\t\trequire(services[msg.sender][_serviceId].applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[msg.sender][_serviceId].isRemoved == false);\n\n\t\t//note: update address can be address(0)\n\t\t//change the update address\n\t\tservices[msg.sender][_serviceId].updateAddress=_updateAddress;\n\n\t\temit ServiceChanged(msg.sender, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction removeService (\n\t\t\taddress _targetApplicationAddress, \n\t\t\tuint32 _serviceId ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//check that service exists\n\t\trequire(services[_targetApplicationAddress][_serviceId].applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( services[_targetApplicationAddress][_serviceId].updateAddress != address(0) \n\t\t\t   && msg.sender == services[_targetApplicationAddress][_serviceId].updateAddress \n\t\t\t  ));\n\n\t\t//check that service is not already removed\n\t\trequire(services[_targetApplicationAddress][_serviceId].isRemoved == false);\n\n\t\t//add to removed array\n\t\tservicesRemovedLists[_targetApplicationAddress].push(_serviceId);\n\n\t\t//change value of isRemoved to true\n\t\tservices[_targetApplicationAddress][_serviceId].isRemoved = true;\n\n\t\temit ServiceRemoved(_targetApplicationAddress, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction transferToSimpleService (\n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tuint256 _tokenValue, \n\t\t\tuint256 _applicationReference, \n\t\t\tuint256 _multiple ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//requested multiple must be >= 1\n\t\trequire(_multiple > 0);\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//service must exist\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[_applicationAddress][_serviceId].isRemoved == false);\n\n\t\t//check that service is a simple service\n\t\trequire(s.isSimple == true);\n\n\t\t//expected value is the token cost of the service multiplied by the requested multiple\n\t\tuint256 expectedValue=s.tokensPerCredit.mul(_multiple);\n\n\t\t//supplied token value must equal expected value\n\t\trequire(expectedValue == _tokenValue);\n\n\t\t//transfer the tokens -- this verifies the sender owns the tokens\n\t\ttransfer(s.receiptAddress, _tokenValue);\n\n\t\t//this starts and ends a simple provision at a single point in time \n\t\temit CompleteSimpleProvision(_applicationAddress, _serviceId, msg.sender, _multiple, _applicationReference);\n\n\t\treturn true;\n\t}\n\n\n\tfunction transferToService (\n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tuint256 _tokenValue, \n\t\t\tuint256 _credits,\n\t\t\tuint256 _applicationReference ) \n\t\tpublic returns (\n\t\t\tuint256 provisionId ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//service must exist\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[_applicationAddress][_serviceId].isRemoved == false);\n\n\t\t//check that service is not a simple service\n\t\trequire(s.isSimple == false);\n\n\t\t//verify: value == credits * tokens per credit\n\t\trequire(_tokenValue == (_credits.mul(s.tokensPerCredit)));\n\n\t\t//verify: max credits == 0 OR (value/tokens per credit) <= max credits per provision\n\t\trequire( s.maxCreditsPerProvision == 0 ||\n\t\t\t_credits <= s.maxCreditsPerProvision);\n\n\t\t//increment provision head and use as provision id\n\t\ts.provisionHead++;\n\t\tuint256 pid = s.provisionHead;\n\n\t\t//create provision in mapping\n\t\tprovisions[_applicationAddress][_serviceId][pid] = Provision (\n\t\t\t\ts.tokensPerCredit,\n\t\t\t\t_credits,\n\t\t\t\t_applicationReference,\n\t\t\t\tmsg.sender,\n\t\t\t\t_credits\t\t\n\t\t\t);\n\n\t\t//transfer the tokens\n\t\ttransfer(s.receiptAddress, _tokenValue);\n\n\t\t//emits a start provision \n\t\temit StartProvision(_applicationAddress, _serviceId, msg.sender, pid, _credits, s.tokensPerCredit, _applicationReference);\n\n\t\t//return provision id\n\t\treturn pid;\n\t}\n\n\tfunction getProvisionCreditsRemaining (\n\t\t\taddress _applicationAddress,\n\t\t\tuint32 _serviceId,\n\t\t    uint256 _provisionId )\n\t\tpublic view returns (\n\t\t\tuint256 credits) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//service must exist\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[_applicationAddress][_serviceId].isRemoved == false);\t\t\n\n\t\t//get & check that the provision exists (address at userAddress)\n\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\trequire(p.userAddress != 0);\n\n\t\t//return the credits remaining for this provision\n\t\treturn p.creditsRemaining;\n\t}\n\n\tfunction updateProvision (\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256 _provisionId,\n\t\t    uint256 _creditsRemaining )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//credits remaining must be >0, complete provision should be used to set to 0\n\t\trequire(_creditsRemaining > 0);\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _applicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//get & check that the provision exists (address at userAddress)\n\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\trequire(p.userAddress != 0);\n\n\t\t//update the credits remaining\n\t\tp.creditsRemaining=_creditsRemaining;\n\t\n\t\t//fires UpdateProvision\n\t\temit UpdateProvision(_applicationAddress, _serviceId, _provisionId, _creditsRemaining);\n\n\t\treturn true;\t\t\n\t}\n\n\tfunction completeProvision (\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256 _provisionId,\n\t\t    uint256 _creditsOutstanding )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _applicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//get & check that the provision exists (address at userAddress)\n\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\trequire(p.userAddress != 0);\n\n\t\tif(_creditsOutstanding > 0) {\n\t\t\t//can only signal refund total of credits originally provisioned\n\t\t\trequire(_creditsOutstanding <= p.creditsProvisioned);\n\n\t\t\temit SignalProvisionRefund(_applicationAddress, _serviceId, _provisionId, _creditsOutstanding.mul(p.tokensPerCredit));\n\t\t}\n\n\t\t//credits remaining on service is set to 0\n\t\tp.creditsRemaining=0;\n\n\t\t//fires CompleteProvision\n\t\temit CompleteProvision(_applicationAddress, _serviceId, _provisionId, _creditsOutstanding);\n\n\t\treturn true;\n\t}\n\n\n\tfunction confirmReference (\n\t\t\taddress _applicationAddress,\n\t\t\tuint256 _applicationReference,\n\t\t\tuint256 _senderTokensMinimum )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//sender must have some tokens - if 0 is passed to _senderTokensMinimum\n\t\t//then it is assumed that the method is checking that the sender has any amount\n\t\t//of tokens (>0)\n\t\trequire(balances[msg.sender] > 0);\n\n\t\t//sender must have min tokens if specified\n\t\trequire(_senderTokensMinimum == 0 \n\t\t\t|| balances[msg.sender] >= _senderTokensMinimum);\n\n\t\temit ReferenceConfirmed(_applicationAddress, _applicationReference, msg.sender, _senderTokensMinimum);\n\n\t\treturn true;\n\t}\n\n\n\tfunction transferBecauseOf (\n\t\t    address _to,\n\t\t    uint256 _value,\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256 _provisionId )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//provision ID can be optional, but if it's supplied it must exist\n\t\tif(_provisionId != 0) {\n\t\t\t//get & check that the provision exists (address at userAddress)\n\t\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\t\trequire(p.userAddress != 0);\n\t\t}\n\n\t\t//do the transfer\n\t\ttransfer(_to, _value);\n\n\t\temit TransferBecauseOf(_applicationAddress, _serviceId, _provisionId, msg.sender, _to, _value);\n\n\t\treturn true;\n\t}\n\n\n\tfunction transferBecauseOfAggregate (\n\t\t    address _to,\n\t\t    uint256 _value,\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256[] _provisionIds,\n\t\t    uint256[] _tokenAmounts )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//do the transfer\n\t\ttransfer(_to, _value);\n\n\t\temit TransferBecauseOfAggregate(_applicationAddress, _serviceId, _provisionIds, _tokenAmounts, msg.sender, _to, _value);\n\n\t\treturn true;\n\t}\n\n\tfunction ownerBurn ( \n\t\t\tuint256 _value )\n\t\tpublic returns (\n\t\t\tbool success) {\n\n\t\t//only the contract owner can burn tokens\n\t\trequire(msg.sender == contractOwner);\n\n\t\t//can only burn tokens held by the owner\n\t\trequire(_value <= balances[contractOwner]);\n\n\t\t//total supply of tokens is decremented when burned\n\t\ttotalSupply_ = totalSupply_.sub(_value);\n\n\t\t//balance of the contract owner is reduced (the contract owner's tokens are burned)\n\t\tbalances[contractOwner] = balances[contractOwner].sub(_value);\n\n\t\t//burning tokens emits a transfer to 0, as well as TokensBurned\n\t\temit Transfer(contractOwner, address(0), _value);\n\t\temit TokensBurned(contractOwner, _value);\n\n\t\treturn true;\n\n\t}\n\t\n\t\n\tfunction totalSupply ( ) public view returns (\n\t\tuint256 ) {\n\n\t\treturn totalSupply_;\n\t}\n\n\tfunction balanceOf (\n\t\t\taddress _owner ) \n\t\tpublic view returns (\n\t\t\tuint256 ) {\n\n\t\treturn balances[_owner];\n\t}\n\n\tfunction transfer (\n\t\t\taddress _to, \n\t\t\tuint256 _value ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[msg.sender]);\n\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n   \t//changing approval with this method has the same underlying issue as https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   \t//in that transaction order can be modified in a block to spend, change approval, spend again\n   \t//the method is kept for ERC-20 compatibility, but a set to zero, set again or use of the below increase/decrease should be used instead\n\tfunction approve (\n\t\t\taddress _spender, \n\t\t\tuint256 _value ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\tallowed[msg.sender][_spender] = _value;\n\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\tfunction increaseApproval (\n\t\t\taddress _spender, \n\t\t\tuint256 _addedValue ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\tfunction decreaseApproval (\n\t\t\taddress _spender,\n\t\t\tuint256 _subtractedValue ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\tuint256 oldValue = allowed[msg.sender][_spender];\n\n\t\tif (_subtractedValue > oldValue) {\n\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t} else {\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\t\t}\n\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\tfunction allowance (\n\t\t\taddress _owner, \n\t\t\taddress _spender ) \n\t\tpublic view returns (\n\t\t\tuint256 remaining ) {\n\n\t\treturn allowed[_owner][_spender];\n\t}\n\n\tfunction transferFrom (\n\t\t\taddress _from, \n\t\t\taddress _to, \n\t\t\tuint256 _value ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[_from]);\n\t\trequire(_value <= allowed[_from][msg.sender]);\n\n\t\tbalances[_from] = balances[_from].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n}",
        "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_U42_4 + calldata_U42_32 + 4)) +\n96: 0x9ffbffffffffd99db48e28ffffffffffffffffffffffffffffffffffffffffe8\nkeccac_1_+\nkeccac_4294967295_&_4294967295_&_4294967295_&_calldata_U42_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_U42_4 + calldata_U42_32 + 4)) +\n96: 0x2021fda91bfffffffffffffffffffffffffffffffffffffffff8\ncaller: 0x0\ncalldata_U42_32 + 100: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_U42_32 + 132: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_U42_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0 +\nkeccac_4294967295_&_4294967295_&_4294967295_&_calldata_U42_4: 0x0\ncalldata_U42_4: 0xffffffff\ncalldata_U42_0: 0x16a7859b00000000000000000000000000000000000000000000000000000000\ncalldatasize_U42: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x16a7859b`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/10/0x1f988b4ee752826e834f478b7668725ae7ecf53c.sol",
        "function": "_function_0x16a7859b",
        "lineno": 61,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 22104,
        "code": "s\n\tusing SafeMath for uint256;\n\n\tstring public constant name = \"U42\";\n\tstring public constant symbol = \"U42\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant initialSupply = 525000000 * (10 ** uint256(decimals));\n\tuint256 internal totalSupply_ = initialSupply;\n\taddress public contractOwner;\n\n\t//token balances\n\tmapping(address => uint256) balances;\n\n\t//for each balance address, map allowed addresses to amount allowed\n\tmapping (address => mapping (address => uint256)) internal allowed;\n\n\t//each service is represented by a Service struct \n\tstruct Service {\n\t\taddress applicationAddress;\n\t\tuint32 serviceId;\n\t\tbool isSimple;\n\t\tstring serviceDescription;\n\t\tuint256 tokensPerCredit;\n\t\tuint256 maxCreditsPerProvision;\n\t\taddress updateAddress;\n\t\taddress receiptAddress;\n\t\tbool isRemoved;\n\t\tuint256 provisionHead;\n\t}\n\n\tstruct Provision {\n\t\tuint256 tokensPerCredit;\n\t\tuint256 creditsRemaining;\n\t\tuint256 applicationReference;\n\t\taddress userAddress;\n\t\tuint256 creditsProvisioned;\n\t}\n\n\t//mapping of application addresses to service structs\n\tmapping (address => mapping (uint32 => Service)) services;\n\n\t//mapping of application addresses to service structs to provisions\n\tmapping (address => mapping (uint32 => mapping (uint256 => Provision))) provisions;\n\n\t//mapping of application addresses to lists of services\n\tmapping (address => uint32[]) servicesLists;\n\n\t//mapping of application addresses to lists of removed services\n\tmapping (address => uint32[]) servicesRemovedLists;\n\n\t//methods emit the following events\n\tevent Transfer (\n\t\taddress indexed from, \n\t\taddress indexed to, \n\t\tuint256 value );\n\n\tevent TokensBurned (\n\t\taddress indexed burner, \n\t\tuint256 value );\n\n\tevent Approval (\n\t\taddress indexed owner,\n\t\taddress indexed spender,\n\t\tuint256 value );\n\n\tevent NewService (\n\t\taddress indexed applicationAddress,\n\t\tuint32 serviceId );\n\n\tevent ServiceChanged (\n\t\taddress indexed applicationAddress,\n\t\tuint32 serviceId );\n\n\tevent ServiceRemoved (\n\t\taddress indexed applicationAddress,\n\t\tuint32 serviceId );\n\n\tevent CompleteSimpleProvision (\n\t\taddress indexed applicationAddress,\n\t\tuint32 indexed serviceId,\n\t\taddress indexed userAddress,\n\t\tuint256 multiple,\n\t\tuint256 applicationReference );\n\n\tevent ReferenceConfirmed (\n\t\taddress indexed applicationAddress,\n\t\tuint256 indexed applicationReference, \n\t\taddress indexed confirmedBy, \n\t\tuint256 confirmerTokensMinimum );\n\n\tevent StartProvision (\n\t    address indexed applicationAddress, \n\t    uint32 indexed serviceId, \n\t    address indexed userAddress,\n\t    uint256 provisionId,\n\t    uint256 serviceCredits,\n\t    uint256 tokensPerCredit, \n\t    uint256 applicationReference );\n\n\tevent UpdateProvision (\n\t    address indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    uint256 creditsRemaining );\n\n\tevent CompleteProvision (\n\t    address indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    uint256 creditsOutstanding );\n\n\tevent SignalProvisionRefund (\n\t    address indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    uint256 tokenValue );\n\n\tevent TransferBecauseOf (\n\t\taddress indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    address from,\n\t    address to,\n\t    uint256 value );\n\n\tevent TransferBecauseOfAggregate (\n\t\taddress indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256[] provisionIds,\n\t    uint256[] tokenAmounts,\n\t    address from,\n\t    address to,\n\t    uint256 value );\n\n\n\tconstructor() public {\n\t\t//contract creator holds all tokens at creation\n\t\tbalances[msg.sender] = totalSupply_;\n\n\t\t//record contract owner for later reference (e.g. in ownerBurn)\n\t\tcontractOwner=msg.sender;\n\n\t\t//indicate all tokens were sent to contract address\n\t\temit Transfer(address(0), msg.sender, totalSupply_);\n\t}\n\n\tfunction listSimpleService ( \n\t\t\tuint32 _serviceId, \n\t\t\tstring _serviceDescription,\n\t\t\tuint256 _tokensRequired,\n\t\t\taddress _updateAddress,\n\t\t\taddress _receiptAddress\t) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//check service id is not 0\n\t\trequire(_serviceId != 0);\n\n\t\t//check service doesn't already exist for this application id\n\t\trequire(services[msg.sender][_serviceId].applicationAddress == 0);\n\n\t\t//check cost of the service is >0 \n\t\trequire(_tokensRequired != 0);\n\n\t\t//check receiptAddress is not address(0)\n\t\trequire(_receiptAddress != address(0));\n\n\t\t//update address should be address(0) or a non-sender address\n\t\trequire(_updateAddress != msg.sender);\n\n\t\t//add service to services mapping\n\t\tservices[msg.sender][_serviceId] = Service(\n\t\t\t\tmsg.sender,\n\t\t\t\t_serviceId,\n\t\t\t\ttrue,\n\t\t\t\t_serviceDescription,\n\t\t\t\t_tokensRequired,\n\t\t\t\t1,\n\t\t\t\t_updateAddress,\n\t\t\t\t_receiptAddress,\n\t\t\t\tfalse,\n\t\t\t\t0\n\t\t\t);\n\n\t\t//add service to servicesLists for application\n\t\tservicesLists[msg.sender].push(_serviceId);\n\n\t\t//emit NewService\n\t\temit NewService(msg.sender, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction listService ( \n\t\t\tuint32 _serviceId, \n\t\t\tstring _serviceDescription,\n\t\t\tuint256 _tokensPerCredit,\n\t\t\tuint256 _maxCreditsPerProvision,\n\t\t\taddress _updateAddress,\n\t\t\taddress _receiptAddress\t) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//check service id is not 0\n\t\trequire(_serviceId != 0);\n\n\t\t//check service doesn't already exist for this application id\n\t\trequire(services[msg.sender][_serviceId].applicationAddress == 0);\n\n\t\t//check cost of the service is >0 \n\t\trequire(_tokensPerCredit != 0);\n\n\t\t//check receiptAddress is not address(0)\n\t\trequire(_receiptAddress != address(0));\n\n\t\t//update address should be address(0) or a non-sender address\n\t\trequire(_updateAddress != msg.sender);\n\n\t\t//add service to services mapping\n\t\tservices[msg.sender][_serviceId] = Service(\n\t\t\t\tmsg.sender,\n\t\t\t\t_serviceId,\n\t\t\t\tfalse,\n\t\t\t\t_serviceDescription,\n\t\t\t\t_tokensPerCredit,\n\t\t\t\t_maxCreditsPerProvision,\n\t\t\t\t_updateAddress,\n\t\t\t\t_receiptAddress,\n\t\t\t\tfalse,\n\t\t\t\t0\n\t\t\t);\n\n\t\t//add service to servicesLists for application\n\t\tservicesLists[msg.sender].push(_serviceId);\n\n\t\t//emit NewService\n\t\temit NewService(msg.sender, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction getServicesForApplication ( \n\t\t\taddress _applicationAddress ) \n\t\tpublic view returns (\n\t\t\tuint32[] serviceIds ) {\n\n\t\treturn servicesLists[_applicationAddress];\n\t}\n\n\tfunction getRemovedServicesForApplication (\n\t\t\taddress _applicationAddress ) \n\t\tpublic view returns (\n\t\t\tuint32[] serviceIds ) {\n\n\t\treturn servicesRemovedLists[_applicationAddress];\n\t}\n\n\tfunction isServiceRemoved (\n\t\t\taddress _applicationAddress,\n\t\t\tuint32 _serviceId )\n\t\tpublic view returns (\n\t\t\tbool ) {\n\n\t\t//returns true if service has been removed\n\t\treturn services[_applicationAddress][_serviceId].isRemoved;\n\t}\n\n\tfunction getServiceInformation ( \n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId )\n\t\tpublic view returns (\n\t\t\tbool exists,\n\t\t\tbool isSimple,\n\t\t\tstring serviceDescription,\n\t\t\tuint256 tokensPerCredit,\n\t\t\tuint256 maxCreditsPerProvision,\n\t\t\taddress receiptAddress,\n\t\t\tbool isRemoved,\n\t\t\tuint256 provisionHead ) {\n\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//services with unset application address indicates an empty/unset struct in the mapping\n\t\tif(s.applicationAddress == 0) {\n\t\t\t//first return parameter indicates whether the service exists\n\t\t\texists=false;\n\t\t\treturn;\n\n\t\t} else {\n\t\t\texists=true;\n\t\t\tisSimple=s.isSimple;\n\t\t\t//note that the returned service description can't be read in solidity funtion call\n\t\t\tserviceDescription=s.serviceDescription;\n\t\t\ttokensPerCredit=s.tokensPerCredit;\n\t\t\tmaxCreditsPerProvision=s.maxCreditsPerProvision;\n\t\t\treceiptAddress=s.receiptAddress;\n\t\t\tisRemoved=s.isRemoved;\n\t\t\tprovisionHead=s.provisionHead;\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfunction getServiceUpdateAddress (\n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId ) \n\t\tpublic view returns (\n\t\t\taddress updateAddress ) {\n\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\treturn s.updateAddress;\n\t}\n\n\tfunction updateServiceDescription (\n\t\t\taddress _targetApplicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tstring _serviceDescription ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_targetApplicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\tservices[_targetApplicationAddress][_serviceId].serviceDescription=_serviceDescription;\n\t\t\n\t\temit ServiceChanged(_targetApplicationAddress, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction updateServiceTokensPerCredit (\n\t\t\taddress _targetApplicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tuint256 _tokensPerCredit ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_targetApplicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//check changed cost of the service is >0 \n\t\trequire(_tokensPerCredit != 0);\n\n\t\tservices[_targetApplicationAddress][_serviceId].tokensPerCredit=_tokensPerCredit;\n\t\t\n\t\temit ServiceChanged(_targetApplicationAddress, _serviceId);\n\n\t\treturn true;\t\t\n\t}\n\n\tfunction updateServiceMaxCreditsPerProvision (\n\t\t\taddress _targetApplicationAddress,\n\t\t\tuint32 _serviceId,\n\t\t\tuint256 _maxCreditsPerProvision )\n\t\tpublic returns (\n\t\t\tbool sucess ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_targetApplicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//note that credits per provision can be == 0 (no limit)\n\n\t\t//change max credits per provision for this service\n\t\tservices[_targetApplicationAddress][_serviceId].maxCreditsPerProvision=_maxCreditsPerProvision;\n\n\t\temit ServiceChanged(_targetApplicationAddress, _serviceId);\n\t\n\t\treturn true;\t\t\n\t}\n\n\tfunction changeServiceReceiptAddress(\n\t\t\tuint32 _serviceId, \n\t\t\taddress _receiptAddress ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//receipt address can only be changed by application address\n\n\t\t//check that service exists\n\t\trequire(services[msg.sender][_serviceId].applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[msg.sender][_serviceId].isRemoved == false);\n\n\t\t//check changed receiptAddress is not address(0)\n\t\trequire(_receiptAddress != address(0));\n\n\t\tservices[msg.sender][_serviceId].receiptAddress=_receiptAddress;\n\t\t\n\t\temit ServiceChanged(msg.sender, _serviceId);\n\n\t\treturn true;\t\t\n\t}\n\n\tfunction changeServiceUpdateAddress (\n\t\t\tuint32 _serviceId,\n\t\t\taddress _updateAddress )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//update address can only be changed by application address\n\n\t\t//check that service exists\n\t\trequire(services[msg.sender][_serviceId].applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[msg.sender][_serviceId].isRemoved == false);\n\n\t\t//note: update address can be address(0)\n\t\t//change the update address\n\t\tservices[msg.sender][_serviceId].updateAddress=_updateAddress;\n\n\t\temit ServiceChanged(msg.sender, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction removeService (\n\t\t\taddress _targetApplicationAddress, \n\t\t\tuint32 _serviceId ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//check that service exists\n\t\trequire(services[_targetApplicationAddress][_serviceId].applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( services[_targetApplicationAddress][_serviceId].updateAddress != address(0) \n\t\t\t   && msg.sender == services[_targetApplicationAddress][_serviceId].updateAddress \n\t\t\t  ));\n\n\t\t//check that service is not already removed\n\t\trequire(services[_targetApplicationAddress][_serviceId].isRemoved == false);\n\n\t\t//add to removed array\n\t\tservicesRemovedLists[_targetApplicationAddress].push(_serviceId);\n\n\t\t//change value of isRemoved to true\n\t\tservices[_targetApplicationAddress][_serviceId].isRemoved = true;\n\n\t\temit ServiceRemoved(_targetApplicationAddress, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction transferToSimpleService (\n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tuint256 _tokenValue, \n\t\t\tuint256 _applicationReference, \n\t\t\tuint256 _multiple ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//requested multiple must be >= 1\n\t\trequire(_multiple > 0);\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//service must exist\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[_applicationAddress][_serviceId].isRemoved == false);\n\n\t\t//check that service is a simple service\n\t\trequire(s.isSimple == true);\n\n\t\t//expected value is the token cost of the service multiplied by the requested multiple\n\t\tuint256 expectedValue=s.tokensPerCredit.mul(_multiple);\n\n\t\t//supplied token value must equal expected value\n\t\trequire(expectedValue == _tokenValue);\n\n\t\t//transfer the tokens -- this verifies the sender owns the tokens\n\t\ttransfer(s.receiptAddress, _tokenValue);\n\n\t\t//this starts and ends a simple provision at a single point in time \n\t\temit CompleteSimpleProvision(_applicationAddress, _serviceId, msg.sender, _multiple, _applicationReference);\n\n\t\treturn true;\n\t}\n\n\n\tfunction transferToService (\n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tuint256 _tokenValue, \n\t\t\tuint256 _credits,\n\t\t\tuint256 _applicationReference ) \n\t\tpublic returns (\n\t\t\tuint256 provisionId ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//service must exist\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[_applicationAddress][_serviceId].isRemoved == false);\n\n\t\t//check that service is not a simple service\n\t\trequire(s.isSimple == false);\n\n\t\t//verify: value == credits * tokens per credit\n\t\trequire(_tokenValue == (_credits.mul(s.tokensPerCredit)));\n\n\t\t//verify: max credits == 0 OR (value/tokens per credit) <= max credits per provision\n\t\trequire( s.maxCreditsPerProvision == 0 ||\n\t\t\t_credits <= s.maxCreditsPerProvision);\n\n\t\t//increment provision head and use as provision id\n\t\ts.provisionHead++;\n\t\tuint256 pid = s.provisionHead;\n\n\t\t//create provision in mapping\n\t\tprovisions[_applicationAddress][_serviceId][pid] = Provision (\n\t\t\t\ts.tokensPerCredit,\n\t\t\t\t_credits,\n\t\t\t\t_applicationReference,\n\t\t\t\tmsg.sender,\n\t\t\t\t_credits\t\t\n\t\t\t);\n\n\t\t//transfer the tokens\n\t\ttransfer(s.receiptAddress, _tokenValue);\n\n\t\t//emits a start provision \n\t\temit StartProvision(_applicationAddress, _serviceId, msg.sender, pid, _credits, s.tokensPerCredit, _applicationReference);\n\n\t\t//return provision id\n\t\treturn pid;\n\t}\n\n\tfunction getProvisionCreditsRemaining (\n\t\t\taddress _applicationAddress,\n\t\t\tuint32 _serviceId,\n\t\t    uint256 _provisionId )\n\t\tpublic view returns (\n\t\t\tuint256 credits) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//service must exist\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[_applicationAddress][_serviceId].isRemoved == false);\t\t\n\n\t\t//get & check that the provision exists (address at userAddress)\n\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\trequire(p.userAddress != 0);\n\n\t\t//return the credits remaining for this provision\n\t\treturn p.creditsRemaining;\n\t}\n\n\tfunction updateProvision (\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256 _provisionId,\n\t\t    uint256 _creditsRemaining )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//credits remaining must be >0, complete provision should be used to set to 0\n\t\trequire(_creditsRemaining > 0);\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _applicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//get & check that the provision exists (address at userAddress)\n\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\trequire(p.userAddress != 0);\n\n\t\t//update the credits remaining\n\t\tp.creditsRemaining=_creditsRemaining;\n\t\n\t\t//fires UpdateProvision\n\t\temit UpdateProvision(_applicationAddress, _serviceId, _provisionId, _creditsRemaining);\n\n\t\treturn true;\t\t\n\t}\n\n\tfunction completeProvision (\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256 _provisionId,\n\t\t    uint256 _creditsOutstanding )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _applicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//get & check that the provision exists (address at userAddress)\n\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\trequire(p.userAddress != 0);\n\n\t\tif(_creditsOutstanding > 0) {\n\t\t\t//can only signal refund total of credits originally provisioned\n\t\t\trequire(_creditsOutstanding <= p.creditsProvisioned);\n\n\t\t\temit SignalProvisionRefund(_applicationAddress, _serviceId, _provisionId, _creditsOutstanding.mul(p.tokensPerCredit));\n\t\t}\n\n\t\t//credits remaining on service is set to 0\n\t\tp.creditsRemaining=0;\n\n\t\t//fires CompleteProvision\n\t\temit CompleteProvision(_applicationAddress, _serviceId, _provisionId, _creditsOutstanding);\n\n\t\treturn true;\n\t}\n\n\n\tfunction confirmReference (\n\t\t\taddress _applicationAddress,\n\t\t\tuint256 _applicationReference,\n\t\t\tuint256 _senderTokensMinimum )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//sender must have some tokens - if 0 is passed to _senderTokensMinimum\n\t\t//then it is assumed that the method is checking that the sender has any amount\n\t\t//of tokens (>0)\n\t\trequire(balances[msg.sender] > 0);\n\n\t\t//sender must have min tokens if specified\n\t\trequire(_senderTokensMinimum == 0 \n\t\t\t|| balances[msg.sender] >= _senderTokensMinimum);\n\n\t\temit ReferenceConfirmed(_applicationAddress, _applicationReference, msg.sender, _senderTokensMinimum);\n\n\t\treturn true;\n\t}\n\n\n\tfunction transferBecauseOf (\n\t\t    address _to,\n\t\t    uint256 _value,\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256 _provisionId )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//provision ID can be optional, but if it's supplied it must exist\n\t\tif(_provisionId != 0) {\n\t\t\t//get & check that the provision exists (address at userAddress)\n\t\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\t\trequire(p.userAddress != 0);\n\t\t}\n\n\t\t//do the transfer\n\t\ttransfer(_to, _value);\n\n\t\temit TransferBecauseOf(_applicationAddress, _serviceId, _provisionId, msg.sender, _to, _value);\n\n\t\treturn true;\n\t}\n\n\n\tfunction transferBecauseOfAggregate (\n\t\t    address _to,\n\t\t    uint256 _value,\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256[] _provisionIds,\n\t\t    uint256[] _tokenAmounts )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//do the transfer\n\t\ttransfer(_to, _value);\n\n\t\temit TransferBecauseOfAggregate(_applicationAddress, _serviceId, _provisionIds, _tokenAmounts, msg.sender, _to, _value);\n\n\t\treturn true;\n\t}\n\n\tfunction ownerBurn ( \n\t\t\tuint256 _value )\n\t\tpublic returns (\n\t\t\tbool success) {\n\n\t\t//only the contract owner can burn tokens\n\t\trequire(msg.sender == contractOwner);\n\n\t\t//can only burn tokens held by the owner\n\t\trequire(_value <= balances[contractOwner]);\n\n\t\t//total supply of tokens is decremented when burned\n\t\ttotalSupply_ = totalSupply_.sub(_value);\n\n\t\t//balance of the contract owner is reduced (the contract owner's tokens are burned)\n\t\tbalances[contractOwner] = balances[contractOwner].sub(_value);\n\n\t\t//burning tokens emits a transfer to 0, as well as TokensBurned\n\t\temit Transfer(contractOwner, address(0), _value);\n\t\temit TokensBurned(contractOwner, _value);\n\n\t\treturn true;\n\n\t}\n\t\n\t\n\tfunction totalSupply ( ) public view returns (\n\t\tuint256 ) {\n\n\t\treturn totalSupply_;\n\t}\n\n\tfunction balanceOf (\n\t\t\taddress _owner ) \n\t\tpublic view returns (\n\t\t\tuint256 ) {\n\n\t\treturn balances[_owner];\n\t}\n\n\tfunction transfer (\n\t\t\taddress _to, \n\t\t\tuint256 _value ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[msg.sender]);\n\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n   \t//changing approval with this method has the same underlying issue as https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   \t//in that transaction order can be modified in a block to spend, change approval, spend again\n   \t//the method is kept for ERC-20 compatibility, but a set to zero, set again or use of the below increase/decrease should be used instead\n\tfunction approve (\n\t\t\taddress _spender, \n\t\t\tuint256 _value ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\tallowed[msg.sender][_spender] = _value;\n\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\tfunction increaseApproval (\n\t\t\taddress _spender, \n\t\t\tuint256 _addedValue ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\tfunction decreaseApproval (\n\t\t\taddress _spender,\n\t\t\tuint256 _subtractedValue ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\tuint256 oldValue = allowed[msg.sender][_spender];\n\n\t\tif (_subtractedValue > oldValue) {\n\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t} else {\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\t\t}\n\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\tfunction allowance (\n\t\t\taddress _owner, \n\t\t\taddress _spender ) \n\t\tpublic view returns (\n\t\t\tuint256 remaining ) {\n\n\t\treturn allowed[_owner][_spender];\n\t}\n\n\tfunction transferFrom (\n\t\t\taddress _from, \n\t\t\taddress _to, \n\t\t\tuint256 _value ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[_from]);\n\t\trequire(_value <= allowed[_from][msg.sender]);\n\n\t\tbalances[_from] = balances[_from].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n}",
        "debug": "storage_1 +\nkeccac_4294967295_&_4294967295_&_4294967295_&_calldata_U42_32_+_4: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nkeccac_1_+\nkeccac_4294967295_&_4294967295_&_4294967295_&_calldata_U42_32_+_4: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_5 +\nkeccac_4294967295_&_4294967295_&_4294967295_&_calldata_U42_32_+_4: 0x0\ncalldata_U42_4: 0x0\ncaller: 0x0\nstorage_0 +\nkeccac_4294967295_&_4294967295_&_4294967295_&_calldata_U42_32_+_4: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_U42_0: 0x274fadf600000000000000000000000000000000000000000000000000000000\ncalldatasize_U42: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x274fadf6`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/10/0x1f988b4ee752826e834f478b7668725ae7ecf53c.sol",
        "function": "_function_0x274fadf6",
        "lineno": 61,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 22133,
        "code": "s\n\tusing SafeMath for uint256;\n\n\tstring public constant name = \"U42\";\n\tstring public constant symbol = \"U42\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant initialSupply = 525000000 * (10 ** uint256(decimals));\n\tuint256 internal totalSupply_ = initialSupply;\n\taddress public contractOwner;\n\n\t//token balances\n\tmapping(address => uint256) balances;\n\n\t//for each balance address, map allowed addresses to amount allowed\n\tmapping (address => mapping (address => uint256)) internal allowed;\n\n\t//each service is represented by a Service struct \n\tstruct Service {\n\t\taddress applicationAddress;\n\t\tuint32 serviceId;\n\t\tbool isSimple;\n\t\tstring serviceDescription;\n\t\tuint256 tokensPerCredit;\n\t\tuint256 maxCreditsPerProvision;\n\t\taddress updateAddress;\n\t\taddress receiptAddress;\n\t\tbool isRemoved;\n\t\tuint256 provisionHead;\n\t}\n\n\tstruct Provision {\n\t\tuint256 tokensPerCredit;\n\t\tuint256 creditsRemaining;\n\t\tuint256 applicationReference;\n\t\taddress userAddress;\n\t\tuint256 creditsProvisioned;\n\t}\n\n\t//mapping of application addresses to service structs\n\tmapping (address => mapping (uint32 => Service)) services;\n\n\t//mapping of application addresses to service structs to provisions\n\tmapping (address => mapping (uint32 => mapping (uint256 => Provision))) provisions;\n\n\t//mapping of application addresses to lists of services\n\tmapping (address => uint32[]) servicesLists;\n\n\t//mapping of application addresses to lists of removed services\n\tmapping (address => uint32[]) servicesRemovedLists;\n\n\t//methods emit the following events\n\tevent Transfer (\n\t\taddress indexed from, \n\t\taddress indexed to, \n\t\tuint256 value );\n\n\tevent TokensBurned (\n\t\taddress indexed burner, \n\t\tuint256 value );\n\n\tevent Approval (\n\t\taddress indexed owner,\n\t\taddress indexed spender,\n\t\tuint256 value );\n\n\tevent NewService (\n\t\taddress indexed applicationAddress,\n\t\tuint32 serviceId );\n\n\tevent ServiceChanged (\n\t\taddress indexed applicationAddress,\n\t\tuint32 serviceId );\n\n\tevent ServiceRemoved (\n\t\taddress indexed applicationAddress,\n\t\tuint32 serviceId );\n\n\tevent CompleteSimpleProvision (\n\t\taddress indexed applicationAddress,\n\t\tuint32 indexed serviceId,\n\t\taddress indexed userAddress,\n\t\tuint256 multiple,\n\t\tuint256 applicationReference );\n\n\tevent ReferenceConfirmed (\n\t\taddress indexed applicationAddress,\n\t\tuint256 indexed applicationReference, \n\t\taddress indexed confirmedBy, \n\t\tuint256 confirmerTokensMinimum );\n\n\tevent StartProvision (\n\t    address indexed applicationAddress, \n\t    uint32 indexed serviceId, \n\t    address indexed userAddress,\n\t    uint256 provisionId,\n\t    uint256 serviceCredits,\n\t    uint256 tokensPerCredit, \n\t    uint256 applicationReference );\n\n\tevent UpdateProvision (\n\t    address indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    uint256 creditsRemaining );\n\n\tevent CompleteProvision (\n\t    address indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    uint256 creditsOutstanding );\n\n\tevent SignalProvisionRefund (\n\t    address indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    uint256 tokenValue );\n\n\tevent TransferBecauseOf (\n\t\taddress indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    address from,\n\t    address to,\n\t    uint256 value );\n\n\tevent TransferBecauseOfAggregate (\n\t\taddress indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256[] provisionIds,\n\t    uint256[] tokenAmounts,\n\t    address from,\n\t    address to,\n\t    uint256 value );\n\n\n\tconstructor() public {\n\t\t//contract creator holds all tokens at creation\n\t\tbalances[msg.sender] = totalSupply_;\n\n\t\t//record contract owner for later reference (e.g. in ownerBurn)\n\t\tcontractOwner=msg.sender;\n\n\t\t//indicate all tokens were sent to contract address\n\t\temit Transfer(address(0), msg.sender, totalSupply_);\n\t}\n\n\tfunction listSimpleService ( \n\t\t\tuint32 _serviceId, \n\t\t\tstring _serviceDescription,\n\t\t\tuint256 _tokensRequired,\n\t\t\taddress _updateAddress,\n\t\t\taddress _receiptAddress\t) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//check service id is not 0\n\t\trequire(_serviceId != 0);\n\n\t\t//check service doesn't already exist for this application id\n\t\trequire(services[msg.sender][_serviceId].applicationAddress == 0);\n\n\t\t//check cost of the service is >0 \n\t\trequire(_tokensRequired != 0);\n\n\t\t//check receiptAddress is not address(0)\n\t\trequire(_receiptAddress != address(0));\n\n\t\t//update address should be address(0) or a non-sender address\n\t\trequire(_updateAddress != msg.sender);\n\n\t\t//add service to services mapping\n\t\tservices[msg.sender][_serviceId] = Service(\n\t\t\t\tmsg.sender,\n\t\t\t\t_serviceId,\n\t\t\t\ttrue,\n\t\t\t\t_serviceDescription,\n\t\t\t\t_tokensRequired,\n\t\t\t\t1,\n\t\t\t\t_updateAddress,\n\t\t\t\t_receiptAddress,\n\t\t\t\tfalse,\n\t\t\t\t0\n\t\t\t);\n\n\t\t//add service to servicesLists for application\n\t\tservicesLists[msg.sender].push(_serviceId);\n\n\t\t//emit NewService\n\t\temit NewService(msg.sender, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction listService ( \n\t\t\tuint32 _serviceId, \n\t\t\tstring _serviceDescription,\n\t\t\tuint256 _tokensPerCredit,\n\t\t\tuint256 _maxCreditsPerProvision,\n\t\t\taddress _updateAddress,\n\t\t\taddress _receiptAddress\t) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//check service id is not 0\n\t\trequire(_serviceId != 0);\n\n\t\t//check service doesn't already exist for this application id\n\t\trequire(services[msg.sender][_serviceId].applicationAddress == 0);\n\n\t\t//check cost of the service is >0 \n\t\trequire(_tokensPerCredit != 0);\n\n\t\t//check receiptAddress is not address(0)\n\t\trequire(_receiptAddress != address(0));\n\n\t\t//update address should be address(0) or a non-sender address\n\t\trequire(_updateAddress != msg.sender);\n\n\t\t//add service to services mapping\n\t\tservices[msg.sender][_serviceId] = Service(\n\t\t\t\tmsg.sender,\n\t\t\t\t_serviceId,\n\t\t\t\tfalse,\n\t\t\t\t_serviceDescription,\n\t\t\t\t_tokensPerCredit,\n\t\t\t\t_maxCreditsPerProvision,\n\t\t\t\t_updateAddress,\n\t\t\t\t_receiptAddress,\n\t\t\t\tfalse,\n\t\t\t\t0\n\t\t\t);\n\n\t\t//add service to servicesLists for application\n\t\tservicesLists[msg.sender].push(_serviceId);\n\n\t\t//emit NewService\n\t\temit NewService(msg.sender, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction getServicesForApplication ( \n\t\t\taddress _applicationAddress ) \n\t\tpublic view returns (\n\t\t\tuint32[] serviceIds ) {\n\n\t\treturn servicesLists[_applicationAddress];\n\t}\n\n\tfunction getRemovedServicesForApplication (\n\t\t\taddress _applicationAddress ) \n\t\tpublic view returns (\n\t\t\tuint32[] serviceIds ) {\n\n\t\treturn servicesRemovedLists[_applicationAddress];\n\t}\n\n\tfunction isServiceRemoved (\n\t\t\taddress _applicationAddress,\n\t\t\tuint32 _serviceId )\n\t\tpublic view returns (\n\t\t\tbool ) {\n\n\t\t//returns true if service has been removed\n\t\treturn services[_applicationAddress][_serviceId].isRemoved;\n\t}\n\n\tfunction getServiceInformation ( \n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId )\n\t\tpublic view returns (\n\t\t\tbool exists,\n\t\t\tbool isSimple,\n\t\t\tstring serviceDescription,\n\t\t\tuint256 tokensPerCredit,\n\t\t\tuint256 maxCreditsPerProvision,\n\t\t\taddress receiptAddress,\n\t\t\tbool isRemoved,\n\t\t\tuint256 provisionHead ) {\n\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//services with unset application address indicates an empty/unset struct in the mapping\n\t\tif(s.applicationAddress == 0) {\n\t\t\t//first return parameter indicates whether the service exists\n\t\t\texists=false;\n\t\t\treturn;\n\n\t\t} else {\n\t\t\texists=true;\n\t\t\tisSimple=s.isSimple;\n\t\t\t//note that the returned service description can't be read in solidity funtion call\n\t\t\tserviceDescription=s.serviceDescription;\n\t\t\ttokensPerCredit=s.tokensPerCredit;\n\t\t\tmaxCreditsPerProvision=s.maxCreditsPerProvision;\n\t\t\treceiptAddress=s.receiptAddress;\n\t\t\tisRemoved=s.isRemoved;\n\t\t\tprovisionHead=s.provisionHead;\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfunction getServiceUpdateAddress (\n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId ) \n\t\tpublic view returns (\n\t\t\taddress updateAddress ) {\n\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\treturn s.updateAddress;\n\t}\n\n\tfunction updateServiceDescription (\n\t\t\taddress _targetApplicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tstring _serviceDescription ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_targetApplicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\tservices[_targetApplicationAddress][_serviceId].serviceDescription=_serviceDescription;\n\t\t\n\t\temit ServiceChanged(_targetApplicationAddress, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction updateServiceTokensPerCredit (\n\t\t\taddress _targetApplicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tuint256 _tokensPerCredit ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_targetApplicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//check changed cost of the service is >0 \n\t\trequire(_tokensPerCredit != 0);\n\n\t\tservices[_targetApplicationAddress][_serviceId].tokensPerCredit=_tokensPerCredit;\n\t\t\n\t\temit ServiceChanged(_targetApplicationAddress, _serviceId);\n\n\t\treturn true;\t\t\n\t}\n\n\tfunction updateServiceMaxCreditsPerProvision (\n\t\t\taddress _targetApplicationAddress,\n\t\t\tuint32 _serviceId,\n\t\t\tuint256 _maxCreditsPerProvision )\n\t\tpublic returns (\n\t\t\tbool sucess ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_targetApplicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//note that credits per provision can be == 0 (no limit)\n\n\t\t//change max credits per provision for this service\n\t\tservices[_targetApplicationAddress][_serviceId].maxCreditsPerProvision=_maxCreditsPerProvision;\n\n\t\temit ServiceChanged(_targetApplicationAddress, _serviceId);\n\t\n\t\treturn true;\t\t\n\t}\n\n\tfunction changeServiceReceiptAddress(\n\t\t\tuint32 _serviceId, \n\t\t\taddress _receiptAddress ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//receipt address can only be changed by application address\n\n\t\t//check that service exists\n\t\trequire(services[msg.sender][_serviceId].applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[msg.sender][_serviceId].isRemoved == false);\n\n\t\t//check changed receiptAddress is not address(0)\n\t\trequire(_receiptAddress != address(0));\n\n\t\tservices[msg.sender][_serviceId].receiptAddress=_receiptAddress;\n\t\t\n\t\temit ServiceChanged(msg.sender, _serviceId);\n\n\t\treturn true;\t\t\n\t}\n\n\tfunction changeServiceUpdateAddress (\n\t\t\tuint32 _serviceId,\n\t\t\taddress _updateAddress )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//update address can only be changed by application address\n\n\t\t//check that service exists\n\t\trequire(services[msg.sender][_serviceId].applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[msg.sender][_serviceId].isRemoved == false);\n\n\t\t//note: update address can be address(0)\n\t\t//change the update address\n\t\tservices[msg.sender][_serviceId].updateAddress=_updateAddress;\n\n\t\temit ServiceChanged(msg.sender, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction removeService (\n\t\t\taddress _targetApplicationAddress, \n\t\t\tuint32 _serviceId ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//check that service exists\n\t\trequire(services[_targetApplicationAddress][_serviceId].applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( services[_targetApplicationAddress][_serviceId].updateAddress != address(0) \n\t\t\t   && msg.sender == services[_targetApplicationAddress][_serviceId].updateAddress \n\t\t\t  ));\n\n\t\t//check that service is not already removed\n\t\trequire(services[_targetApplicationAddress][_serviceId].isRemoved == false);\n\n\t\t//add to removed array\n\t\tservicesRemovedLists[_targetApplicationAddress].push(_serviceId);\n\n\t\t//change value of isRemoved to true\n\t\tservices[_targetApplicationAddress][_serviceId].isRemoved = true;\n\n\t\temit ServiceRemoved(_targetApplicationAddress, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction transferToSimpleService (\n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tuint256 _tokenValue, \n\t\t\tuint256 _applicationReference, \n\t\t\tuint256 _multiple ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//requested multiple must be >= 1\n\t\trequire(_multiple > 0);\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//service must exist\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[_applicationAddress][_serviceId].isRemoved == false);\n\n\t\t//check that service is a simple service\n\t\trequire(s.isSimple == true);\n\n\t\t//expected value is the token cost of the service multiplied by the requested multiple\n\t\tuint256 expectedValue=s.tokensPerCredit.mul(_multiple);\n\n\t\t//supplied token value must equal expected value\n\t\trequire(expectedValue == _tokenValue);\n\n\t\t//transfer the tokens -- this verifies the sender owns the tokens\n\t\ttransfer(s.receiptAddress, _tokenValue);\n\n\t\t//this starts and ends a simple provision at a single point in time \n\t\temit CompleteSimpleProvision(_applicationAddress, _serviceId, msg.sender, _multiple, _applicationReference);\n\n\t\treturn true;\n\t}\n\n\n\tfunction transferToService (\n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tuint256 _tokenValue, \n\t\t\tuint256 _credits,\n\t\t\tuint256 _applicationReference ) \n\t\tpublic returns (\n\t\t\tuint256 provisionId ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//service must exist\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[_applicationAddress][_serviceId].isRemoved == false);\n\n\t\t//check that service is not a simple service\n\t\trequire(s.isSimple == false);\n\n\t\t//verify: value == credits * tokens per credit\n\t\trequire(_tokenValue == (_credits.mul(s.tokensPerCredit)));\n\n\t\t//verify: max credits == 0 OR (value/tokens per credit) <= max credits per provision\n\t\trequire( s.maxCreditsPerProvision == 0 ||\n\t\t\t_credits <= s.maxCreditsPerProvision);\n\n\t\t//increment provision head and use as provision id\n\t\ts.provisionHead++;\n\t\tuint256 pid = s.provisionHead;\n\n\t\t//create provision in mapping\n\t\tprovisions[_applicationAddress][_serviceId][pid] = Provision (\n\t\t\t\ts.tokensPerCredit,\n\t\t\t\t_credits,\n\t\t\t\t_applicationReference,\n\t\t\t\tmsg.sender,\n\t\t\t\t_credits\t\t\n\t\t\t);\n\n\t\t//transfer the tokens\n\t\ttransfer(s.receiptAddress, _tokenValue);\n\n\t\t//emits a start provision \n\t\temit StartProvision(_applicationAddress, _serviceId, msg.sender, pid, _credits, s.tokensPerCredit, _applicationReference);\n\n\t\t//return provision id\n\t\treturn pid;\n\t}\n\n\tfunction getProvisionCreditsRemaining (\n\t\t\taddress _applicationAddress,\n\t\t\tuint32 _serviceId,\n\t\t    uint256 _provisionId )\n\t\tpublic view returns (\n\t\t\tuint256 credits) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//service must exist\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[_applicationAddress][_serviceId].isRemoved == false);\t\t\n\n\t\t//get & check that the provision exists (address at userAddress)\n\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\trequire(p.userAddress != 0);\n\n\t\t//return the credits remaining for this provision\n\t\treturn p.creditsRemaining;\n\t}\n\n\tfunction updateProvision (\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256 _provisionId,\n\t\t    uint256 _creditsRemaining )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//credits remaining must be >0, complete provision should be used to set to 0\n\t\trequire(_creditsRemaining > 0);\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _applicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//get & check that the provision exists (address at userAddress)\n\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\trequire(p.userAddress != 0);\n\n\t\t//update the credits remaining\n\t\tp.creditsRemaining=_creditsRemaining;\n\t\n\t\t//fires UpdateProvision\n\t\temit UpdateProvision(_applicationAddress, _serviceId, _provisionId, _creditsRemaining);\n\n\t\treturn true;\t\t\n\t}\n\n\tfunction completeProvision (\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256 _provisionId,\n\t\t    uint256 _creditsOutstanding )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _applicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//get & check that the provision exists (address at userAddress)\n\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\trequire(p.userAddress != 0);\n\n\t\tif(_creditsOutstanding > 0) {\n\t\t\t//can only signal refund total of credits originally provisioned\n\t\t\trequire(_creditsOutstanding <= p.creditsProvisioned);\n\n\t\t\temit SignalProvisionRefund(_applicationAddress, _serviceId, _provisionId, _creditsOutstanding.mul(p.tokensPerCredit));\n\t\t}\n\n\t\t//credits remaining on service is set to 0\n\t\tp.creditsRemaining=0;\n\n\t\t//fires CompleteProvision\n\t\temit CompleteProvision(_applicationAddress, _serviceId, _provisionId, _creditsOutstanding);\n\n\t\treturn true;\n\t}\n\n\n\tfunction confirmReference (\n\t\t\taddress _applicationAddress,\n\t\t\tuint256 _applicationReference,\n\t\t\tuint256 _senderTokensMinimum )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//sender must have some tokens - if 0 is passed to _senderTokensMinimum\n\t\t//then it is assumed that the method is checking that the sender has any amount\n\t\t//of tokens (>0)\n\t\trequire(balances[msg.sender] > 0);\n\n\t\t//sender must have min tokens if specified\n\t\trequire(_senderTokensMinimum == 0 \n\t\t\t|| balances[msg.sender] >= _senderTokensMinimum);\n\n\t\temit ReferenceConfirmed(_applicationAddress, _applicationReference, msg.sender, _senderTokensMinimum);\n\n\t\treturn true;\n\t}\n\n\n\tfunction transferBecauseOf (\n\t\t    address _to,\n\t\t    uint256 _value,\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256 _provisionId )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//provision ID can be optional, but if it's supplied it must exist\n\t\tif(_provisionId != 0) {\n\t\t\t//get & check that the provision exists (address at userAddress)\n\t\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\t\trequire(p.userAddress != 0);\n\t\t}\n\n\t\t//do the transfer\n\t\ttransfer(_to, _value);\n\n\t\temit TransferBecauseOf(_applicationAddress, _serviceId, _provisionId, msg.sender, _to, _value);\n\n\t\treturn true;\n\t}\n\n\n\tfunction transferBecauseOfAggregate (\n\t\t    address _to,\n\t\t    uint256 _value,\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256[] _provisionIds,\n\t\t    uint256[] _tokenAmounts )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//do the transfer\n\t\ttransfer(_to, _value);\n\n\t\temit TransferBecauseOfAggregate(_applicationAddress, _serviceId, _provisionIds, _tokenAmounts, msg.sender, _to, _value);\n\n\t\treturn true;\n\t}\n\n\tfunction ownerBurn ( \n\t\t\tuint256 _value )\n\t\tpublic returns (\n\t\t\tbool success) {\n\n\t\t//only the contract owner can burn tokens\n\t\trequire(msg.sender == contractOwner);\n\n\t\t//can only burn tokens held by the owner\n\t\trequire(_value <= balances[contractOwner]);\n\n\t\t//total supply of tokens is decremented when burned\n\t\ttotalSupply_ = totalSupply_.sub(_value);\n\n\t\t//balance of the contract owner is reduced (the contract owner's tokens are burned)\n\t\tbalances[contractOwner] = balances[contractOwner].sub(_value);\n\n\t\t//burning tokens emits a transfer to 0, as well as TokensBurned\n\t\temit Transfer(contractOwner, address(0), _value);\n\t\temit TokensBurned(contractOwner, _value);\n\n\t\treturn true;\n\n\t}\n\t\n\t\n\tfunction totalSupply ( ) public view returns (\n\t\tuint256 ) {\n\n\t\treturn totalSupply_;\n\t}\n\n\tfunction balanceOf (\n\t\t\taddress _owner ) \n\t\tpublic view returns (\n\t\t\tuint256 ) {\n\n\t\treturn balances[_owner];\n\t}\n\n\tfunction transfer (\n\t\t\taddress _to, \n\t\t\tuint256 _value ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[msg.sender]);\n\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n   \t//changing approval with this method has the same underlying issue as https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   \t//in that transaction order can be modified in a block to spend, change approval, spend again\n   \t//the method is kept for ERC-20 compatibility, but a set to zero, set again or use of the below increase/decrease should be used instead\n\tfunction approve (\n\t\t\taddress _spender, \n\t\t\tuint256 _value ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\tallowed[msg.sender][_spender] = _value;\n\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\tfunction increaseApproval (\n\t\t\taddress _spender, \n\t\t\tuint256 _addedValue ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\tfunction decreaseApproval (\n\t\t\taddress _spender,\n\t\t\tuint256 _subtractedValue ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\tuint256 oldValue = allowed[msg.sender][_spender];\n\n\t\tif (_subtractedValue > oldValue) {\n\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t} else {\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\t\t}\n\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\tfunction allowance (\n\t\t\taddress _owner, \n\t\t\taddress _spender ) \n\t\tpublic view returns (\n\t\t\tuint256 remaining ) {\n\n\t\treturn allowed[_owner][_spender];\n\t}\n\n\tfunction transferFrom (\n\t\t\taddress _from, \n\t\t\taddress _to, \n\t\t\tuint256 _value ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[_from]);\n\t\trequire(_value <= allowed[_from][msg.sender]);\n\n\t\tbalances[_from] = balances[_from].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n}",
        "debug": "calldata_U42_4 + calldata_U42_32 + 36: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_5 +\nkeccac_4294967295_&_4294967295_&_4294967295_&_calldata_U42_32_+_4: 0x0\nstorage_4 +\nkeccac_4294967295_&_4294967295_&_4294967295_&_calldata_U42_32_+_4: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_U42_4: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_0 +\nkeccac_4294967295_&_4294967295_&_4294967295_&_calldata_U42_32_+_4: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_U42_0: 0x274fadf600000000000000000000000000000000000000000000000000000000\ncalldatasize_U42: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x274fadf6`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/10/0x1f988b4ee752826e834f478b7668725ae7ecf53c.sol",
        "function": "_function_0x274fadf6",
        "lineno": 61,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 22147,
        "code": "s\n\tusing SafeMath for uint256;\n\n\tstring public constant name = \"U42\";\n\tstring public constant symbol = \"U42\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant initialSupply = 525000000 * (10 ** uint256(decimals));\n\tuint256 internal totalSupply_ = initialSupply;\n\taddress public contractOwner;\n\n\t//token balances\n\tmapping(address => uint256) balances;\n\n\t//for each balance address, map allowed addresses to amount allowed\n\tmapping (address => mapping (address => uint256)) internal allowed;\n\n\t//each service is represented by a Service struct \n\tstruct Service {\n\t\taddress applicationAddress;\n\t\tuint32 serviceId;\n\t\tbool isSimple;\n\t\tstring serviceDescription;\n\t\tuint256 tokensPerCredit;\n\t\tuint256 maxCreditsPerProvision;\n\t\taddress updateAddress;\n\t\taddress receiptAddress;\n\t\tbool isRemoved;\n\t\tuint256 provisionHead;\n\t}\n\n\tstruct Provision {\n\t\tuint256 tokensPerCredit;\n\t\tuint256 creditsRemaining;\n\t\tuint256 applicationReference;\n\t\taddress userAddress;\n\t\tuint256 creditsProvisioned;\n\t}\n\n\t//mapping of application addresses to service structs\n\tmapping (address => mapping (uint32 => Service)) services;\n\n\t//mapping of application addresses to service structs to provisions\n\tmapping (address => mapping (uint32 => mapping (uint256 => Provision))) provisions;\n\n\t//mapping of application addresses to lists of services\n\tmapping (address => uint32[]) servicesLists;\n\n\t//mapping of application addresses to lists of removed services\n\tmapping (address => uint32[]) servicesRemovedLists;\n\n\t//methods emit the following events\n\tevent Transfer (\n\t\taddress indexed from, \n\t\taddress indexed to, \n\t\tuint256 value );\n\n\tevent TokensBurned (\n\t\taddress indexed burner, \n\t\tuint256 value );\n\n\tevent Approval (\n\t\taddress indexed owner,\n\t\taddress indexed spender,\n\t\tuint256 value );\n\n\tevent NewService (\n\t\taddress indexed applicationAddress,\n\t\tuint32 serviceId );\n\n\tevent ServiceChanged (\n\t\taddress indexed applicationAddress,\n\t\tuint32 serviceId );\n\n\tevent ServiceRemoved (\n\t\taddress indexed applicationAddress,\n\t\tuint32 serviceId );\n\n\tevent CompleteSimpleProvision (\n\t\taddress indexed applicationAddress,\n\t\tuint32 indexed serviceId,\n\t\taddress indexed userAddress,\n\t\tuint256 multiple,\n\t\tuint256 applicationReference );\n\n\tevent ReferenceConfirmed (\n\t\taddress indexed applicationAddress,\n\t\tuint256 indexed applicationReference, \n\t\taddress indexed confirmedBy, \n\t\tuint256 confirmerTokensMinimum );\n\n\tevent StartProvision (\n\t    address indexed applicationAddress, \n\t    uint32 indexed serviceId, \n\t    address indexed userAddress,\n\t    uint256 provisionId,\n\t    uint256 serviceCredits,\n\t    uint256 tokensPerCredit, \n\t    uint256 applicationReference );\n\n\tevent UpdateProvision (\n\t    address indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    uint256 creditsRemaining );\n\n\tevent CompleteProvision (\n\t    address indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    uint256 creditsOutstanding );\n\n\tevent SignalProvisionRefund (\n\t    address indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    uint256 tokenValue );\n\n\tevent TransferBecauseOf (\n\t\taddress indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256 indexed provisionId,\n\t    address from,\n\t    address to,\n\t    uint256 value );\n\n\tevent TransferBecauseOfAggregate (\n\t\taddress indexed applicationAddress,\n\t    uint32 indexed serviceId,\n\t    uint256[] provisionIds,\n\t    uint256[] tokenAmounts,\n\t    address from,\n\t    address to,\n\t    uint256 value );\n\n\n\tconstructor() public {\n\t\t//contract creator holds all tokens at creation\n\t\tbalances[msg.sender] = totalSupply_;\n\n\t\t//record contract owner for later reference (e.g. in ownerBurn)\n\t\tcontractOwner=msg.sender;\n\n\t\t//indicate all tokens were sent to contract address\n\t\temit Transfer(address(0), msg.sender, totalSupply_);\n\t}\n\n\tfunction listSimpleService ( \n\t\t\tuint32 _serviceId, \n\t\t\tstring _serviceDescription,\n\t\t\tuint256 _tokensRequired,\n\t\t\taddress _updateAddress,\n\t\t\taddress _receiptAddress\t) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//check service id is not 0\n\t\trequire(_serviceId != 0);\n\n\t\t//check service doesn't already exist for this application id\n\t\trequire(services[msg.sender][_serviceId].applicationAddress == 0);\n\n\t\t//check cost of the service is >0 \n\t\trequire(_tokensRequired != 0);\n\n\t\t//check receiptAddress is not address(0)\n\t\trequire(_receiptAddress != address(0));\n\n\t\t//update address should be address(0) or a non-sender address\n\t\trequire(_updateAddress != msg.sender);\n\n\t\t//add service to services mapping\n\t\tservices[msg.sender][_serviceId] = Service(\n\t\t\t\tmsg.sender,\n\t\t\t\t_serviceId,\n\t\t\t\ttrue,\n\t\t\t\t_serviceDescription,\n\t\t\t\t_tokensRequired,\n\t\t\t\t1,\n\t\t\t\t_updateAddress,\n\t\t\t\t_receiptAddress,\n\t\t\t\tfalse,\n\t\t\t\t0\n\t\t\t);\n\n\t\t//add service to servicesLists for application\n\t\tservicesLists[msg.sender].push(_serviceId);\n\n\t\t//emit NewService\n\t\temit NewService(msg.sender, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction listService ( \n\t\t\tuint32 _serviceId, \n\t\t\tstring _serviceDescription,\n\t\t\tuint256 _tokensPerCredit,\n\t\t\tuint256 _maxCreditsPerProvision,\n\t\t\taddress _updateAddress,\n\t\t\taddress _receiptAddress\t) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//check service id is not 0\n\t\trequire(_serviceId != 0);\n\n\t\t//check service doesn't already exist for this application id\n\t\trequire(services[msg.sender][_serviceId].applicationAddress == 0);\n\n\t\t//check cost of the service is >0 \n\t\trequire(_tokensPerCredit != 0);\n\n\t\t//check receiptAddress is not address(0)\n\t\trequire(_receiptAddress != address(0));\n\n\t\t//update address should be address(0) or a non-sender address\n\t\trequire(_updateAddress != msg.sender);\n\n\t\t//add service to services mapping\n\t\tservices[msg.sender][_serviceId] = Service(\n\t\t\t\tmsg.sender,\n\t\t\t\t_serviceId,\n\t\t\t\tfalse,\n\t\t\t\t_serviceDescription,\n\t\t\t\t_tokensPerCredit,\n\t\t\t\t_maxCreditsPerProvision,\n\t\t\t\t_updateAddress,\n\t\t\t\t_receiptAddress,\n\t\t\t\tfalse,\n\t\t\t\t0\n\t\t\t);\n\n\t\t//add service to servicesLists for application\n\t\tservicesLists[msg.sender].push(_serviceId);\n\n\t\t//emit NewService\n\t\temit NewService(msg.sender, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction getServicesForApplication ( \n\t\t\taddress _applicationAddress ) \n\t\tpublic view returns (\n\t\t\tuint32[] serviceIds ) {\n\n\t\treturn servicesLists[_applicationAddress];\n\t}\n\n\tfunction getRemovedServicesForApplication (\n\t\t\taddress _applicationAddress ) \n\t\tpublic view returns (\n\t\t\tuint32[] serviceIds ) {\n\n\t\treturn servicesRemovedLists[_applicationAddress];\n\t}\n\n\tfunction isServiceRemoved (\n\t\t\taddress _applicationAddress,\n\t\t\tuint32 _serviceId )\n\t\tpublic view returns (\n\t\t\tbool ) {\n\n\t\t//returns true if service has been removed\n\t\treturn services[_applicationAddress][_serviceId].isRemoved;\n\t}\n\n\tfunction getServiceInformation ( \n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId )\n\t\tpublic view returns (\n\t\t\tbool exists,\n\t\t\tbool isSimple,\n\t\t\tstring serviceDescription,\n\t\t\tuint256 tokensPerCredit,\n\t\t\tuint256 maxCreditsPerProvision,\n\t\t\taddress receiptAddress,\n\t\t\tbool isRemoved,\n\t\t\tuint256 provisionHead ) {\n\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//services with unset application address indicates an empty/unset struct in the mapping\n\t\tif(s.applicationAddress == 0) {\n\t\t\t//first return parameter indicates whether the service exists\n\t\t\texists=false;\n\t\t\treturn;\n\n\t\t} else {\n\t\t\texists=true;\n\t\t\tisSimple=s.isSimple;\n\t\t\t//note that the returned service description can't be read in solidity funtion call\n\t\t\tserviceDescription=s.serviceDescription;\n\t\t\ttokensPerCredit=s.tokensPerCredit;\n\t\t\tmaxCreditsPerProvision=s.maxCreditsPerProvision;\n\t\t\treceiptAddress=s.receiptAddress;\n\t\t\tisRemoved=s.isRemoved;\n\t\t\tprovisionHead=s.provisionHead;\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfunction getServiceUpdateAddress (\n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId ) \n\t\tpublic view returns (\n\t\t\taddress updateAddress ) {\n\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\treturn s.updateAddress;\n\t}\n\n\tfunction updateServiceDescription (\n\t\t\taddress _targetApplicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tstring _serviceDescription ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_targetApplicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\tservices[_targetApplicationAddress][_serviceId].serviceDescription=_serviceDescription;\n\t\t\n\t\temit ServiceChanged(_targetApplicationAddress, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction updateServiceTokensPerCredit (\n\t\t\taddress _targetApplicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tuint256 _tokensPerCredit ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_targetApplicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//check changed cost of the service is >0 \n\t\trequire(_tokensPerCredit != 0);\n\n\t\tservices[_targetApplicationAddress][_serviceId].tokensPerCredit=_tokensPerCredit;\n\t\t\n\t\temit ServiceChanged(_targetApplicationAddress, _serviceId);\n\n\t\treturn true;\t\t\n\t}\n\n\tfunction updateServiceMaxCreditsPerProvision (\n\t\t\taddress _targetApplicationAddress,\n\t\t\tuint32 _serviceId,\n\t\t\tuint256 _maxCreditsPerProvision )\n\t\tpublic returns (\n\t\t\tbool sucess ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_targetApplicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//note that credits per provision can be == 0 (no limit)\n\n\t\t//change max credits per provision for this service\n\t\tservices[_targetApplicationAddress][_serviceId].maxCreditsPerProvision=_maxCreditsPerProvision;\n\n\t\temit ServiceChanged(_targetApplicationAddress, _serviceId);\n\t\n\t\treturn true;\t\t\n\t}\n\n\tfunction changeServiceReceiptAddress(\n\t\t\tuint32 _serviceId, \n\t\t\taddress _receiptAddress ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//receipt address can only be changed by application address\n\n\t\t//check that service exists\n\t\trequire(services[msg.sender][_serviceId].applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[msg.sender][_serviceId].isRemoved == false);\n\n\t\t//check changed receiptAddress is not address(0)\n\t\trequire(_receiptAddress != address(0));\n\n\t\tservices[msg.sender][_serviceId].receiptAddress=_receiptAddress;\n\t\t\n\t\temit ServiceChanged(msg.sender, _serviceId);\n\n\t\treturn true;\t\t\n\t}\n\n\tfunction changeServiceUpdateAddress (\n\t\t\tuint32 _serviceId,\n\t\t\taddress _updateAddress )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//update address can only be changed by application address\n\n\t\t//check that service exists\n\t\trequire(services[msg.sender][_serviceId].applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[msg.sender][_serviceId].isRemoved == false);\n\n\t\t//note: update address can be address(0)\n\t\t//change the update address\n\t\tservices[msg.sender][_serviceId].updateAddress=_updateAddress;\n\n\t\temit ServiceChanged(msg.sender, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction removeService (\n\t\t\taddress _targetApplicationAddress, \n\t\t\tuint32 _serviceId ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//check that service exists\n\t\trequire(services[_targetApplicationAddress][_serviceId].applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _targetApplicationAddress || \n\t\t\t( services[_targetApplicationAddress][_serviceId].updateAddress != address(0) \n\t\t\t   && msg.sender == services[_targetApplicationAddress][_serviceId].updateAddress \n\t\t\t  ));\n\n\t\t//check that service is not already removed\n\t\trequire(services[_targetApplicationAddress][_serviceId].isRemoved == false);\n\n\t\t//add to removed array\n\t\tservicesRemovedLists[_targetApplicationAddress].push(_serviceId);\n\n\t\t//change value of isRemoved to true\n\t\tservices[_targetApplicationAddress][_serviceId].isRemoved = true;\n\n\t\temit ServiceRemoved(_targetApplicationAddress, _serviceId);\n\n\t\treturn true;\n\t}\n\n\tfunction transferToSimpleService (\n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tuint256 _tokenValue, \n\t\t\tuint256 _applicationReference, \n\t\t\tuint256 _multiple ) \n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//requested multiple must be >= 1\n\t\trequire(_multiple > 0);\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//service must exist\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[_applicationAddress][_serviceId].isRemoved == false);\n\n\t\t//check that service is a simple service\n\t\trequire(s.isSimple == true);\n\n\t\t//expected value is the token cost of the service multiplied by the requested multiple\n\t\tuint256 expectedValue=s.tokensPerCredit.mul(_multiple);\n\n\t\t//supplied token value must equal expected value\n\t\trequire(expectedValue == _tokenValue);\n\n\t\t//transfer the tokens -- this verifies the sender owns the tokens\n\t\ttransfer(s.receiptAddress, _tokenValue);\n\n\t\t//this starts and ends a simple provision at a single point in time \n\t\temit CompleteSimpleProvision(_applicationAddress, _serviceId, msg.sender, _multiple, _applicationReference);\n\n\t\treturn true;\n\t}\n\n\n\tfunction transferToService (\n\t\t\taddress _applicationAddress, \n\t\t\tuint32 _serviceId, \n\t\t\tuint256 _tokenValue, \n\t\t\tuint256 _credits,\n\t\t\tuint256 _applicationReference ) \n\t\tpublic returns (\n\t\t\tuint256 provisionId ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//service must exist\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[_applicationAddress][_serviceId].isRemoved == false);\n\n\t\t//check that service is not a simple service\n\t\trequire(s.isSimple == false);\n\n\t\t//verify: value == credits * tokens per credit\n\t\trequire(_tokenValue == (_credits.mul(s.tokensPerCredit)));\n\n\t\t//verify: max credits == 0 OR (value/tokens per credit) <= max credits per provision\n\t\trequire( s.maxCreditsPerProvision == 0 ||\n\t\t\t_credits <= s.maxCreditsPerProvision);\n\n\t\t//increment provision head and use as provision id\n\t\ts.provisionHead++;\n\t\tuint256 pid = s.provisionHead;\n\n\t\t//create provision in mapping\n\t\tprovisions[_applicationAddress][_serviceId][pid] = Provision (\n\t\t\t\ts.tokensPerCredit,\n\t\t\t\t_credits,\n\t\t\t\t_applicationReference,\n\t\t\t\tmsg.sender,\n\t\t\t\t_credits\t\t\n\t\t\t);\n\n\t\t//transfer the tokens\n\t\ttransfer(s.receiptAddress, _tokenValue);\n\n\t\t//emits a start provision \n\t\temit StartProvision(_applicationAddress, _serviceId, msg.sender, pid, _credits, s.tokensPerCredit, _applicationReference);\n\n\t\t//return provision id\n\t\treturn pid;\n\t}\n\n\tfunction getProvisionCreditsRemaining (\n\t\t\taddress _applicationAddress,\n\t\t\tuint32 _serviceId,\n\t\t    uint256 _provisionId )\n\t\tpublic view returns (\n\t\t\tuint256 credits) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//service must exist\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(services[_applicationAddress][_serviceId].isRemoved == false);\t\t\n\n\t\t//get & check that the provision exists (address at userAddress)\n\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\trequire(p.userAddress != 0);\n\n\t\t//return the credits remaining for this provision\n\t\treturn p.creditsRemaining;\n\t}\n\n\tfunction updateProvision (\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256 _provisionId,\n\t\t    uint256 _creditsRemaining )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//credits remaining must be >0, complete provision should be used to set to 0\n\t\trequire(_creditsRemaining > 0);\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _applicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//get & check that the provision exists (address at userAddress)\n\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\trequire(p.userAddress != 0);\n\n\t\t//update the credits remaining\n\t\tp.creditsRemaining=_creditsRemaining;\n\t\n\t\t//fires UpdateProvision\n\t\temit UpdateProvision(_applicationAddress, _serviceId, _provisionId, _creditsRemaining);\n\n\t\treturn true;\t\t\n\t}\n\n\tfunction completeProvision (\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256 _provisionId,\n\t\t    uint256 _creditsOutstanding )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//update must be by the application address or, if specified, update address\n\t\trequire(msg.sender == _applicationAddress || \n\t\t\t( s.updateAddress != address(0) && msg.sender == s.updateAddress ));\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//get & check that the provision exists (address at userAddress)\n\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\trequire(p.userAddress != 0);\n\n\t\tif(_creditsOutstanding > 0) {\n\t\t\t//can only signal refund total of credits originally provisioned\n\t\t\trequire(_creditsOutstanding <= p.creditsProvisioned);\n\n\t\t\temit SignalProvisionRefund(_applicationAddress, _serviceId, _provisionId, _creditsOutstanding.mul(p.tokensPerCredit));\n\t\t}\n\n\t\t//credits remaining on service is set to 0\n\t\tp.creditsRemaining=0;\n\n\t\t//fires CompleteProvision\n\t\temit CompleteProvision(_applicationAddress, _serviceId, _provisionId, _creditsOutstanding);\n\n\t\treturn true;\n\t}\n\n\n\tfunction confirmReference (\n\t\t\taddress _applicationAddress,\n\t\t\tuint256 _applicationReference,\n\t\t\tuint256 _senderTokensMinimum )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//sender must have some tokens - if 0 is passed to _senderTokensMinimum\n\t\t//then it is assumed that the method is checking that the sender has any amount\n\t\t//of tokens (>0)\n\t\trequire(balances[msg.sender] > 0);\n\n\t\t//sender must have min tokens if specified\n\t\trequire(_senderTokensMinimum == 0 \n\t\t\t|| balances[msg.sender] >= _senderTokensMinimum);\n\n\t\temit ReferenceConfirmed(_applicationAddress, _applicationReference, msg.sender, _senderTokensMinimum);\n\n\t\treturn true;\n\t}\n\n\n\tfunction transferBecauseOf (\n\t\t    address _to,\n\t\t    uint256 _value,\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256 _provisionId )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//provision ID can be optional, but if it's supplied it must exist\n\t\tif(_provisionId != 0) {\n\t\t\t//get & check that the provision exists (address at userAddress)\n\t\t\tProvision storage p=provisions[_applicationAddress][_serviceId][_provisionId];\n\t\t\trequire(p.userAddress != 0);\n\t\t}\n\n\t\t//do the transfer\n\t\ttransfer(_to, _value);\n\n\t\temit TransferBecauseOf(_applicationAddress, _serviceId, _provisionId, msg.sender, _to, _value);\n\n\t\treturn true;\n\t}\n\n\n\tfunction transferBecauseOfAggregate (\n\t\t    address _to,\n\t\t    uint256 _value,\n\t\t    address _applicationAddress,\n\t\t    uint32 _serviceId,\n\t\t    uint256[] _provisionIds,\n\t\t    uint256[] _tokenAmounts )\n\t\tpublic returns (\n\t\t\tbool success ) {\n\n\t\t//get the referenced service\n\t\tService storage s=services[_applicationAddress][_serviceId];\n\n\t\t//check that service exists\n\t\trequire(s.applicationAddress != 0);\n\n\t\t//check that service is not removed\n\t\trequire(s.isRemoved == false);\n\n\t\t//do the transfer\n\t\ttransfer(_to, _value);\n\n\t\temit TransferBecauseOfAggregate(_applicationAddress, _serviceId, _provisionIds, _tokenAmounts, msg.sender, _to, _value);\n\n\t\treturn true;\n\t}\n\n\tfunction ownerBurn ( \n\t\t\tuint256 _value )\n\t\tpublic returns (\n\t\t\tbool success) {\n\n\t\t//only the contract owner can burn tokens\n\t\trequire(msg.sender == contractOwner);\n\n\t\t//can only burn tokens held by the owner\n\t\trequire(_value <= balances[contractOwner]);\n\n\t\t//total supply of tokens is decremented when burned\n\t\ttotalSupply_ = totalSupply_.sub(_value);\n\n\t\t//balance of the contract owner is reduced (the contract owner's tokens are burned)\n\t\tbalances[contractOwner] = balances[contractOwner].sub(_value);\n\n\t\t//burning tokens emits a transfer to 0, as well as TokensBurned\n\t\temit Transfer(contractOwner, address(0), _value);\n\t\temit TokensBurned(contractOwner, _value);\n\n\t\treturn true;\n\n\t}\n\t\n\t\n\tfunction totalSupply ( ) public view returns (\n\t\tuint256 ) {\n\n\t\treturn totalSupply_;\n\t}\n\n\tfunction balanceOf (\n\t\t\taddress _owner ) \n\t\tpublic view returns (\n\t\t\tuint256 ) {\n\n\t\treturn balances[_owner];\n\t}\n\n\tfunction transfer (\n\t\t\taddress _to, \n\t\t\tuint256 _value ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[msg.sender]);\n\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n   \t//changing approval with this method has the same underlying issue as https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   \t//in that transaction order can be modified in a block to spend, change approval, spend again\n   \t//the method is kept for ERC-20 compatibility, but a set to zero, set again or use of the below increase/decrease should be used instead\n\tfunction approve (\n\t\t\taddress _spender, \n\t\t\tuint256 _value ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\tallowed[msg.sender][_spender] = _value;\n\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\tfunction increaseApproval (\n\t\t\taddress _spender, \n\t\t\tuint256 _addedValue ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\tfunction decreaseApproval (\n\t\t\taddress _spender,\n\t\t\tuint256 _subtractedValue ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\tuint256 oldValue = allowed[msg.sender][_spender];\n\n\t\tif (_subtractedValue > oldValue) {\n\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t} else {\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\t\t}\n\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\tfunction allowance (\n\t\t\taddress _owner, \n\t\t\taddress _spender ) \n\t\tpublic view returns (\n\t\t\tuint256 remaining ) {\n\n\t\treturn allowed[_owner][_spender];\n\t}\n\n\tfunction transferFrom (\n\t\t\taddress _from, \n\t\t\taddress _to, \n\t\t\tuint256 _value ) \n\t\tpublic returns (\n\t\t\tbool ) {\n\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[_from]);\n\t\trequire(_value <= allowed[_from][msg.sender]);\n\n\t\tbalances[_from] = balances[_from].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n}",
        "debug": "calldata_U42_4 + calldata_U42_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_5 +\nkeccac_4294967295_&_4294967295_&_4294967295_&_calldata_U42_32_+_4: 0x0\nstorage_4 +\nkeccac_4294967295_&_4294967295_&_4294967295_&_calldata_U42_32_+_4: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_U42_4: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_0 +\nkeccac_4294967295_&_4294967295_&_4294967295_&_calldata_U42_32_+_4: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_U42_0: 0x274fadf600000000000000000000000000000000000000000000000000000000\ncalldatasize_U42: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x274fadf6`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/10/0x1f988b4ee752826e834f478b7668725ae7ecf53c.sol",
        "function": "_function_0x274fadf6",
        "lineno": 61,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}