{"error": null, "issues": [{"address": 683, "code": "rns(bool _result){         \n        _result = false;\n        require(!gameOver);       \n        require(gameEndTime < now); \n        if(lastBlockNumber == block.number){                           \n            emit OnOpenGameResult(gameID, msg.sender,0, '',false, 2, now, getEventId());\n            return;\n        }\n\n        lock(); \n\t\t\n        gameEndPlayNo = playNo", "debug": "calldata_SelectOne_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_SelectOne_0: 0x3bb5d8a00000000000000000000000000000000000000000000000000000000\ncalldatasize_SelectOne: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `openGameResultAndNewGame(uint256,string,bytes32)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/33/0x56c95c0a4e3c667e30ef383dcaffa7d35b64e20a.sol", "function": "openGameResultAndNewGame(uint256,string,bytes32)", "lineno": 416, "title": "Integer Overflow ", "type": "Warning"}, {"address": 695, "code": "rns(bool _result){         \n        _result = false;\n        require(!gameOver);       \n        require(gameEndTime < now); \n        if(lastBlockNumber == block.number){                           \n            emit OnOpenGameResult(gameID, msg.sender,0, '',false, 2, now, getEventId());\n            return;\n        }\n\n        lock(); \n\t\t\n        gameEndPlayNo = playNo", "debug": "calldata_SelectOne_4 + calldata_SelectOne_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8\ncalldata_SelectOne_0: 0x3bb5d8a00000000000000000000000000000000000000000000000000000000\ncalldatasize_SelectOne: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `openGameResultAndNewGame(uint256,string,bytes32)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/33/0x56c95c0a4e3c667e30ef383dcaffa7d35b64e20a.sol", "function": "openGameResultAndNewGame(uint256,string,bytes32)", "lineno": 416, "title": "Integer Overflow ", "type": "Warning"}, {"address": 704, "code": "rns(bool _result){         \n        _result = false;\n        require(!gameOver);       \n        require(gameEndTime < now); \n        if(lastBlockNumber == block.number){                           \n            emit OnOpenGameResult(gameID, msg.sender,0, '',false, 2, now, getEventId());\n            return;\n        }\n\n        lock(); \n\t\t\n        gameEndPlayNo = playNo", "debug": "calldata_SelectOne_4 + calldata_SelectOne_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc1\ncalldata_SelectOne_0: 0x3bb5d8a00000000000000000000000000000000000000000000000000000000\ncalldatasize_SelectOne: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `openGameResultAndNewGame(uint256,string,bytes32)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/33/0x56c95c0a4e3c667e30ef383dcaffa7d35b64e20a.sol", "function": "openGameResultAndNewGame(uint256,string,bytes32)", "lineno": 416, "title": "Integer Overflow ", "type": "Warning"}, {"address": 710, "code": "rns(bool _result){         \n        _result = false;\n        require(!gameOver);       \n        require(gameEndTime < now); \n        if(lastBlockNumber == block.number){                           \n            emit OnOpenGameResult(gameID, msg.sender,0, '',false, 2, now, getEventId());\n            return;\n        }\n\n        lock(); \n\t\t\n        gameEndPlayNo = playNo", "debug": "calldata_SelectOne_4 + calldata_SelectOne_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff41\ncalldata_SelectOne_0: 0x3bb5d8a00000000000000000000000000000000000000000000000000000000\ncalldatasize_SelectOne: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `openGameResultAndNewGame(uint256,string,bytes32)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/33/0x56c95c0a4e3c667e30ef383dcaffa7d35b64e20a.sol", "function": "openGameResultAndNewGame(uint256,string,bytes32)", "lineno": 416, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1561, "code": "   }\n        \n}\n\ncontract SelectOne is Base\n{    \n    uint public constant minNum = 1;        \n    uint public maxNum = 22;     ", "debug": "calldata_SelectOne_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_SelectOne_0: 0x26c4fa3d00000000000000000000000000000000000000000000000000000000\ncalldatasize_SelectOne: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setOfficialGameUrl(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/33/0x56c95c0a4e3c667e30ef383dcaffa7d35b64e20a.sol", "function": "setOfficialGameUrl(string)", "lineno": 125, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4705, "code": "          ", "debug": "storage_25: 0x0\nstorage_17: 0x0\nstorage_8: 0x0\nblock_number: 0x0\nstorage_15: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ntimestamp: 0x1\nstorage_26: 0x0\ncalldata_SelectOne_0: 0x10828bcc00000000000000000000000000000000000000000000000000000000\ncalldatasize_SelectOne: 0x4\ncallvalue: 0x0\n", "description": "A possible integer underflow exists in the function `noOpenGameResult()`.\nThe subtraction may result in a value < 0.", "filename": "/unique_chucks/33/0x56c95c0a4e3c667e30ef383dcaffa7d35b64e20a.sol", "function": "noOpenGameResult()", "lineno": 434, "title": "Integer Underflow", "type": "Warning"}, {"address": 6438, "code": ") public {\n        lock();\n     ", "debug": "", "description": "This contract executes a message call to an address found at storage slot 8. This storage slot can be written to by calling the function `noOpenGameResult()`. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.", "filename": "/unique_chucks/33/0x56c95c0a4e3c667e30ef383dcaffa7d35b64e20a.sol", "function": "tokenOf(address)", "lineno": 87, "title": "Message call to external contract", "type": "Warning"}, {"address": 6438, "code": ") public {\n        lock();\n     ", "debug": "", "description": "A possible transaction order independence vulnerability exists in function tokenOf(address). The value or direction of the call statement is determined from a tainted storage location", "filename": "/unique_chucks/33/0x56c95c0a4e3c667e30ef383dcaffa7d35b64e20a.sol", "function": "tokenOf(address)", "lineno": 87, "title": "Transaction order dependence", "type": "Warning"}, {"address": 13722, "code": "        ", "debug": "storage_3: 0x0\nstorage_4: 0xffffffffffe00000000000000000000000000000000000000000000000000000\ntimestamp: 0xffffffefffdfffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_18: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_12: 0x1\nstorage_26: 0xff00\nstorage_5: 0x0\ncaller: 0x0\ncalldata_SelectOne_0: 0x3bb5d8a00000000000000000000000000000000000000000000000000000000\ncalldatasize_SelectOne: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `openGameResultAndNewGame(uint256,string,bytes32)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/33/0x56c95c0a4e3c667e30ef383dcaffa7d35b64e20a.sol", "function": "openGameResultAndNewGame(uint256,string,bytes32)", "lineno": 250, "title": "Integer Overflow ", "type": "Warning"}, {"address": 13829, "code": " false;\n        ", "debug": "storage_3: 0x4000501fffdffffffff818001000200000000764000000000024000000001\nstorage_4: 0xfff7fffa7e305bcb05cfbffc4000000000000007c54000100000006000000001\ntimestamp: 0xffebfffa7a00020e0000006d0001fffdffffffff89c000000000024000000001\ncalldata_SelectOne_4 + calldata_SelectOne_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff21\nstorage_12: 0x62609e7fffffffc14001efbffffeffbea01ffffffffffdbfffffffff\nstorage_26: 0xff00\nstorage_5: 0x0\ncaller: 0x0\ncalldata_SelectOne_0: 0x3bb5d8a00000000000000000000000000000000000000000000000000000000\ncalldatasize_SelectOne: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `openGameResultAndNewGame(uint256,string,bytes32)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/33/0x56c95c0a4e3c667e30ef383dcaffa7d35b64e20a.sol", "function": "openGameResultAndNewGame(uint256,string,bytes32)", "lineno": 253, "title": "Integer Overflow ", "type": "Warning"}, {"address": 14141, "code": "lGameUrl = _newOf", "debug": "storage_9: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_25: 0x0\ntimestamp: 0x1\nstorage_26: 0x0\ncalldata_SelectOne_0: 0x10828bcc00000000000000000000000000000000000000000000000000000000\ncalldatasize_SelectOne: 0x4\nblock_number: 0x0\nstorage_15: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `noOpenGameResult()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/33/0x56c95c0a4e3c667e30ef383dcaffa7d35b64e20a.sol", "function": "noOpenGameResult()", "lineno": 124, "title": "Integer Overflow ", "type": "Warning"}, {"address": 14224, "code": "return c;\n  }\n", "debug": "The exception is triggered under the following conditions:\n\nstorage_11: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffcc\nstorage_19: 0x0\nstorage_25: 0x0\nstorage_3 + keccac_storage_19: 0x0\nstorage_17: 0x1\nstorage_8: 0x0\nblock_number: 0x0\nstorage_15: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ntimestamp: 0x1\nstorage_26: 0x0\ncalldata_SelectOne_0: 0x10828bcc00000000000000000000000000000000000000000000000000000000\ncalldatasize_SelectOne: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/33/0x56c95c0a4e3c667e30ef383dcaffa7d35b64e20a.sol", "function": "noOpenGameResult()", "lineno": 22, "title": "Exception state", "type": "Informational"}, {"address": 14780, "code": "EventId() internal returns(uint _resul", "debug": "", "description": "This contract executes a message call to an address found at storage slot 8. This storage slot can be written to by calling the function `noOpenGameResult()`. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.", "filename": "/unique_chucks/33/0x56c95c0a4e3c667e30ef383dcaffa7d35b64e20a.sol", "function": "withdrawAllToken()", "lineno": 118, "title": "Message call to external contract", "type": "Warning"}, {"address": 14780, "code": "EventId() internal returns(uint _resul", "debug": "", "description": "A possible transaction order independence vulnerability exists in function withdrawAllToken(). The value or direction of the call statement is determined from a tainted storage location", "filename": "/unique_chucks/33/0x56c95c0a4e3c667e30ef383dcaffa7d35b64e20a.sol", "function": "withdrawAllToken()", "lineno": 118, "title": "Transaction order dependence", "type": "Warning"}, {"address": 17701, "code": "nt  public winMultiplePer = 90;     \n    \n    uint  public constant maxPlayerNum = 100;      \n    uint public gameTime; \n    uint256 public gameMaxBetAmount;    \n    uint256 public gameMinBetAmount;    \n\t\n\tfunction SelectOne(uint _maxNum, uint  _gameTime, uint256 _gameMinBetAmount, uint256 _gameMaxBetAmount,uint _winMultiplePer, string _gameName,address _DonQuixoteToken)  public {\n        require(_gameMinBetAmount >= 0);\n        require(_gameMaxBetAmount > 0);\n        require(_gameMaxBetAmount >= _gameMinBetAmount);\n\t\trequire(_maxNum < 10000);              \n        require(1 < _maxNum);                   \n        require(_winMultiplePer < _maxNum.mul(100));      \n        \n\t\tgameMinBetAmount = _gameMinBetAmount;\n        gameMaxBetAmount = _gameMaxBetAmount;\n        gameTime = _gameTime;\n        maxNum = _maxNum;                      \n        winMultiplePer = _winMultiplePer;       \n        owner = msg.sender;             \n        gameName = _gameName;           \n\n        require(_DonQuixoteToken != 0x0);\n        DonQuixoteToken = IDonQuixoteToken(_DonQuixoteToken);\n    }\n\n    uint public lastBlockNumber = 0;            \n    bool public betInfoIsLocked = false;       \n    address public auction;             \n    \n\n    function setAuction(address _newAuction) public onlyOwner{\n        require(_newAuction != 0x0);\n        auction = _newAuction;\n    }\n    modifier onlyAuction {             \n        require(msg.sender == auction);\n        _;\n    }\n\n    function canSetBanker() public view returns (bool _result){\n        _result =  bankerEndTime <= now && gameOver;\n    }\n\t\n    modifier onlyBanker {               \n        require(msg.sender == currentBanker);\n        require(bankerBeginTime <= now);\n        require(now < bankerEndTime);     \n        _;\n    }\n\n    event OnSetNewBanker(address _caller, address _banker, uint _beginTime, uint _endTime, uint _code, uint _eventTime, uint eventId);\n\n    function setBanker(address _banker, uint _beginTime, uint _endTime) public onlyAuction returns(bool _result)\n\t{\n        _result = false;\n        require(_banker != 0x0);\n        if(now < bankerEndTime){        \n            emit OnSetNewBanker(msg.sender, _banker,  _beginTime,  _endTime, 1, now, getEventId());\n            return;\n        }\n        if(!gameOver){                  \n            emit OnSetNewBanker(msg.sender, _banker,  _beginTime,  _endTime, 2, now, getEventId());\n            return;\n        }\n        if(_beginTime > now){               \n            emit OnSetNewBanker(msg.sender, _banker,  _beginTime,  _endTime, 3, now, getEventId()); \n            return;\n        }\n        if(_endTime <= now){\n            emit OnSetNewBanker(msg.sender, _banker,  _beginTime,  _endTime, 4, now, getEventId());\n            return;\n        }\n\t    if(now < donGameGiftLineTime){\n            DonQuixoteToken.logPlaying(_banker);\n        }\n        currentBanker = _banker;\n        bankerBeginTime = _beginTime;\n        bankerEndTime = _endTime;\n        emit OnSetNewBanker(msg.sender, _banker,  _beginTime,  _endTime, 0 , now, getEventId());\n        _result = true;\n    }\n \n    uint public playNo = 1;             \n    uint public gameID = 0;             \n    uint public gameBeginPlayNo;        \n    uint public gameEndPlayNo;          \n    bytes32 public gameEncryptedText;  \n    uint public gameResult;            \n    string public gameRandon1;          \n    string public constant gameRandon2 = 'ChinasNewGovernmentBracesforTrump';   \n    uint  public gameBeginTime;        \n    uint  public gameEndTime;           \n    bool public gameOver = true;       \n    uint public donGameGiftLineTime = now.add(90 days);  \n    \n\t\n    event OnNewGame(uint _gameID, address _banker, bytes32 _gameEncryptedText, uint  _gameBeginTime,  uint  _gameEndTime, uint _eventTime, uint _eventId);\n\n    function newGame(bytes32 _gameEncryptedText) public onlyBanker returns(bool _result)               \n    {\n        _result = _newGame( _gameEncryptedText);\n    }\n\n    function _newGame(bytes32 _gameEncryptedText) private  returns(bool _result)       \n    {\n        _result = false;\n        require(gameOver); \n        require(bankerBeginTime < now);       \n        require(now.add(gameTime) <= bankerEndTime);    \n        gameID++;                           \n        currentBanker = msg.sender;\n        gameEncryptedText = _gameEncryptedText;\n        gameRandon1 = '';          \n        gameBeginTime = now;                \n        gameEndTime = now.add(gameTime);\n        gameBeginPlayNo = playNo;          \n        gameEndPlayNo = 0;                 \n        gameResult = 0;  \n        gameOver = false;\n        \n        emit OnNewGame(gameID, msg.sender, _gameEncryptedText, now, now.add(gameTime), now, getEventId());\n        _result = true;\n    }\n    \n    struct betInfo              \n    {\n        address Player;\n        uint BetNum;            \n        uint256 BetAmount;      \n        bool IsReturnAward;     \n    }\n\n    mapping (uint => betInfo) public playerBetInfoOf;              \n    event OnPlay(uint indexed _gameID, address indexed _player, uint _betNum, uint256 _betAmount, uint _playNo, uint _eventTime, uint _eventId);\n\n    function play(uint _betNum, uint256 _betAmount) public  returns(bool _result){      \n        _result = _play(_betNum, _betAmount);\n    }\n\n    function _play(uint _betNum, uint256 _betAmount) private  returns(bool _result){            \n        _result = false;\n        require(!gameOver);\n        require(!betInfoIsLocked);                         \n        require(now < gameEndTime);\n        require(playNo.sub(gameBeginPlayNo) <= maxPlayerNum); \n        require(minNum <= _betNum && _betNum <= maxNum);    \n        require(msg.sender != currentBanker);                \n                   \n        uint256 ba = _betAmount;\n        if (ba > gameMaxBetAmount){                       \n            ba = gameMaxBetAmount;\n        }\n        require(ba >= gameMinBetAmount);                   \n\n        if(userTokenOf[msg.sender] < ba){                                       \n            depositToken(ba.sub(userTokenOf[msg.sender]));                    \n        }\n        require(userTokenOf[msg.sender] >= ba);             \n       \n        uint256 BankerAmount = ba.mul(winMultiplePer).div(100);                  \n      \n        require(userTokenOf[currentBanker] >= BankerAmount);\n\n        betInfo memory bi = betInfo({\n                Player :  msg.sender,\n                BetNum : _betNum,\n                BetAmount : ba,\n                IsReturnAward: false                 \n        });\n\n        playerBetInfoOf[playNo] = bi;\n        userTokenOf[msg.sender] = userTokenOf[msg.sender].sub(ba);                     \n        userTokenOf[currentBanker] = userTokenOf[currentBanker].sub(BankerAmount);      \n        userTokenOf[this] = userTokenOf[this].add(ba.add(BankerAmount));                \n\n        emit OnPlay(gameID,  msg.sender,  _betNum,  ba, playNo, now, getEventId());\n\n        lastBlockNumber = block.number;    \n        playNo++;                          \n\n        if(now < donGameGiftLineTime){     \n            DonQuixoteToken.logPlaying(msg.sender);           \n        }\n        _result = true;\n    }\n\n   \n    \n    function lockBetInfo() public onlyBanker returns (bool _result) {                  \n        require(!gameOver);\n        require(now < gameEndTime);\n        require(!betInfoIsLocked);\n        betInfoIsLocked = true;\n        _result = true;\n    }\n\n    function uint8ToString(uint v) private pure returns (string)    \n    {\n        uint maxlength = 8;                    \n        bytes memory reversed = new bytes(maxlength);\n        uint i = 0;\n        while (v != 0) {\n            uint remainder = v % 10;\n            v = v.div(10);\n            reversed[i++] = byte(remainder.add(48));\n        }\n        bytes memory s = new bytes(i);         \n        for (uint j = 0; j < i; j++) {\n            s[j] = reversed[(i.sub(j)).sub(1)];         \n        }\n        string memory str = string(s);          \n        return str;                             \n    }\n\n    event OnOpenGameResult(uint indexed _gameID, address _banker, uint _gameResult, string _r1, bool  _result, uint  _code, uint _eventTime, uint eventId);\n\n    function openGameResult(uint _gameResult, string _r1) public onlyBanker  returns(bool _result){\n        _result =  _openGameResult( _gameResult,  _r1);\n    }\n    \n    function _openGameResult(uint _gameResult, string _r1) private  returns(bool _result){            \n       \n\t   _result = false;\n        require(betInfoIsLocked);          \n        require(!gameOver);\n        require(now <= gameEndTime);       \n\n        if(lastBlockNumber == block.number){                        \n            emit OnOpenGameResult(gameID, msg.sender, _gameResult, _r1,  false, 2, now, getEventId());         \n            return;\n        }\n\n        string memory gr = uint8ToString(_gameResult); \n        if(keccak256(gr, gameRandon2,  _r1) ==  gameEncryptedText){\n            if(_gameResult >= minNum && _gameResult <= maxNum){     \n                gameResult = _gameResult;\n                gameRandon1 = _r1;\n                gameEndPlayNo = playNo.sub(1); \n                for(uint i = gameBeginPlayNo; i < playNo; i++){     \n                    betInfo storage p = playerBetInfoOf[i];\n                    if(!p.IsReturnAward){   \n                        p.IsReturnAward = true;\n                        uint256 AllAmount = p.BetAmount.mul(winMultiplePer.add(100)).div(100);    \n                        if(p.BetNum == _gameResult){                                           \n                            userTokenOf[p.Player] = userTokenOf[p.Player].add(AllAmount);     \n                            userTokenOf[this] = userTokenOf[this].sub(AllAmount);               \n                        }else{                                                                  \n                            userTokenOf[currentBanker] = userTokenOf[currentBanker].add(AllAmount);\n                            userTokenOf[this] = userTokenOf[this].sub(AllAmount);               \n                            if(now < donGameGiftLineTime){  \n                                DonQuixoteToken.sendGameGift(p.Player);                                \n                            } \n                        }\n                    }\n                }\n                gameOver = true;\n                betInfoIsLocked = false;    \n                emit OnOpenGameResult(gameID, msg.sender,  _gameResult,  _r1, true, 0, now, getEventId());      \n                _result = true;\n                return;\n            }else{       \n                emit OnOpenGameResult(gameID, msg.sender,  _gameResult,  _r1,  false, 3, now, getEventId()); \n                return;                  \n            }\n        }else{           \n            emit OnOpenGameResult(gameID, msg.sender,  _gameResult,  _r1,  false,4, now, getEventId());\n            return;\n        }        \n    }\n\n    function openGameResultAndNewGame(uint _gameResult, string _r1, bytes32 _gameEncryptedText) public onlyBanker returns(bool _result){\n\t\tif(gameOver){\n            _result = true ;\n        }else{\n            _result = _openGameResult( _gameResult,  _r1);\n        }\n        if (_result){      \n            _result = _newGame( _gameEncryptedText);\n        }\n    }\n\n    function noOpenGameResult() public  returns(bool _result){         \n        _result = false;\n        require(!gameOver);       \n        require(gameEndTime < now); \n        if(lastBlockNumber == block.number){                           \n            emit OnOpenGameResult(gameID, msg.sender,0, '',false, 2, now, getEventId());\n            return;\n        }\n\n        lock(); \n\t\t\n        gameEndPlayNo = playNo - 1;         \n        for(uint i = gameBeginPlayNo; i < playNo; i++){                                \n            betInfo storage p = playerBetInfoOf[i];\n            if(!p.IsReturnAward){           \n                p.IsReturnAward = true;\n                uint256 AllAmount = p.BetAmount.mul(winMultiplePer.add(100)).div(100);     \n                userTokenOf[p.Player] = userTokenOf[p.Player].add(AllAmount);          \n                userTokenOf[this] = userTokenOf[this].sub(AllAmount);                  \n            }\n        }\n\n        gameOver = true;\n        if(betInfoIsLocked){\n            betInfoIsLocked = false;    \n        }\n        emit OnOpenGameResult(gameID, msg.sender,   0,  '',  true, 1, now, getEventId());\n        _result = true;\n\n        unLock();  \n    }\n\n    function  failUserRefund(uint _playNo) public returns (bool _result) {      \n        _result = false;\n        require(!gameOver);\n        require(gameEndTime.add(30 days) < now);          \n\n        betInfo storage p = playerBetInfoOf[_playNo];   \n        require(p.Player == msg.sender);               \n        \n        if(!p.IsReturnAward && p.BetNum > 0){            \n            p.IsReturnAward = true;\n            uint256 ToUser = p.BetAmount;   \n            uint256 ToBanker = p.BetAmount.mul(winMultiplePer).div(100);  \n            userTokenOf[this] = userTokenOf[this].sub(ToUser.add(ToBanker));              \n            userTokenOf[p.Player] = userTokenOf[p.Player].add(ToUser);         \n            userTokenOf[currentBanker] = userTokenOf[currentBanker].add(ToBanker);\n            _result = true;                                  \n        }\n    }\n\n    function transEther() public onlyOwner()    \n    {\n        msg.sender.transfer(address(this).balance);\n    }\n    \n    function () public payable {        \n      \n    }\n\n\n}", "debug": "calldata_SelectOne_4 + calldata_SelectOne_4: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_7: 0x0\ncaller: 0x0\ncalldata_SelectOne_0: 0x26c4fa3d00000000000000000000000000000000000000000000000000000000\ncalldatasize_SelectOne: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setOfficialGameUrl(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/33/0x56c95c0a4e3c667e30ef383dcaffa7d35b64e20a.sol", "function": "setOfficialGameUrl(string)", "lineno": 133, "title": "Integer Overflow ", "type": "Warning"}, {"address": 17715, "code": "nt  public winMultiplePer = 90;     \n    \n    uint  public constant maxPlayerNum = 100;      \n    uint public gameTime; \n    uint256 public gameMaxBetAmount;    \n    uint256 public gameMinBetAmount;    \n\t\n\tfunction SelectOne(uint _maxNum, uint  _gameTime, uint256 _gameMinBetAmount, uint256 _gameMaxBetAmount,uint _winMultiplePer, string _gameName,address _DonQuixoteToken)  public {\n        require(_gameMinBetAmount >= 0);\n        require(_gameMaxBetAmount > 0);\n        require(_gameMaxBetAmount >= _gameMinBetAmount);\n\t\trequire(_maxNum < 10000);              \n        require(1 < _maxNum);                   \n        require(_winMultiplePer < _maxNum.mul(100));      \n        \n\t\tgameMinBetAmount = _gameMinBetAmount;\n        gameMaxBetAmount = _gameMaxBetAmount;\n        gameTime = _gameTime;\n        maxNum = _maxNum;                      \n        winMultiplePer = _winMultiplePer;       \n        owner = msg.sender;             \n        gameName = _gameName;           \n\n        require(_DonQuixoteToken != 0x0);\n        DonQuixoteToken = IDonQuixoteToken(_DonQuixoteToken);\n    }\n\n    uint public lastBlockNumber = 0;            \n    bool public betInfoIsLocked = false;       \n    address public auction;             \n    \n\n    function setAuction(address _newAuction) public onlyOwner{\n        require(_newAuction != 0x0);\n        auction = _newAuction;\n    }\n    modifier onlyAuction {             \n        require(msg.sender == auction);\n        _;\n    }\n\n    function canSetBanker() public view returns (bool _result){\n        _result =  bankerEndTime <= now && gameOver;\n    }\n\t\n    modifier onlyBanker {               \n        require(msg.sender == currentBanker);\n        require(bankerBeginTime <= now);\n        require(now < bankerEndTime);     \n        _;\n    }\n\n    event OnSetNewBanker(address _caller, address _banker, uint _beginTime, uint _endTime, uint _code, uint _eventTime, uint eventId);\n\n    function setBanker(address _banker, uint _beginTime, uint _endTime) public onlyAuction returns(bool _result)\n\t{\n        _result = false;\n        require(_banker != 0x0);\n        if(now < bankerEndTime){        \n            emit OnSetNewBanker(msg.sender, _banker,  _beginTime,  _endTime, 1, now, getEventId());\n            return;\n        }\n        if(!gameOver){                  \n            emit OnSetNewBanker(msg.sender, _banker,  _beginTime,  _endTime, 2, now, getEventId());\n            return;\n        }\n        if(_beginTime > now){               \n            emit OnSetNewBanker(msg.sender, _banker,  _beginTime,  _endTime, 3, now, getEventId()); \n            return;\n        }\n        if(_endTime <= now){\n            emit OnSetNewBanker(msg.sender, _banker,  _beginTime,  _endTime, 4, now, getEventId());\n            return;\n        }\n\t    if(now < donGameGiftLineTime){\n            DonQuixoteToken.logPlaying(_banker);\n        }\n        currentBanker = _banker;\n        bankerBeginTime = _beginTime;\n        bankerEndTime = _endTime;\n        emit OnSetNewBanker(msg.sender, _banker,  _beginTime,  _endTime, 0 , now, getEventId());\n        _result = true;\n    }\n \n    uint public playNo = 1;             \n    uint public gameID = 0;             \n    uint public gameBeginPlayNo;        \n    uint public gameEndPlayNo;          \n    bytes32 public gameEncryptedText;  \n    uint public gameResult;            \n    string public gameRandon1;          \n    string public constant gameRandon2 = 'ChinasNewGovernmentBracesforTrump';   \n    uint  public gameBeginTime;        \n    uint  public gameEndTime;           \n    bool public gameOver = true;       \n    uint public donGameGiftLineTime = now.add(90 days);  \n    \n\t\n    event OnNewGame(uint _gameID, address _banker, bytes32 _gameEncryptedText, uint  _gameBeginTime,  uint  _gameEndTime, uint _eventTime, uint _eventId);\n\n    function newGame(bytes32 _gameEncryptedText) public onlyBanker returns(bool _result)               \n    {\n        _result = _newGame( _gameEncryptedText);\n    }\n\n    function _newGame(bytes32 _gameEncryptedText) private  returns(bool _result)       \n    {\n        _result = false;\n        require(gameOver); \n        require(bankerBeginTime < now);       \n        require(now.add(gameTime) <= bankerEndTime);    \n        gameID++;                           \n        currentBanker = msg.sender;\n        gameEncryptedText = _gameEncryptedText;\n        gameRandon1 = '';          \n        gameBeginTime = now;                \n        gameEndTime = now.add(gameTime);\n        gameBeginPlayNo = playNo;          \n        gameEndPlayNo = 0;                 \n        gameResult = 0;  \n        gameOver = false;\n        \n        emit OnNewGame(gameID, msg.sender, _gameEncryptedText, now, now.add(gameTime), now, getEventId());\n        _result = true;\n    }\n    \n    struct betInfo              \n    {\n        address Player;\n        uint BetNum;            \n        uint256 BetAmount;      \n        bool IsReturnAward;     \n    }\n\n    mapping (uint => betInfo) public playerBetInfoOf;              \n    event OnPlay(uint indexed _gameID, address indexed _player, uint _betNum, uint256 _betAmount, uint _playNo, uint _eventTime, uint _eventId);\n\n    function play(uint _betNum, uint256 _betAmount) public  returns(bool _result){      \n        _result = _play(_betNum, _betAmount);\n    }\n\n    function _play(uint _betNum, uint256 _betAmount) private  returns(bool _result){            \n        _result = false;\n        require(!gameOver);\n        require(!betInfoIsLocked);                         \n        require(now < gameEndTime);\n        require(playNo.sub(gameBeginPlayNo) <= maxPlayerNum); \n        require(minNum <= _betNum && _betNum <= maxNum);    \n        require(msg.sender != currentBanker);                \n                   \n        uint256 ba = _betAmount;\n        if (ba > gameMaxBetAmount){                       \n            ba = gameMaxBetAmount;\n        }\n        require(ba >= gameMinBetAmount);                   \n\n        if(userTokenOf[msg.sender] < ba){                                       \n            depositToken(ba.sub(userTokenOf[msg.sender]));                    \n        }\n        require(userTokenOf[msg.sender] >= ba);             \n       \n        uint256 BankerAmount = ba.mul(winMultiplePer).div(100);                  \n      \n        require(userTokenOf[currentBanker] >= BankerAmount);\n\n        betInfo memory bi = betInfo({\n                Player :  msg.sender,\n                BetNum : _betNum,\n                BetAmount : ba,\n                IsReturnAward: false                 \n        });\n\n        playerBetInfoOf[playNo] = bi;\n        userTokenOf[msg.sender] = userTokenOf[msg.sender].sub(ba);                     \n        userTokenOf[currentBanker] = userTokenOf[currentBanker].sub(BankerAmount);      \n        userTokenOf[this] = userTokenOf[this].add(ba.add(BankerAmount));                \n\n        emit OnPlay(gameID,  msg.sender,  _betNum,  ba, playNo, now, getEventId());\n\n        lastBlockNumber = block.number;    \n        playNo++;                          \n\n        if(now < donGameGiftLineTime){     \n            DonQuixoteToken.logPlaying(msg.sender);           \n        }\n        _result = true;\n    }\n\n   \n    \n    function lockBetInfo() public onlyBanker returns (bool _result) {                  \n        require(!gameOver);\n        require(now < gameEndTime);\n        require(!betInfoIsLocked);\n        betInfoIsLocked = true;\n        _result = true;\n    }\n\n    function uint8ToString(uint v) private pure returns (string)    \n    {\n        uint maxlength = 8;                    \n        bytes memory reversed = new bytes(maxlength);\n        uint i = 0;\n        while (v != 0) {\n            uint remainder = v % 10;\n            v = v.div(10);\n            reversed[i++] = byte(remainder.add(48));\n        }\n        bytes memory s = new bytes(i);         \n        for (uint j = 0; j < i; j++) {\n            s[j] = reversed[(i.sub(j)).sub(1)];         \n        }\n        string memory str = string(s);          \n        return str;                             \n    }\n\n    event OnOpenGameResult(uint indexed _gameID, address _banker, uint _gameResult, string _r1, bool  _result, uint  _code, uint _eventTime, uint eventId);\n\n    function openGameResult(uint _gameResult, string _r1) public onlyBanker  returns(bool _result){\n        _result =  _openGameResult( _gameResult,  _r1);\n    }\n    \n    function _openGameResult(uint _gameResult, string _r1) private  returns(bool _result){            \n       \n\t   _result = false;\n        require(betInfoIsLocked);          \n        require(!gameOver);\n        require(now <= gameEndTime);       \n\n        if(lastBlockNumber == block.number){                        \n            emit OnOpenGameResult(gameID, msg.sender, _gameResult, _r1,  false, 2, now, getEventId());         \n            return;\n        }\n\n        string memory gr = uint8ToString(_gameResult); \n        if(keccak256(gr, gameRandon2,  _r1) ==  gameEncryptedText){\n            if(_gameResult >= minNum && _gameResult <= maxNum){     \n                gameResult = _gameResult;\n                gameRandon1 = _r1;\n                gameEndPlayNo = playNo.sub(1); \n                for(uint i = gameBeginPlayNo; i < playNo; i++){     \n                    betInfo storage p = playerBetInfoOf[i];\n                    if(!p.IsReturnAward){   \n                        p.IsReturnAward = true;\n                        uint256 AllAmount = p.BetAmount.mul(winMultiplePer.add(100)).div(100);    \n                        if(p.BetNum == _gameResult){                                           \n                            userTokenOf[p.Player] = userTokenOf[p.Player].add(AllAmount);     \n                            userTokenOf[this] = userTokenOf[this].sub(AllAmount);               \n                        }else{                                                                  \n                            userTokenOf[currentBanker] = userTokenOf[currentBanker].add(AllAmount);\n                            userTokenOf[this] = userTokenOf[this].sub(AllAmount);               \n                            if(now < donGameGiftLineTime){  \n                                DonQuixoteToken.sendGameGift(p.Player);                                \n                            } \n                        }\n                    }\n                }\n                gameOver = true;\n                betInfoIsLocked = false;    \n                emit OnOpenGameResult(gameID, msg.sender,  _gameResult,  _r1, true, 0, now, getEventId());      \n                _result = true;\n                return;\n            }else{       \n                emit OnOpenGameResult(gameID, msg.sender,  _gameResult,  _r1,  false, 3, now, getEventId()); \n                return;                  \n            }\n        }else{           \n            emit OnOpenGameResult(gameID, msg.sender,  _gameResult,  _r1,  false,4, now, getEventId());\n            return;\n        }        \n    }\n\n    function openGameResultAndNewGame(uint _gameResult, string _r1, bytes32 _gameEncryptedText) public onlyBanker returns(bool _result){\n\t\tif(gameOver){\n            _result = true ;\n        }else{\n            _result = _openGameResult( _gameResult,  _r1);\n        }\n        if (_result){      \n            _result = _newGame( _gameEncryptedText);\n        }\n    }\n\n    function noOpenGameResult() public  returns(bool _result){         \n        _result = false;\n        require(!gameOver);       \n        require(gameEndTime < now); \n        if(lastBlockNumber == block.number){                           \n            emit OnOpenGameResult(gameID, msg.sender,0, '',false, 2, now, getEventId());\n            return;\n        }\n\n        lock(); \n\t\t\n        gameEndPlayNo = playNo - 1;         \n        for(uint i = gameBeginPlayNo; i < playNo; i++){                                \n            betInfo storage p = playerBetInfoOf[i];\n            if(!p.IsReturnAward){           \n                p.IsReturnAward = true;\n                uint256 AllAmount = p.BetAmount.mul(winMultiplePer.add(100)).div(100);     \n                userTokenOf[p.Player] = userTokenOf[p.Player].add(AllAmount);          \n                userTokenOf[this] = userTokenOf[this].sub(AllAmount);                  \n            }\n        }\n\n        gameOver = true;\n        if(betInfoIsLocked){\n            betInfoIsLocked = false;    \n        }\n        emit OnOpenGameResult(gameID, msg.sender,   0,  '',  true, 1, now, getEventId());\n        _result = true;\n\n        unLock();  \n    }\n\n    function  failUserRefund(uint _playNo) public returns (bool _result) {      \n        _result = false;\n        require(!gameOver);\n        require(gameEndTime.add(30 days) < now);          \n\n        betInfo storage p = playerBetInfoOf[_playNo];   \n        require(p.Player == msg.sender);               \n        \n        if(!p.IsReturnAward && p.BetNum > 0){            \n            p.IsReturnAward = true;\n            uint256 ToUser = p.BetAmount;   \n            uint256 ToBanker = p.BetAmount.mul(winMultiplePer).div(100);  \n            userTokenOf[this] = userTokenOf[this].sub(ToUser.add(ToBanker));              \n            userTokenOf[p.Player] = userTokenOf[p.Player].add(ToUser);         \n            userTokenOf[currentBanker] = userTokenOf[currentBanker].add(ToBanker);\n            _result = true;                                  \n        }\n    }\n\n    function transEther() public onlyOwner()    \n    {\n        msg.sender.transfer(address(this).balance);\n    }\n    \n    function () public payable {        \n      \n    }\n\n\n}", "debug": "calldata_SelectOne_4 + calldata_SelectOne_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_7: 0x0\ncaller: 0x0\ncalldata_SelectOne_0: 0x26c4fa3d00000000000000000000000000000000000000000000000000000000\ncalldatasize_SelectOne: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setOfficialGameUrl(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/33/0x56c95c0a4e3c667e30ef383dcaffa7d35b64e20a.sol", "function": "setOfficialGameUrl(string)", "lineno": 133, "title": "Integer Overflow ", "type": "Warning"}], "success": true}