{
  "contract": "0x93ebbf10084680bae8afdb05955bf1c0dd65948a",
  "tool": "mythril",
  "start": 1563763928.3315487,
  "end": 1563764206.2297945,
  "duration": 277.8982458114624,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 813,
        "code": " that important to you: go ahead.\n\t\t\tif (remainder > 0 && now % ((10000 / ethartArtReward) - 1) <= remainder) {ethartArtAwarded++;}\n\t\t\tpiecesOwned[registrar] = ethartArtAwarded;\n\t\t\tpiecesOwned[owner] = editionSize - ethartArtAwarded;\n\t\t\t}\n\t\telse {throw;}\n\t\t}\n\n\tfunction transfer(address _to, uint256 _amount) notLocked(msg.sender, _amount) onlyPayloadSize(2 * 32) returns (bool success) {\n\t\tif (piecesOwned[msg.sender] >= _amount \n\t\t\t&& _amount > 0\n\t\t\t&& piecesOwned[_to] + _amount > piecesOwned[_to]\n\t\t\t// use burn() instead\n\t\t\t&& _to != 0x0)\n\t\t\t{\n\t\t\tpiecesOwned[msg.sender] -= _amount",
        "debug": "calldata_Interface_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Interface_0: 0x15336f8000000000000000000000000000000000000000000000000000000000\ncalldatasize_Interface: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x15336f80`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/43/0x93ebbf10084680bae8afdb05955bf1c0dd65948a.sol",
        "function": "_function_0x15336f80",
        "lineno": 321,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 3706,
        "code": "\t\t\tpiecesOwned[owner] =",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_5: 0x8\ncalldata_Interface_4 + calldata_Interface_4: 0x0\nstorage_16: 0x0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_Interface_0: 0x15336f8000000000000000000000000000000000000000000000000000000000\ncalldatasize_Interface: 0x4\nstorage_22: 0x0\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/43/0x93ebbf10084680bae8afdb05955bf1c0dd65948a.sol",
        "function": "_function_0x15336f80",
        "lineno": 324,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 3719,
        "code": "artArtAwarded;\n\t\t\tpiecesOwned[owner] = ",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_22: 0x400000000000000000000000000000001\nstorage_5: 0x0\ncalldata_Interface_4 + calldata_Interface_4: 0x0\nstorage_16: 0x0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_Interface_0: 0x15336f8000000000000000000000000000000000000000000000000000000000\ncalldatasize_Interface: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/43/0x93ebbf10084680bae8afdb05955bf1c0dd65948a.sol",
        "function": "_function_0x15336f80",
        "lineno": 323,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 4807,
        "code": ";}\n\t\t}\n\n\t// Allow _spender",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Interface_32_+_4: 0x5e98bf06b4444c10eeb99760f070e5c16c11860244080011dd9290291afd2e8f\ncalldata_Interface_32 + 36: 0xa4f83f6ec7fd5af811cad13d07026471efbe8b6c020000085b3293d1aa9e2e8b\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Interface_4: 0xc8985cf0c4dc4679910470e005818425d7c01e81340000004341d3b242c05f4b\ncalldatasize_Interface: 0xe4\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xa4f83f6ec7fd5af811cad13d07026471efbe8b6c020000085b3293d1aa9e2e8b\nstorage_9: 0x0\ncalldata_Interface_4: 0x0\ncalldata_Interface_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `transferFrom(address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/43/0x93ebbf10084680bae8afdb05955bf1c0dd65948a.sol",
        "function": "transferFrom(address,address,uint256)",
        "lineno": 367,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 8062,
        "code": "e -= _value;\n\t\t\tBurn(_",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xfffffffffffffffffffffffffffffffbfffffffffffffffffffffffff0000000\ncalldata_Interface_4: 0x1fffffb\nstorage_2: 0x1fffffa\nstorage_9: 0x0\ncaller: 0x0\ncalldata_Interface_0: 0x42966c6800000000000000000000000000000000000000000000000000000000\ncalldatasize_Interface: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `burn(uint256)`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_chucks/43/0x93ebbf10084680bae8afdb05955bf1c0dd65948a.sol",
        "function": "burn(uint256)",
        "lineno": 398,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 14642,
        "code": "1. Introduction\n\nThis text is a plain English translation of the artwork smart contract's 'COSIMA' programming logic and represent its terms of use (terms). This plain English translation is a best effort only and while all reasonable precautions - including significant bug bounties - have been taken to ensure that the smart contract will behave in the exact way outlined in these terms, mistakes do happen (see The DAO) which may result in unexpected and unintended contract behaviour which may include the total loss of invested funds (Ether), other tokens sent to it as well as accessibility of the contract itself. Due to the nature of smart contracts, once it is deployed on the blockchain it becomes immutably imbedded in it which means that any bugs and/or exploits discovered after deployment are unfixable. Should the code behave differently than outlined in these terms, the code - by the very nature of smart contracts - takes precedent over the terms. By deploying, interacting or otherwise using the smart contract you acknowledge and accept all associated risks while at the same time waive all rights to hold the creator of the smart contract, the artists who deployed the smart contract, its current owner as well as any other parties responsible for potential damages suffered by or caused by you through your interaction with the smart contract to yourself or others. No backsies.\n\n2. Contract deployment\n\nThis smart contract enables its owner to issue limited edition pieces of art (pieces) that are cryptographically embedded in the Ethereum blockchain. Every piece can be owned, offered for sale, sold, bought, transferred and burned. The contract accepts bids from interested buyers and allows for the cancelation of bids as well as the cancelation of pieces offered for sale and filling of bids. In addition the owner of the contract as well as Ethart will earn a commission for every future sales of pieces irrespective of who owns, buys or sells them using the contract.\n\nThe contract creation costs approximately 2.4 Mgas - assuming a gas price of 20 Gwei, contract creation will cost ~0.05 ETH or about $15 (@$300/ETH) on the Ethereum main net. If contract creation is not urgent and Ethereum's pending transactions pool is not congested gas prices can be lowered to ~4 Gwei which would reduce the cost of deployment to ~$3 per artwork at current prices. Please make sure you understand the implications of gas cost, gas price and Ether price before you engage with this contract as the price of Ether and gas prices accepted by miners can and do change on a daily basis.\n\nDuring creation the contract asks for the following parameters:\n\n\t- The SHA256 hash of your piece (the cryptographic link of your artwork to the Ethereum blockchain)\n\t- Edition size (the maximum number of pieces you plan to issue)\n\t- Title (the title or name of your artwork, if any)\n\t- The link to your file (if any)\n\t- Custom text (if any)\n\t- The owner's commission in basis points (i.e. 1/100th of a percent)\n\nSHA256 hash: A SHA256 hash is a fixed length cryptographic digest of a file. On Mac and Linux it can be calculated by opening a terminal window and typing \"openssl sha -sha256\" followed by a space and the filename (i.e. \"openssl sha -sha256 <FILENAME>\") one wants to calculate the hash for. An online tool that serves the same purpose can be found at http://hash.online-convert.com/sha256-generator. By the nature of the cryptographic math the resulting hash is a) a unique fingerprint of the input file which can be independently verified by whomever has access to the original file, b) different for (almost) every file as long as at least one bit is different and c) almost impossible to reverse, meaning you can calculate a SHA256 hash from a file very easily but you can not generate the file from the SHA256 hash. Embedding the SHA256 hash in the contract at it's deployment therefore proofs that the limited edition pieces controlled by the smart contract's logic are linked to a particular file: the artwork.\n\nEdition size: The maximum number of pieces you wish your artwork to have.\n\nTitle: the title is stored as a public string in the contract\n\nFile link: So people can independently verify that a particular file is associated with a particular instance of a smart contract you can here specify the publicly accessible link to the file. Note that providing a link is not mandatory and some artists may decide to only provide the SHA256 hash and reveal the actual file associated with it at a later point in time or never.\n\nCustom text: This field can be whatever you want it to be. One use case could be a set of custom attributes for limited edition collectible playing cards. In this case you would format your game card attributes in a standard manner for later use e.g. Strength, Constitution, Dexterity, Intelligence, Wisdom as \"12,8,6,9,3\" which a later application can then read and interpreted according to your game's rules.\n\nOwner's commission: the account that deploys/ed the smart contract can set a commission for future sales that will be paid out to the current owner of smart contract. The commission is specified in basis points where 1 basis point equals 0.01%. The commission must be greater than 0 and lower than 10000 - Ethart's reward. If the owner wants to receive 5% for all future sales for example the commission will have to be set as 500.\n\nAt deployment the owner of the smart contract will be set as the account that deployed it. Please make sure to carefully note down your account details including your address, private key, password, JSON file etc and keep it safe and secret. Remember: whoever has access to this information has access to the contract and all the funds and rights associated with it. If you loose this information it is almost certainly going to be lost forever and your funds and artwork with it. Make at least one backup and keep it in a safe location. After contract deployment it is important for you to carefully note down the contract creation transaction receipt number, contract address and ABI for later reference. You and others will require this information to interact with the contract once it is live. If you created an artwork and lost your artwork's contract address you can look up the sha256 hash of your artwork in the registrar's artwok registry which will return your artwork's contract address to you.\n\nThe artwork contract acts as it's own decentralised exchange with an on chain order book of the lowest ask and highest bid for a piece and allows for trustless trade of the pieces of art via the Ethereum blockchain.\n\n3. Providing a proof\n\nAfter deployment and before the first pieces can be bought or sold the owner has to provide a proof. This proof demonstrates that the artwork was in fact deployed by the artist. The proof can be in the form of a link to a blog post, a tweet or press release, providing at the very least the artwork's contract address or contract creation transaction number.\n\n4. Ethart commission\n\nThe fee for letting you deploy your artworks is set by the registrar contract and will be between 0 and 10% of the edition size as well as between 0 and 10% of future revenues. Please make sure to check these numbers before you deploy your artwork's contarct as these values will be fixed after contract deployment. After you have provided the proof, the contract issues a percent of the edition size to Ethart automatically as following:\n\n- 1 piece for every (10000 / ethartArtReward) pieces increase in edition size\n- a (remainder / (10000 / ethartArtReward)) chance of an additional piece\n\nExample: Say you create a 100 piece limited edition artwork and the ethartArtReward is set as 250 (2.5%). The contract will then issue at least 2 pieces to Ethart. In addition there will be a 20 in 40 (i.e. 50%) chance that one additional piece will be issued to Ethart. In other words, if you create a limited edition of 1 piece there is always a chance that after you provide the proof this one piece will be transferred to Ethart. To avoid disappointment we therefore recommend a minimum edition size of 2 - then you are guaranteed to keep at least one piece with an additional small chance of loosing the other. The way the math works out Ethart will on average retain ethartArtReward in basis points of all pieces.\n\nThe pieces transferred to Ethart can not be sold or transferred by Ethart for a minimum of one year (31,556,926 seconds) giving you plenty of time to monopolise the market.\n\n5. Changing the owner\n\nThe current owner of the artwork contract can transfer ownership of the contract to another account.\n\n6. Transferring pieces\n\nYour artworks is in fact an ERC20 token (https://theethereum.wiki/w/index.php/ERC20_Token_Standard) and supports all ERC20 features. Pieces can be transferred to other addresses (as long as they are not being offered for sale) by their respective owners. Make sure that pieces are only being transferred to accounts that have access to their private keys. Pieces send to exchanges or other accounts that do not have access to their private keys will be lost - most likely forever.\n\n7. Offering a piece for sale\n\nThe owner of a piece can offer it for sale. The price for which it is offered (the ask) has to be lower than the current lowest ask. Once a piece is offered for sale by its owner for a lower price than the currently lowest ask it will become the lowest ask and replace the previous lowest ask. The sale price has to be specified in wei (1000000000000000000 wei = 1 ETH).\n\n8. Canceling a sale\n\nThe owner of a piece offered for sale can cancel the sale 24 hours after having offered the piece for sale. The 24 hour limited is intended to prevent owners to offer a piece at an artificially low price, displacing the currently lowest ask and then immediately canceling the sale.\n\n10. Buying a piece\n\nAs long as a piece is being offered for sale, anyone can buy it as long as the buyer sends at least the current lowest ask price with the buy order. Any buy orders that do not send at least the current lowest ask price will be rejects. All the funds send with a buy order will be paid out to the seller of the piece, the contract owner as well as Ethart respectively and in proportion to the commission rules outlined above. There will be no refunds for funds sent in excess of the lowest ask price. Once a piece has been sold the lowest ask will be reset and the next piece offered for sale will become the lowest ask if any. Patrons that buy pieces via the artwork\u2019s smart contract will be issuedpatronRewardMultiplier Patron tokens for every Ether spend in the transaction.\n\n11. Placing a bid\n\nBuyers can place bids in ether. Bids have to be higher than the currently highest bid. Placing a bid that is higher than the current lowest ask price will result in the bidder instantly buying the piece offered by the lowest ask seller for the bid amount.\n\n12. Cancelling a bid\n\nBids can be canceled by the buyer 24 hours after they have been placed. The 24 hour limited is intended to prevent buyers from placing an artificially high bid, displacing the currently highest bid and then immediately canceling the bid.\n\n13. Filling a bid\n\nBids can be filled by anyone who owns a piece.\n\n14. Burning a piece\n\nThe owner of a piece can burn it, removing it permanently from the pool of available pieces and thereby reducing the edition size. Artists may choose to do so to increase the value of the remaining pieces or for any other reason.\n\n15. Referral reward\n\nThe referrer of an artist receives referrerReward basis points of ethartRevenueReward as their referral reward for every piece sold using this contract. The referrer has to be set by the artist prior to creating their first artwork.\n\n16. Withdrawing funds\n\nFor security reasons Ethart contracts' handling of ether transfers have been implemented following the best practise pull payment method from Open Zeppelin (https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/payment/PullPayment.sol). This means that all funds used in placing bids and buying pieces are being transfered to the registrar contract. Sellers, artists, owners, referrer and buyers canceling their bids or those who are being outbid can claim their funds by executing the withdrawPayments method of the registrar contract. Not only does this mitigate several security concerns but at the same time provides a single location for everyone to claim their funds in one transaction.\n\n17. Standing bug bounty\n\nThe factory contract this contract has been spawned from has a standing bug bounty of 1,000 Patrons for all practical and demonstrable exploits that cause the unintentional loss of ether and/or tokens. If you feel you have discovered an exploit path or vulnerability please contact us at http://ethart.com and claim your reward.\n\n\t(c) Stefan Pernar 2017 - all rights reserved\n\t(c) ERC20 functions BokkyPooBah 2017. The MIT Licence.\n\n*/\n\n/* Public variables */\n\taddress public owner;\t\t\t\t\t\t// Contract owner.\n\tbytes32 public SHA256ofArtwork;\t\t\t\t// sha256 hash of the artwork.\n\tuint256 public editionSize;\t\t\t\t\t// The edition size of the artwork.\n\tstring public title;\t\t\t\t\t\t// The title of the artwork.\n\tstring public fileLink;\t\t\t\t\t\t// The link to the file of the artwork.\n\tstring public proofLink;\t\t\t\t\t// Link to the creation proof by the artist -> this has to be done after contract creation\n\tstring public customText;\t\t\t\t\t// Custom text\n\tuint256 public ownerCommission;\t\t\t\t// Percent given to the contract owner for every sale - must be >=0 && <=975 1000 = 100%.\n\t\n\tuint256 public lowestAskPrice;\t\t\t\t// The lowest price an owner of a piece is willing to sell it for.\n\taddress public lowestAskAddress;\t\t\t// The address of the lowest ask.\n\tuint256 public lowestAskTime;\t\t\t\t// The time by which the ask can be withdrawn.\n\tbool public pieceForSale;\t\t\t\t\t// Is a piece for sale?\n\n\tuint256 public highestBidPrice;\t\t\t\t// The highest price a buyer is willing to pay for a piece.\n\taddress public highestBidAddress;\t\t\t// The address of the highest bidder\n\tuint256 public highestBidTime;\t\t\t\t// The time by which the bid can be withdrawn\n\tuint public activationTime;\t\t\t\t\t// Time this contract has been activated.\n\tbool public pieceWanted;\t\t\t\t\t// Is a buyer interested in a piece?\n\n\t/* Events */\n\t\n\t// Informs watchers of the contract when a new lowest ask price has been set. (price, seller)\n\tevent NewLowestAsk (uint256 price, address seller);\n\t\n\t// Informs watchers of the contract when a new highest bid price has been placed. (price, bidder)\n\tevent NewHighestBid (uint256 price, address bidder);\n\t\n\t// Informs watchers of the contract when a piece has been transferred. (amount, from, to)\n\tevent PieceTransferred (uint256 amount, address from, address to);\n\t\n\t// Informs watchers of the contract when a piece has been sold. (from, to, price)\n\tevent PieceSold (address from, address to, uint256 price);\n\n\tevent Transfer (address indexed _from, address indexed _to, uint256 _value);\n\tevent Approval (address indexed _owner, address indexed _spender, uint256 _value);\n\tevent Burn (address indexed _owner, uint256 _amount);\n\n\t/* Other variables */\n\t\n\t// Has the proof been set yet?\n\tbool public proofSet;\n\t\n\t// # of pieces awarded to Ethart.\n\tuint256 public ethartArtAwarded;\n\n\t// Maps the number of pieces owned by an address\n\tmapping (address => uint256) public piecesOwned;\n\t\n\t// Used in burnFrom and transferFrom\n \tmapping (address => mapping (address => uint256)) allowed;\n\t\n\t// set after deployment of Registrar contract\n    address registrar = 0x5f68698245e8c8949450E68B8BD8acef37faaE7D;\n\t\n\t// Ethart reward variables - fixed after contract creation\n\tuint256 public ethartRevenueReward;\n\tuint256 public ethartArtReward;\n\taddress public referrer;\n\t\n\t// Referrer receives referrerReward basis points of ethartRevenueReward\n\tuint256 public referrerReward;\n\n\t// Constructor\n\tfunction Artwork (\n\t\tbytes32 _SHA256ofArtwork,\n\t\tuint256 _editionSize,\n\t\tstring _title,\n\t\tstring _fileLink,\n\t\tstring _customText,\n\t\tuint256 _ownerCommission,\n\t\taddress _owner\n\t) {\n\t\tif (_ownerCommission > (10000 - ethartRevenueReward)) {throw;}\n\t\tInterface a = Interface(registrar);\n\t\tethartRevenueReward = a.getEthartRevenueReward();\n\t\tethartArtReward = a.getEthartArtReward();\n\t\treferrer = a.getReferrer (_owner);\n\t\treferrerReward = a.getReferrerReward ();\n\t\t// Owner is set as the address spawning the contract\n\t\towner = _owner;\n\t\tSHA256ofArtwork = _SHA256ofArtwork;\n\t\teditionSize = _editionSize;\n\t\ttitle = _title;\n\t\tfileLink = _fileLink;\n\t\tcustomText = _customText;\n\t\townerCommission = _ownerCommission;\n\t\tactivationTime = now;\t\n\t}\n\n\tmodifier onlyBy(address _account)\n\t{\n\t\trequire(msg.sender == _account);\n\t\t_;\n\t}\n\n\t// The registrar can execute certain functions only after one year\n\tmodifier ethArtOnlyAfterOneYear()\n\t{\n\t\trequire(msg.sender != registrar || now > activationTime + 31536000);\n\t\t_;\n\t}\n\n\t// Sales / approvals have to be cancelled first for certain functions\n\tmodifier notLocked(address _owner, uint256 _amount)\n\t{\n\t\trequire(_owner != lowestAskAddress || piecesOwned[_owner] > _amount);\n\t\t_;\n\t}\n\n\t// Mitigating ERC20 short address attacks (http://vessenes.com/the-erc20-short-address-attack-explained/)\n\tmodifier onlyPayloadSize(uint size)\n\t{\n\t\trequire(msg.data.length >= size + 4);\n\t\t_;\n\t}\n\n\t// allows the current owner to assign a new owner\n\tfunction changeOwner (address newOwner) onlyBy (owner) {\n\t\towner = newOwner;\n\t\t}\n\n\tfunction setProof (string _proofLink) onlyBy (owner) {\n\t\tif (!proofSet) {\n\t\t\tuint256 remainder;\n\t\t\tproofLink = _proofLink;\n\t\t\tproofSet = true;\n\t\t\tremainder = editionSize % (10000 / ethartArtReward);\n\t\t\tethartArtAwarded = (editionSize - remainder) / (10000 / ethartArtReward);\n\t\t\t// Yes - this is gameable - if it is that important to you: go ahead.\n\t\t\tif (remainder > 0 && now % ((10000 / ethartArtReward) - 1) <= remainder) {ethartArtAwarded++;}\n\t\t\tpiecesOwned[registrar] = ethartArtAwarded;\n\t\t\tpiecesOwned[owner] = editionSize - ethartArtAwarded;\n\t\t\t}\n\t\telse {throw;}\n\t\t}\n\n\tfunction transfer(address _to, uint256 _amount) notLocked(msg.sender, _amount) onlyPayloadSize(2 * 32) returns (bool success) {\n\t\tif (piecesOwned[msg.sender] >= _amount \n\t\t\t&& _amount > 0\n\t\t\t&& piecesOwned[_to] + _amount > piecesOwned[_to]\n\t\t\t// use burn() instead\n\t\t\t&& _to != 0x0)\n\t\t\t{\n\t\t\tpiecesOwned[msg.sender] -= _amount;\n\t\t\tpiecesOwned[_to] += _amount;\n\t\t\tTransfer(msg.sender, _to, _amount);\n\t\t\treturn true;\n\t\t\t}\n\t\t\telse { return false;}\n \t\t }\n\n\tfunction totalSupply() constant returns (uint256 totalSupply) {\n\t\ttotalSupply = editionSize;\n\t\t}\n\n\tfunction balanceOf(address _owner) constant returns (uint256 balance) {\n \t\treturn piecesOwned[_owner];\n\t\t}\n\n\tfunction transferFrom(address _from, address _to, uint256 _amount) notLocked(_from, _amount) onlyPayloadSize(3 * 32)returns (bool success)\n\t\t{\n\t\t\tif (piecesOwned[_from] >= _amount\n\t\t\t\t&& allowed[_from][msg.sender] >= _amount\n\t\t\t\t&& _amount > 0\n\t\t\t\t&& piecesOwned[_to] + _amount > piecesOwned[_to]\n\t\t\t\t// use burn() instead\n\t\t\t\t&& _to != 0x0\n\t\t\t\t&& (_from != lowestAskAddress || piecesOwned[_from] > _amount))\n\t\t\t\t\t{\n\t\t\t\t\tpiecesOwned[_from] -= _amount;\n\t\t\t\t\tallowed[_from][msg.sender] -= _amount;\n\t\t\t\t\tpiecesOwned[_to] += _amount;\n\t\t\t\t\tTransfer(_from, _to, _amount);\n\t\t\t\t\treturn true;\n\t\t\t\t\t} else {return false;}\n\t\t}\n\n\t// Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n\t// If this function is called again it overwrites the current allowance with _value.\n\t// To be extra secure set allowance to 0 and check that none of our allowance was spend between you sending the tx and it getting mined. Only then decrease/increase the allowance.\n\t// See https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#heading=h.m9fhqynw2xvt\n\tfunction approve(address _spender, uint256 _amount) returns (bool success) {\n\t\tallowed[msg.sender][_spender] = _amount;\n\t\tApproval(msg.sender, _spender, _amount);\n\t\treturn true;\n\t\t}\n\n\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n\t\treturn allowed[_owner][_spender];\n\t\t}\n\n\tfunction burn(uint256 _amount) notLocked(msg.sender, _amount) returns (bool success) {\n\t\t\tif (piecesOwned[msg.sender] >= _amount) {\n\t\t\t\tpiecesOwned[msg.sender] -= _amount;\n\t\t\t\teditionSize -= _amount;\n\t\t\t\tBurn(msg.sender, _amount);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {throw;}\n\t\t}\n\n\tfunction burnFrom(address _from, uint256 _value) notLocked(_from, _value) onlyPayloadSize(2 * 32) returns (bool success) {\n\t\tif (piecesOwned[_from] >= _value && allowed[_from][msg.sender] >= _value) {\n\t\t\tpiecesOwned[_from] -= _value;\n\t\t\tallowed[_from][msg.sender] -= _value;\n\t\t\teditionSize -= _value;\n\t\t\tBurn(_from, _value);\n\t\t\treturn true;\n\t\t}\n\t\telse {throw;}\n\t}\n\n\tfunction buyPiece() payable {\n\t\tif (pieceForSale && msg.value >= lowestAskPrice) {\n\t\t\tuint256 _amountOwner;\n\t\t\tuint256 _amountEthart;\n\t\t\tuint256 _amountSeller;\n\t\t\tuint256 _amountReferrer;\n\t\t\t_amountOwner = (msg.value / 10000) * ownerCommission;\n\t\t\t_amountEthart = (msg.value / 10000) * ethartRevenueReward;\n\t\t\t_amountSeller = msg.value - _amountOwner - _amountEthart;\n\t\t\tInterface a = Interface(registrar);\n\t\t\tif (referrer != 0x0) {\n\t\t\t\t_amountReferrer = _amountEthart / 10000 * referrerReward;\n\t\t\t\t_amountEthart -= _amountReferrer;\n\t\t\t\t// Async send the referrer reward to the referrer\n\t\t\t\ta.asyncSend(referrer, _amountReferrer);\n\t\t\t\t}\n\t\t\tpiecesOwned[lowestAskAddress]--;\n\t\t\tpiecesOwned[msg.sender]++;\n\t\t\tPieceSold (lowestAskAddress, msg.sender, msg.value);\n\t\t\tpieceForSale = false;\n\t\t\tlowestAskPrice = 0;\n\t\t\t// Reward the buyer with Patron tokens\n\t\t\ta.issuePatrons(msg.sender, msg.value);\n\t\t\t// Async send the contract owner's commission\n\t\t\ta.asyncSend(owner, _amountOwner);\n\t\t\t// Async send the buy price - commissions to seller\n\t\t\ta.asyncSend(lowestAskAddress, _amountSeller);\n\t\t\tlowestAskAddress = 0x0;\n\t\t\t// Async send Ethart commission to Ethart\n\t\t\ta.asyncSend(registrar, _amountEthart);\n\t\t\t// Transfer the sale price to the registrar contract\n\t\t\tregistrar.transfer(msg.value);\n\t\t}\n\t\telse {throw;}\n\t}\n\n\t// Offer a piece for sale at a fixed price - the price has to be lower than the current lowest price\n\tfunction offerPieceForSale (uint256 _price) ethArtOnlyAfterOneYear {\n\t\tif ((_price < lowestAskPrice || !pieceForSale) && piecesOwned[msg.sender] >= 1) {\n\t\t\t\tif (_price <= highestBidPrice) {fillBid();}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpieceForSale = true;\n\t\t\t\t\tlowestAskPrice = _price;\n\t\t\t\t\tlowestAskAddress = msg.sender;\n\t\t\t\t\tlowestAskTime = now;\n\t\t\t\t\tNewLowestAsk (_price, lowestAskAddress);\t\t\t// alerts contract watchers about new lowest ask price.\n\t\t\t\t}\n\t\t}\n\t\telse {throw;}\n\t}\n\n\t// place a bid for a piece - bid has to be higher than current highest bid\n\tfunction placeBid () payable {\n\t\tif (msg.value > highestBidPrice || (pieceForSale && msg.value >= lowestAskPrice)) {\n\t\t\tif (pieceWanted) \n\t\t\t\t{\n\t\t\t\t\tInterface a = Interface(registrar);\n\t\t\t\t\ta.asyncSend(highestBidAddress, highestBidPrice);\n\t\t\t\t}\n\t\t\tif (pieceForSale && msg.value >= lowestAskPrice) {buyPiece();}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpieceWanted = true;\n\t\t\t\t\thighestBidPrice = msg.value;\n\t\t\t\t\thighestBidAddress = msg.sender;\n\t\t\t\t\thighestBidTime = now;\n\t\t\t\t\tNewHighestBid (msg.value, highestBidAddress);\n\t\t\t\t\tregistrar.transfer(msg.value);\n\t\t\t\t}\n\t\t}\n\t\telse {throw;}\n\t}\n\n\t// If the current lowest ask address wants to fill a bid it has to either cancel it's sale first and then\n\t// fill the bid or lower the lowest ask price to be equal or lower than the highest bid.\n\tfunction fillBid () ethArtOnlyAfterOneYear notLocked(msg.sender, 1) {\n\t\tif (pieceWanted && piecesOwned[msg.sender] >= 1) {\n\t\t\tuint256 _amountOwner;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tuint256 _amountEthart;\n\t\t\tuint256 _amountSeller;\n\t\t\tuint256 _amountReferrer;\n\t\t\t_amountOwner = (highestBidPrice / 10000) * ownerCommission;\n\t\t\t_amountEthart = (highestBidPrice / 10000) * ethartRevenueReward;\n\t\t\t_amountSeller = highestBidPrice - _amountOwner - _amountEthart;\n\t\t\tInterface a = Interface(registrar);\n\t\t\tif (referrer != 0x0) {\n\t\t\t\t_amountReferrer = _amountEthart / 10000 * referrerReward;\n\t\t\t\t_amountEthart -= _amountReferrer;\n\t\t\t\t// Async send the referrer reward to the referrer\n\t\t\t\ta.asyncSend(referrer, _amountReferrer);\n\t\t\t\t}\n\t\t\tpiecesOwned[highestBidAddress]++;\n\t\t\t// Reward the buyer with Patron tokens\n\t\t\ta.issuePatrons(highestBidAddress, highestBidPrice);\t\t\t\t\n\t\t\tpiecesOwned[msg.sender]--;\n\t\t\tPieceSold (msg.sender, highestBidAddress, highestBidPrice);\n\t\t\tpieceWanted = false;\n\t\t\thighestBidPrice = 0;\n\t\t\thighestBidAddress = 0x0;\n\t\t\t// Async send the contract owner's commission\n\t\t\ta.asyncSend(owner, _amountOwner);\n\t\t\t// Async send the buy price - commissions to seller\n\t\t\ta.asyncSend(msg.sender, _amountSeller);\n\t\t\t// Async send Ethart commission to Ethart\n\t\t\ta.asyncSend(registrar, _amountEthart);\n\t\t}\n\t\telse {throw;}\n\t}\n\n\t// withdraw a bid - bids can only be withdrawn after 24 hours of being placed\n\tfunction cancelBid () onlyBy (highestBidAddress){\n\t\tif (pieceWanted && now > highestBidTime + 86400) {\n\t\t\tpieceWanted = false;\n\t\t\thighestBidPrice = 0;\n\t\t\thighestBidAddress = 0x0;\n\t\t\tNewHighestBid (0, 0x0);\n\t\t\tInterface a = Interface(registrar);\n\t\t\ta.asyncSend(msg.sender, highestBidPrice);\t\t\t\n\t\t}\n\t\telse {throw;}\n\t}\n\n\t// cancels sales - sales can only be canceled 24 hours after it has been offered for sale\n\tfunction cancelSale () onlyBy (lowestAskAddress){\n\t\tif(pieceForSale && now > lowestAskTime + 86400) {\n\t\t\tpieceForSale = false;\n\t\t\tlowestAskPrice = 0;\n\t\t\tlowestAskAddress = 0x0;\n\t\t\tNewLowestAsk (0, 0x0);\n\t\t}\n\t\telse {throw;}\n\t}\n\n}",
        "debug": "calldata_Interface_4 + calldata_Interface_4: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_16: 0x0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_Interface_0: 0x15336f8000000000000000000000000000000000000000000000000000000000\ncalldatasize_Interface: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x15336f80`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/43/0x93ebbf10084680bae8afdb05955bf1c0dd65948a.sol",
        "function": "_function_0x15336f80",
        "lineno": 88,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 14656,
        "code": "1. Introduction\n\nThis text is a plain English translation of the artwork smart contract's 'COSIMA' programming logic and represent its terms of use (terms). This plain English translation is a best effort only and while all reasonable precautions - including significant bug bounties - have been taken to ensure that the smart contract will behave in the exact way outlined in these terms, mistakes do happen (see The DAO) which may result in unexpected and unintended contract behaviour which may include the total loss of invested funds (Ether), other tokens sent to it as well as accessibility of the contract itself. Due to the nature of smart contracts, once it is deployed on the blockchain it becomes immutably imbedded in it which means that any bugs and/or exploits discovered after deployment are unfixable. Should the code behave differently than outlined in these terms, the code - by the very nature of smart contracts - takes precedent over the terms. By deploying, interacting or otherwise using the smart contract you acknowledge and accept all associated risks while at the same time waive all rights to hold the creator of the smart contract, the artists who deployed the smart contract, its current owner as well as any other parties responsible for potential damages suffered by or caused by you through your interaction with the smart contract to yourself or others. No backsies.\n\n2. Contract deployment\n\nThis smart contract enables its owner to issue limited edition pieces of art (pieces) that are cryptographically embedded in the Ethereum blockchain. Every piece can be owned, offered for sale, sold, bought, transferred and burned. The contract accepts bids from interested buyers and allows for the cancelation of bids as well as the cancelation of pieces offered for sale and filling of bids. In addition the owner of the contract as well as Ethart will earn a commission for every future sales of pieces irrespective of who owns, buys or sells them using the contract.\n\nThe contract creation costs approximately 2.4 Mgas - assuming a gas price of 20 Gwei, contract creation will cost ~0.05 ETH or about $15 (@$300/ETH) on the Ethereum main net. If contract creation is not urgent and Ethereum's pending transactions pool is not congested gas prices can be lowered to ~4 Gwei which would reduce the cost of deployment to ~$3 per artwork at current prices. Please make sure you understand the implications of gas cost, gas price and Ether price before you engage with this contract as the price of Ether and gas prices accepted by miners can and do change on a daily basis.\n\nDuring creation the contract asks for the following parameters:\n\n\t- The SHA256 hash of your piece (the cryptographic link of your artwork to the Ethereum blockchain)\n\t- Edition size (the maximum number of pieces you plan to issue)\n\t- Title (the title or name of your artwork, if any)\n\t- The link to your file (if any)\n\t- Custom text (if any)\n\t- The owner's commission in basis points (i.e. 1/100th of a percent)\n\nSHA256 hash: A SHA256 hash is a fixed length cryptographic digest of a file. On Mac and Linux it can be calculated by opening a terminal window and typing \"openssl sha -sha256\" followed by a space and the filename (i.e. \"openssl sha -sha256 <FILENAME>\") one wants to calculate the hash for. An online tool that serves the same purpose can be found at http://hash.online-convert.com/sha256-generator. By the nature of the cryptographic math the resulting hash is a) a unique fingerprint of the input file which can be independently verified by whomever has access to the original file, b) different for (almost) every file as long as at least one bit is different and c) almost impossible to reverse, meaning you can calculate a SHA256 hash from a file very easily but you can not generate the file from the SHA256 hash. Embedding the SHA256 hash in the contract at it's deployment therefore proofs that the limited edition pieces controlled by the smart contract's logic are linked to a particular file: the artwork.\n\nEdition size: The maximum number of pieces you wish your artwork to have.\n\nTitle: the title is stored as a public string in the contract\n\nFile link: So people can independently verify that a particular file is associated with a particular instance of a smart contract you can here specify the publicly accessible link to the file. Note that providing a link is not mandatory and some artists may decide to only provide the SHA256 hash and reveal the actual file associated with it at a later point in time or never.\n\nCustom text: This field can be whatever you want it to be. One use case could be a set of custom attributes for limited edition collectible playing cards. In this case you would format your game card attributes in a standard manner for later use e.g. Strength, Constitution, Dexterity, Intelligence, Wisdom as \"12,8,6,9,3\" which a later application can then read and interpreted according to your game's rules.\n\nOwner's commission: the account that deploys/ed the smart contract can set a commission for future sales that will be paid out to the current owner of smart contract. The commission is specified in basis points where 1 basis point equals 0.01%. The commission must be greater than 0 and lower than 10000 - Ethart's reward. If the owner wants to receive 5% for all future sales for example the commission will have to be set as 500.\n\nAt deployment the owner of the smart contract will be set as the account that deployed it. Please make sure to carefully note down your account details including your address, private key, password, JSON file etc and keep it safe and secret. Remember: whoever has access to this information has access to the contract and all the funds and rights associated with it. If you loose this information it is almost certainly going to be lost forever and your funds and artwork with it. Make at least one backup and keep it in a safe location. After contract deployment it is important for you to carefully note down the contract creation transaction receipt number, contract address and ABI for later reference. You and others will require this information to interact with the contract once it is live. If you created an artwork and lost your artwork's contract address you can look up the sha256 hash of your artwork in the registrar's artwok registry which will return your artwork's contract address to you.\n\nThe artwork contract acts as it's own decentralised exchange with an on chain order book of the lowest ask and highest bid for a piece and allows for trustless trade of the pieces of art via the Ethereum blockchain.\n\n3. Providing a proof\n\nAfter deployment and before the first pieces can be bought or sold the owner has to provide a proof. This proof demonstrates that the artwork was in fact deployed by the artist. The proof can be in the form of a link to a blog post, a tweet or press release, providing at the very least the artwork's contract address or contract creation transaction number.\n\n4. Ethart commission\n\nThe fee for letting you deploy your artworks is set by the registrar contract and will be between 0 and 10% of the edition size as well as between 0 and 10% of future revenues. Please make sure to check these numbers before you deploy your artwork's contarct as these values will be fixed after contract deployment. After you have provided the proof, the contract issues a percent of the edition size to Ethart automatically as following:\n\n- 1 piece for every (10000 / ethartArtReward) pieces increase in edition size\n- a (remainder / (10000 / ethartArtReward)) chance of an additional piece\n\nExample: Say you create a 100 piece limited edition artwork and the ethartArtReward is set as 250 (2.5%). The contract will then issue at least 2 pieces to Ethart. In addition there will be a 20 in 40 (i.e. 50%) chance that one additional piece will be issued to Ethart. In other words, if you create a limited edition of 1 piece there is always a chance that after you provide the proof this one piece will be transferred to Ethart. To avoid disappointment we therefore recommend a minimum edition size of 2 - then you are guaranteed to keep at least one piece with an additional small chance of loosing the other. The way the math works out Ethart will on average retain ethartArtReward in basis points of all pieces.\n\nThe pieces transferred to Ethart can not be sold or transferred by Ethart for a minimum of one year (31,556,926 seconds) giving you plenty of time to monopolise the market.\n\n5. Changing the owner\n\nThe current owner of the artwork contract can transfer ownership of the contract to another account.\n\n6. Transferring pieces\n\nYour artworks is in fact an ERC20 token (https://theethereum.wiki/w/index.php/ERC20_Token_Standard) and supports all ERC20 features. Pieces can be transferred to other addresses (as long as they are not being offered for sale) by their respective owners. Make sure that pieces are only being transferred to accounts that have access to their private keys. Pieces send to exchanges or other accounts that do not have access to their private keys will be lost - most likely forever.\n\n7. Offering a piece for sale\n\nThe owner of a piece can offer it for sale. The price for which it is offered (the ask) has to be lower than the current lowest ask. Once a piece is offered for sale by its owner for a lower price than the currently lowest ask it will become the lowest ask and replace the previous lowest ask. The sale price has to be specified in wei (1000000000000000000 wei = 1 ETH).\n\n8. Canceling a sale\n\nThe owner of a piece offered for sale can cancel the sale 24 hours after having offered the piece for sale. The 24 hour limited is intended to prevent owners to offer a piece at an artificially low price, displacing the currently lowest ask and then immediately canceling the sale.\n\n10. Buying a piece\n\nAs long as a piece is being offered for sale, anyone can buy it as long as the buyer sends at least the current lowest ask price with the buy order. Any buy orders that do not send at least the current lowest ask price will be rejects. All the funds send with a buy order will be paid out to the seller of the piece, the contract owner as well as Ethart respectively and in proportion to the commission rules outlined above. There will be no refunds for funds sent in excess of the lowest ask price. Once a piece has been sold the lowest ask will be reset and the next piece offered for sale will become the lowest ask if any. Patrons that buy pieces via the artwork\u2019s smart contract will be issuedpatronRewardMultiplier Patron tokens for every Ether spend in the transaction.\n\n11. Placing a bid\n\nBuyers can place bids in ether. Bids have to be higher than the currently highest bid. Placing a bid that is higher than the current lowest ask price will result in the bidder instantly buying the piece offered by the lowest ask seller for the bid amount.\n\n12. Cancelling a bid\n\nBids can be canceled by the buyer 24 hours after they have been placed. The 24 hour limited is intended to prevent buyers from placing an artificially high bid, displacing the currently highest bid and then immediately canceling the bid.\n\n13. Filling a bid\n\nBids can be filled by anyone who owns a piece.\n\n14. Burning a piece\n\nThe owner of a piece can burn it, removing it permanently from the pool of available pieces and thereby reducing the edition size. Artists may choose to do so to increase the value of the remaining pieces or for any other reason.\n\n15. Referral reward\n\nThe referrer of an artist receives referrerReward basis points of ethartRevenueReward as their referral reward for every piece sold using this contract. The referrer has to be set by the artist prior to creating their first artwork.\n\n16. Withdrawing funds\n\nFor security reasons Ethart contracts' handling of ether transfers have been implemented following the best practise pull payment method from Open Zeppelin (https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/payment/PullPayment.sol). This means that all funds used in placing bids and buying pieces are being transfered to the registrar contract. Sellers, artists, owners, referrer and buyers canceling their bids or those who are being outbid can claim their funds by executing the withdrawPayments method of the registrar contract. Not only does this mitigate several security concerns but at the same time provides a single location for everyone to claim their funds in one transaction.\n\n17. Standing bug bounty\n\nThe factory contract this contract has been spawned from has a standing bug bounty of 1,000 Patrons for all practical and demonstrable exploits that cause the unintentional loss of ether and/or tokens. If you feel you have discovered an exploit path or vulnerability please contact us at http://ethart.com and claim your reward.\n\n\t(c) Stefan Pernar 2017 - all rights reserved\n\t(c) ERC20 functions BokkyPooBah 2017. The MIT Licence.\n\n*/\n\n/* Public variables */\n\taddress public owner;\t\t\t\t\t\t// Contract owner.\n\tbytes32 public SHA256ofArtwork;\t\t\t\t// sha256 hash of the artwork.\n\tuint256 public editionSize;\t\t\t\t\t// The edition size of the artwork.\n\tstring public title;\t\t\t\t\t\t// The title of the artwork.\n\tstring public fileLink;\t\t\t\t\t\t// The link to the file of the artwork.\n\tstring public proofLink;\t\t\t\t\t// Link to the creation proof by the artist -> this has to be done after contract creation\n\tstring public customText;\t\t\t\t\t// Custom text\n\tuint256 public ownerCommission;\t\t\t\t// Percent given to the contract owner for every sale - must be >=0 && <=975 1000 = 100%.\n\t\n\tuint256 public lowestAskPrice;\t\t\t\t// The lowest price an owner of a piece is willing to sell it for.\n\taddress public lowestAskAddress;\t\t\t// The address of the lowest ask.\n\tuint256 public lowestAskTime;\t\t\t\t// The time by which the ask can be withdrawn.\n\tbool public pieceForSale;\t\t\t\t\t// Is a piece for sale?\n\n\tuint256 public highestBidPrice;\t\t\t\t// The highest price a buyer is willing to pay for a piece.\n\taddress public highestBidAddress;\t\t\t// The address of the highest bidder\n\tuint256 public highestBidTime;\t\t\t\t// The time by which the bid can be withdrawn\n\tuint public activationTime;\t\t\t\t\t// Time this contract has been activated.\n\tbool public pieceWanted;\t\t\t\t\t// Is a buyer interested in a piece?\n\n\t/* Events */\n\t\n\t// Informs watchers of the contract when a new lowest ask price has been set. (price, seller)\n\tevent NewLowestAsk (uint256 price, address seller);\n\t\n\t// Informs watchers of the contract when a new highest bid price has been placed. (price, bidder)\n\tevent NewHighestBid (uint256 price, address bidder);\n\t\n\t// Informs watchers of the contract when a piece has been transferred. (amount, from, to)\n\tevent PieceTransferred (uint256 amount, address from, address to);\n\t\n\t// Informs watchers of the contract when a piece has been sold. (from, to, price)\n\tevent PieceSold (address from, address to, uint256 price);\n\n\tevent Transfer (address indexed _from, address indexed _to, uint256 _value);\n\tevent Approval (address indexed _owner, address indexed _spender, uint256 _value);\n\tevent Burn (address indexed _owner, uint256 _amount);\n\n\t/* Other variables */\n\t\n\t// Has the proof been set yet?\n\tbool public proofSet;\n\t\n\t// # of pieces awarded to Ethart.\n\tuint256 public ethartArtAwarded;\n\n\t// Maps the number of pieces owned by an address\n\tmapping (address => uint256) public piecesOwned;\n\t\n\t// Used in burnFrom and transferFrom\n \tmapping (address => mapping (address => uint256)) allowed;\n\t\n\t// set after deployment of Registrar contract\n    address registrar = 0x5f68698245e8c8949450E68B8BD8acef37faaE7D;\n\t\n\t// Ethart reward variables - fixed after contract creation\n\tuint256 public ethartRevenueReward;\n\tuint256 public ethartArtReward;\n\taddress public referrer;\n\t\n\t// Referrer receives referrerReward basis points of ethartRevenueReward\n\tuint256 public referrerReward;\n\n\t// Constructor\n\tfunction Artwork (\n\t\tbytes32 _SHA256ofArtwork,\n\t\tuint256 _editionSize,\n\t\tstring _title,\n\t\tstring _fileLink,\n\t\tstring _customText,\n\t\tuint256 _ownerCommission,\n\t\taddress _owner\n\t) {\n\t\tif (_ownerCommission > (10000 - ethartRevenueReward)) {throw;}\n\t\tInterface a = Interface(registrar);\n\t\tethartRevenueReward = a.getEthartRevenueReward();\n\t\tethartArtReward = a.getEthartArtReward();\n\t\treferrer = a.getReferrer (_owner);\n\t\treferrerReward = a.getReferrerReward ();\n\t\t// Owner is set as the address spawning the contract\n\t\towner = _owner;\n\t\tSHA256ofArtwork = _SHA256ofArtwork;\n\t\teditionSize = _editionSize;\n\t\ttitle = _title;\n\t\tfileLink = _fileLink;\n\t\tcustomText = _customText;\n\t\townerCommission = _ownerCommission;\n\t\tactivationTime = now;\t\n\t}\n\n\tmodifier onlyBy(address _account)\n\t{\n\t\trequire(msg.sender == _account);\n\t\t_;\n\t}\n\n\t// The registrar can execute certain functions only after one year\n\tmodifier ethArtOnlyAfterOneYear()\n\t{\n\t\trequire(msg.sender != registrar || now > activationTime + 31536000);\n\t\t_;\n\t}\n\n\t// Sales / approvals have to be cancelled first for certain functions\n\tmodifier notLocked(address _owner, uint256 _amount)\n\t{\n\t\trequire(_owner != lowestAskAddress || piecesOwned[_owner] > _amount);\n\t\t_;\n\t}\n\n\t// Mitigating ERC20 short address attacks (http://vessenes.com/the-erc20-short-address-attack-explained/)\n\tmodifier onlyPayloadSize(uint size)\n\t{\n\t\trequire(msg.data.length >= size + 4);\n\t\t_;\n\t}\n\n\t// allows the current owner to assign a new owner\n\tfunction changeOwner (address newOwner) onlyBy (owner) {\n\t\towner = newOwner;\n\t\t}\n\n\tfunction setProof (string _proofLink) onlyBy (owner) {\n\t\tif (!proofSet) {\n\t\t\tuint256 remainder;\n\t\t\tproofLink = _proofLink;\n\t\t\tproofSet = true;\n\t\t\tremainder = editionSize % (10000 / ethartArtReward);\n\t\t\tethartArtAwarded = (editionSize - remainder) / (10000 / ethartArtReward);\n\t\t\t// Yes - this is gameable - if it is that important to you: go ahead.\n\t\t\tif (remainder > 0 && now % ((10000 / ethartArtReward) - 1) <= remainder) {ethartArtAwarded++;}\n\t\t\tpiecesOwned[registrar] = ethartArtAwarded;\n\t\t\tpiecesOwned[owner] = editionSize - ethartArtAwarded;\n\t\t\t}\n\t\telse {throw;}\n\t\t}\n\n\tfunction transfer(address _to, uint256 _amount) notLocked(msg.sender, _amount) onlyPayloadSize(2 * 32) returns (bool success) {\n\t\tif (piecesOwned[msg.sender] >= _amount \n\t\t\t&& _amount > 0\n\t\t\t&& piecesOwned[_to] + _amount > piecesOwned[_to]\n\t\t\t// use burn() instead\n\t\t\t&& _to != 0x0)\n\t\t\t{\n\t\t\tpiecesOwned[msg.sender] -= _amount;\n\t\t\tpiecesOwned[_to] += _amount;\n\t\t\tTransfer(msg.sender, _to, _amount);\n\t\t\treturn true;\n\t\t\t}\n\t\t\telse { return false;}\n \t\t }\n\n\tfunction totalSupply() constant returns (uint256 totalSupply) {\n\t\ttotalSupply = editionSize;\n\t\t}\n\n\tfunction balanceOf(address _owner) constant returns (uint256 balance) {\n \t\treturn piecesOwned[_owner];\n\t\t}\n\n\tfunction transferFrom(address _from, address _to, uint256 _amount) notLocked(_from, _amount) onlyPayloadSize(3 * 32)returns (bool success)\n\t\t{\n\t\t\tif (piecesOwned[_from] >= _amount\n\t\t\t\t&& allowed[_from][msg.sender] >= _amount\n\t\t\t\t&& _amount > 0\n\t\t\t\t&& piecesOwned[_to] + _amount > piecesOwned[_to]\n\t\t\t\t// use burn() instead\n\t\t\t\t&& _to != 0x0\n\t\t\t\t&& (_from != lowestAskAddress || piecesOwned[_from] > _amount))\n\t\t\t\t\t{\n\t\t\t\t\tpiecesOwned[_from] -= _amount;\n\t\t\t\t\tallowed[_from][msg.sender] -= _amount;\n\t\t\t\t\tpiecesOwned[_to] += _amount;\n\t\t\t\t\tTransfer(_from, _to, _amount);\n\t\t\t\t\treturn true;\n\t\t\t\t\t} else {return false;}\n\t\t}\n\n\t// Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n\t// If this function is called again it overwrites the current allowance with _value.\n\t// To be extra secure set allowance to 0 and check that none of our allowance was spend between you sending the tx and it getting mined. Only then decrease/increase the allowance.\n\t// See https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#heading=h.m9fhqynw2xvt\n\tfunction approve(address _spender, uint256 _amount) returns (bool success) {\n\t\tallowed[msg.sender][_spender] = _amount;\n\t\tApproval(msg.sender, _spender, _amount);\n\t\treturn true;\n\t\t}\n\n\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n\t\treturn allowed[_owner][_spender];\n\t\t}\n\n\tfunction burn(uint256 _amount) notLocked(msg.sender, _amount) returns (bool success) {\n\t\t\tif (piecesOwned[msg.sender] >= _amount) {\n\t\t\t\tpiecesOwned[msg.sender] -= _amount;\n\t\t\t\teditionSize -= _amount;\n\t\t\t\tBurn(msg.sender, _amount);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {throw;}\n\t\t}\n\n\tfunction burnFrom(address _from, uint256 _value) notLocked(_from, _value) onlyPayloadSize(2 * 32) returns (bool success) {\n\t\tif (piecesOwned[_from] >= _value && allowed[_from][msg.sender] >= _value) {\n\t\t\tpiecesOwned[_from] -= _value;\n\t\t\tallowed[_from][msg.sender] -= _value;\n\t\t\teditionSize -= _value;\n\t\t\tBurn(_from, _value);\n\t\t\treturn true;\n\t\t}\n\t\telse {throw;}\n\t}\n\n\tfunction buyPiece() payable {\n\t\tif (pieceForSale && msg.value >= lowestAskPrice) {\n\t\t\tuint256 _amountOwner;\n\t\t\tuint256 _amountEthart;\n\t\t\tuint256 _amountSeller;\n\t\t\tuint256 _amountReferrer;\n\t\t\t_amountOwner = (msg.value / 10000) * ownerCommission;\n\t\t\t_amountEthart = (msg.value / 10000) * ethartRevenueReward;\n\t\t\t_amountSeller = msg.value - _amountOwner - _amountEthart;\n\t\t\tInterface a = Interface(registrar);\n\t\t\tif (referrer != 0x0) {\n\t\t\t\t_amountReferrer = _amountEthart / 10000 * referrerReward;\n\t\t\t\t_amountEthart -= _amountReferrer;\n\t\t\t\t// Async send the referrer reward to the referrer\n\t\t\t\ta.asyncSend(referrer, _amountReferrer);\n\t\t\t\t}\n\t\t\tpiecesOwned[lowestAskAddress]--;\n\t\t\tpiecesOwned[msg.sender]++;\n\t\t\tPieceSold (lowestAskAddress, msg.sender, msg.value);\n\t\t\tpieceForSale = false;\n\t\t\tlowestAskPrice = 0;\n\t\t\t// Reward the buyer with Patron tokens\n\t\t\ta.issuePatrons(msg.sender, msg.value);\n\t\t\t// Async send the contract owner's commission\n\t\t\ta.asyncSend(owner, _amountOwner);\n\t\t\t// Async send the buy price - commissions to seller\n\t\t\ta.asyncSend(lowestAskAddress, _amountSeller);\n\t\t\tlowestAskAddress = 0x0;\n\t\t\t// Async send Ethart commission to Ethart\n\t\t\ta.asyncSend(registrar, _amountEthart);\n\t\t\t// Transfer the sale price to the registrar contract\n\t\t\tregistrar.transfer(msg.value);\n\t\t}\n\t\telse {throw;}\n\t}\n\n\t// Offer a piece for sale at a fixed price - the price has to be lower than the current lowest price\n\tfunction offerPieceForSale (uint256 _price) ethArtOnlyAfterOneYear {\n\t\tif ((_price < lowestAskPrice || !pieceForSale) && piecesOwned[msg.sender] >= 1) {\n\t\t\t\tif (_price <= highestBidPrice) {fillBid();}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpieceForSale = true;\n\t\t\t\t\tlowestAskPrice = _price;\n\t\t\t\t\tlowestAskAddress = msg.sender;\n\t\t\t\t\tlowestAskTime = now;\n\t\t\t\t\tNewLowestAsk (_price, lowestAskAddress);\t\t\t// alerts contract watchers about new lowest ask price.\n\t\t\t\t}\n\t\t}\n\t\telse {throw;}\n\t}\n\n\t// place a bid for a piece - bid has to be higher than current highest bid\n\tfunction placeBid () payable {\n\t\tif (msg.value > highestBidPrice || (pieceForSale && msg.value >= lowestAskPrice)) {\n\t\t\tif (pieceWanted) \n\t\t\t\t{\n\t\t\t\t\tInterface a = Interface(registrar);\n\t\t\t\t\ta.asyncSend(highestBidAddress, highestBidPrice);\n\t\t\t\t}\n\t\t\tif (pieceForSale && msg.value >= lowestAskPrice) {buyPiece();}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpieceWanted = true;\n\t\t\t\t\thighestBidPrice = msg.value;\n\t\t\t\t\thighestBidAddress = msg.sender;\n\t\t\t\t\thighestBidTime = now;\n\t\t\t\t\tNewHighestBid (msg.value, highestBidAddress);\n\t\t\t\t\tregistrar.transfer(msg.value);\n\t\t\t\t}\n\t\t}\n\t\telse {throw;}\n\t}\n\n\t// If the current lowest ask address wants to fill a bid it has to either cancel it's sale first and then\n\t// fill the bid or lower the lowest ask price to be equal or lower than the highest bid.\n\tfunction fillBid () ethArtOnlyAfterOneYear notLocked(msg.sender, 1) {\n\t\tif (pieceWanted && piecesOwned[msg.sender] >= 1) {\n\t\t\tuint256 _amountOwner;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tuint256 _amountEthart;\n\t\t\tuint256 _amountSeller;\n\t\t\tuint256 _amountReferrer;\n\t\t\t_amountOwner = (highestBidPrice / 10000) * ownerCommission;\n\t\t\t_amountEthart = (highestBidPrice / 10000) * ethartRevenueReward;\n\t\t\t_amountSeller = highestBidPrice - _amountOwner - _amountEthart;\n\t\t\tInterface a = Interface(registrar);\n\t\t\tif (referrer != 0x0) {\n\t\t\t\t_amountReferrer = _amountEthart / 10000 * referrerReward;\n\t\t\t\t_amountEthart -= _amountReferrer;\n\t\t\t\t// Async send the referrer reward to the referrer\n\t\t\t\ta.asyncSend(referrer, _amountReferrer);\n\t\t\t\t}\n\t\t\tpiecesOwned[highestBidAddress]++;\n\t\t\t// Reward the buyer with Patron tokens\n\t\t\ta.issuePatrons(highestBidAddress, highestBidPrice);\t\t\t\t\n\t\t\tpiecesOwned[msg.sender]--;\n\t\t\tPieceSold (msg.sender, highestBidAddress, highestBidPrice);\n\t\t\tpieceWanted = false;\n\t\t\thighestBidPrice = 0;\n\t\t\thighestBidAddress = 0x0;\n\t\t\t// Async send the contract owner's commission\n\t\t\ta.asyncSend(owner, _amountOwner);\n\t\t\t// Async send the buy price - commissions to seller\n\t\t\ta.asyncSend(msg.sender, _amountSeller);\n\t\t\t// Async send Ethart commission to Ethart\n\t\t\ta.asyncSend(registrar, _amountEthart);\n\t\t}\n\t\telse {throw;}\n\t}\n\n\t// withdraw a bid - bids can only be withdrawn after 24 hours of being placed\n\tfunction cancelBid () onlyBy (highestBidAddress){\n\t\tif (pieceWanted && now > highestBidTime + 86400) {\n\t\t\tpieceWanted = false;\n\t\t\thighestBidPrice = 0;\n\t\t\thighestBidAddress = 0x0;\n\t\t\tNewHighestBid (0, 0x0);\n\t\t\tInterface a = Interface(registrar);\n\t\t\ta.asyncSend(msg.sender, highestBidPrice);\t\t\t\n\t\t}\n\t\telse {throw;}\n\t}\n\n\t// cancels sales - sales can only be canceled 24 hours after it has been offered for sale\n\tfunction cancelSale () onlyBy (lowestAskAddress){\n\t\tif(pieceForSale && now > lowestAskTime + 86400) {\n\t\t\tpieceForSale = false;\n\t\t\tlowestAskPrice = 0;\n\t\t\tlowestAskAddress = 0x0;\n\t\t\tNewLowestAsk (0, 0x0);\n\t\t}\n\t\telse {throw;}\n\t}\n\n}",
        "debug": "calldata_Interface_4 + calldata_Interface_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_16: 0x0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_Interface_0: 0x15336f8000000000000000000000000000000000000000000000000000000000\ncalldatasize_Interface: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x15336f80`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/43/0x93ebbf10084680bae8afdb05955bf1c0dd65948a.sol",
        "function": "_function_0x15336f80",
        "lineno": 88,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}