{
  "contract": "0x1ce41d9f3e2c211d3ff301dcc4b4776151e4a9ed",
  "tool": "mythril",
  "start": 1563683127.942056,
  "end": 1563683238.1115296,
  "duration": 110.16947364807129,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 1569,
        "code": "ract SoccerBet is Base\n{\n\tfunction SoccerBet(string _gameName,uint _bankerDepositPer, address _DonQuixoteToken) public {\n\t\trequi",
        "debug": "calldata_SoccerBet_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_SoccerBet_0: 0x26c4fa3d00000000000000000000000000000000000000000000000000000000\ncalldatasize_SoccerBet: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setOfficialGameUrl(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/34/0x1ce41d9f3e2c211d3ff301dcc4b4776151e4a9ed.sol",
        "function": "setOfficialGameUrl(string)",
        "lineno": 140,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6182,
        "code": "{\n        lock();\n        _depos",
        "debug": "",
        "description": "This contract executes a message call to an address found at storage slot 9. This storage slot can be written to by calling the function `withdrawAllToken()`. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.",
        "filename": "/unique_chucks/34/0x1ce41d9f3e2c211d3ff301dcc4b4776151e4a9ed.sol",
        "function": "tokenOf(address)",
        "lineno": 96,
        "title": "Message call to external contract",
        "type": "Warning"
      },
      {
        "address": 6182,
        "code": "{\n        lock();\n        _depos",
        "debug": "",
        "description": "A possible transaction order independence vulnerability exists in function tokenOf(address). The value or direction of the call statement is determined from a tainted storage location",
        "filename": "/unique_chucks/34/0x1ce41d9f3e2c211d3ff301dcc4b4776151e4a9ed.sol",
        "function": "tokenOf(address)",
        "lineno": 96,
        "title": "Transaction order dependence",
        "type": "Warning"
      },
      {
        "address": 11343,
        "debug": "",
        "description": "This contract executes a message call to an address found at storage slot 9. This storage slot can be written to by calling the function `withdrawAllToken()`. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.",
        "filename": "/unique_chucks/34/0x1ce41d9f3e2c211d3ff301dcc4b4776151e4a9ed.sol",
        "function": "withdrawAllToken()",
        "lineno": 614,
        "title": "Message call to external contract",
        "type": "Warning"
      },
      {
        "address": 11343,
        "debug": "",
        "description": "A possible transaction order independence vulnerability exists in function withdrawAllToken(). The value or direction of the call statement is determined from a tainted storage location",
        "filename": "/unique_chucks/34/0x1ce41d9f3e2c211d3ff301dcc4b4776151e4a9ed.sol",
        "function": "withdrawAllToken()",
        "lineno": 614,
        "title": "Transaction order dependence",
        "type": "Warning"
      },
      {
        "address": 16444,
        "code": " a);\n",
        "debug": "storage_3: 0x100000000040000100000290202000610077f914e97fef8da03036d38a6e1a\nstorage_4: 0x7fefffffffffc4d7fef9bfc3ffefbff75dcfffd7fb837fafbffbfd7dfb75683e\ntimestamp: 0x7fdfffffffff0717eef99e851050051236578f5a1effffefdffffafffb9f6a1a\ncalldata_SoccerBet_32 + 164: 0x989700\nstorage_24: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_SoccerBet_32 + 132: 0x7fdfffffffff879ffefa3f877ce006d617f7cfbab3037fafbffbfcfdfb3e084f\ncalldata_SoccerBet_32 + 196: 0x989700\nstorage_30: 0xff00\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_SoccerBet_4 + calldata_SoccerBet_4)): 0x63\ncalldata_SoccerBet_4 + calldata_SoccerBet_4: 0x63\nstorage_5: 0x0\ncaller: 0x0\ncalldata_SoccerBet_0: 0xfaf277500000000000000000000000000000000000000000000000000000000\ncalldatasize_SoccerBet: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `newGame(string,string,uint256,uint256,uint256,uint256,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/34/0x1ce41d9f3e2c211d3ff301dcc4b4776151e4a9ed.sol",
        "function": "newGame(string,string,uint256,uint256,uint256,uint256,uint256,uint256)",
        "lineno": 24,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 16457,
        "code": "urn c;\n  }\n}\n\n",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_3: 0x362308016f000237906fed6000206980ffc0051f5fffffc13713bf31035f0c6\nstorage_4: 0xa0204b0860a20800000000000000000000000000000000000000000000001060\ntimestamp: 0x7d9c6c6061c9071d5c700029c3ffe045f7e3fffd63fffff7ff9affeeefffcf9a\ncalldata_SoccerBet_32 + 164: 0x2000000000000000000000000000000000000000000001c9200\nstorage_24: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_SoccerBet_32 + 132: 0x8f7008016031fdffffffffffffffffffffffffffffffffffffffffffffffc004\ncalldata_SoccerBet_32 + 196: 0x2000000000000000000000000000000000000000000001c9200\nstorage_30: 0xff00\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_SoccerBet_4 + calldata_SoccerBet_4)): 0x63\ncalldata_SoccerBet_4 + calldata_SoccerBet_4: 0x63\nstorage_5: 0x0\ncaller: 0x0\ncalldata_SoccerBet_0: 0xfaf277500000000000000000000000000000000000000000000000000000000\ncalldatasize_SoccerBet: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/34/0x1ce41d9f3e2c211d3ff301dcc4b4776151e4a9ed.sol",
        "function": "newGame(string,string,uint256,uint256,uint256,uint256,uint256,uint256)",
        "lineno": 25,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 20161,
        "code": "QuixoteToken != 0x0);\n\t\tgameName = _gameName;\n\t\tbankerDepositPer = _bankerDepositPer;\n        DonQuixoteToken = IDonQuixoteToken(_DonQuixoteToken);\n        owner = msg.sender;\n    }\n\n\tuint public unpayPooling = 0;\n\tuint public losePooling = 0;\n\tuint public winPooling = 0;\n\tuint public samePooling = 0;\n\t\n\tuint public bankerDepositPer = 20;\n\n    address public auction;\n\tfunction setAuction(address _newAuction) public onlyOwner{\n        auction = _newAuction;\n    }\n    modifier onlyAuction {\n\t    require(msg.sender == auction);\n        _;\n    }\n\t\n    modifier onlyBanker {\n        require(msg.sender == currentBanker);\n        require(bankerBeginTime <= now);\n        require(now < bankerEndTime);\n        _;\n    }    \n\t\n\tfunction canSetBanker() public view returns (bool _result){\n        _result =  false;\n\t\tif(now < bankerEndTime){\n\t\t\treturn;\n\t\t}\n\t\tif(userTokenOf[this] == 0){\n\t\t\t_result = true;\n\t\t}\n    }\n\t\n\tevent OnSetNewBanker(uint indexed _gameID , address _caller, address _banker, uint _beginTime, uint _endTime, uint _errInfo, uint _eventTime, uint eventId);\n    function setBanker(address _banker, uint _beginTime, uint _endTime) public onlyAuction returns(bool _result)\n    {\n        _result = false;\n        require(_banker != 0x0);\n\n        if(now < bankerEndTime){\n            emit OnSetNewBanker(gameID, msg.sender, _banker,  _beginTime,  _endTime, 1, now, getEventId());//\"bankerEndTime > now\"\n            return;\n        }\n\t\t\n\t\tif(userTokenOf[this] > 0){\n\t\t\temit OnSetNewBanker(gameID, msg.sender, _banker,  _beginTime,  _endTime, 5, now, getEventId());//\"userTokenOf[this] > 0\"\n\t\t\treturn;\n\t\t}\n        \n        if(_beginTime > now){\n\t\t\temit OnSetNewBanker(gameID, msg.sender, _banker,  _beginTime,  _endTime, 3, now, getEventId());//'_beginTime > now'\n            return;\n        }\n\n        if(_endTime <= now){\n\t\t\temit OnSetNewBanker(gameID, msg.sender, _banker,  _beginTime,  _endTime, 4, now, getEventId());//'_endTime <= now'\n            return;\n        }\n\t\t\n\t\tif(now < donGameGiftLineTime){\n            DonQuixoteToken.logPlaying(_banker);\n        }\n        currentBanker = _banker;\n        bankerBeginTime = _beginTime;\n        bankerEndTime =  _endTime;\n\t\n\t\tunpayPooling = 0;\n\t\tlosePooling = 0;\n\t\twinPooling = 0;\n\t\tsamePooling = 0;\n\t\t\n\t\tgameResult = 9;\n\t\t\n\t\tgameOver = true;\n\n\t\temit OnSetNewBanker(gameID, msg.sender, _banker,  _beginTime,  _endTime, 0, now, getEventId());\n        _result = true;\n    }\n\n\tstring public team1;\n    string public team2;\n\t\n    uint public constant loseNum = 1;\n    uint public constant winNum = 3;\n    uint public constant sameNum = 0;\n\n    uint public loseOdd;\n    uint public winOdd;\n    uint public sameOdd;\n\n    uint public betLastTime;\n\n    uint public playNo = 1;\n    uint public gameID = 0;\n\n    uint public gameBeginPlayNo;\n\n    uint public gameResult = 9;\n\n    uint  public gameBeginTime;\n\n    uint256 public gameMaxBetAmount;\n    uint256 public gameMinBetAmount;\n    bool public gameOver = true;\n\t\n\tuint public nextRewardPlayNo=1;\n    uint public currentRewardNum = 100;\n\t\n\tuint public donGameGiftLineTime =  now + 90 days;\n\t\n\taddress public decider;\n    function setDecider(address _decider) public onlyOwner{\t\n        decider = _decider;\n    }\n    modifier onlyDecider{\n        require(msg.sender == decider);\n        _;\n    }\n\tfunction setGameResult(uint _gameResult) public onlyDecider{\n\t\trequire(!gameOver);\n\t\trequire(betLastTime + 90 minutes < now);\n\t\trequire(gameResult == 9);\n\t\trequire( _gameResult == loseNum || _gameResult == winNum || _gameResult == sameNum);\n\t\tgameResult = _gameResult;\n\t\tif(gameResult == 3){\n\t\t\tunpayPooling = winPooling;\n\t\t}else if(gameResult == 1){\n\t\t\tunpayPooling = losePooling;\n\t\t}else if(gameResult == 0){\n\t\t\tunpayPooling = samePooling;\n\t\t}\n\t}\n\n    event OnNewGame(uint indexed _gameID, address _banker , uint _betLastTime, uint _gameBeginTime, uint256 _gameMinBetAmount, uint256 _gameMaxBetAmount, uint _eventTime, uint eventId);\n\tevent OnGameInfo(uint indexed _gameID, string _team1, string _team2, uint _loseOdd, uint _winOdd, uint _sameOdd, uint _eventTime, uint eventId);\n    function newGame(string _team1, string _team2, uint _loseOdd, uint _winOdd, uint _sameOdd, uint _betLastTime, uint256 _gameMinBetAmount, uint256 _gameMaxBetAmount) public onlyBanker returns(bool _result){ //\u5f00\u5c40\n        require(bytes(_team1).length < 100);\n\t\trequire(bytes(_team2).length < 100);\n\t\t\n\t\trequire(gameOver);\n        require(now > bankerBeginTime);\n\t\trequire(_gameMinBetAmount >= 10000000);\n        require(_gameMaxBetAmount >= _gameMinBetAmount);\n\t\trequire(now < _betLastTime);\n\t\trequire(_betLastTime+ 1 days < bankerEndTime);\n\n        _result = _newGame(_team1, _team2, _loseOdd, _winOdd, _sameOdd, _betLastTime, _gameMinBetAmount,  _gameMaxBetAmount);\n    }\n\n    function _newGame(string _team1, string _team2, uint _loseOdd, uint _winOdd, uint _sameOdd, uint _betLastTime, uint256 _gameMinBetAmount, uint256 _gameMaxBetAmount) private  returns(bool _result){\n        _result = false;\n\t\tgameID = gameID.add(1);\n\t\t\n\t\tteam1 = _team1;\n        team2 = _team2;\n\t\tloseOdd = _loseOdd;\n\t\twinOdd = _winOdd;\n\t\tsameOdd = _sameOdd;\n\t\temit OnGameInfo(gameID, team1, team2, loseOdd, winOdd, sameOdd, now, getEventId());\n\t\t\n\t\tbetLastTime = _betLastTime;\n        gameBeginTime = now;\n\t\tgameMinBetAmount = _gameMinBetAmount;\n        gameMaxBetAmount = _gameMaxBetAmount;\n\t\temit OnNewGame(gameID, msg.sender, betLastTime,  gameBeginTime, gameMinBetAmount,   gameMaxBetAmount, now, getEventId());\n        \n        gameBeginPlayNo = playNo;\n        gameResult = 9;\n        gameOver = false;\n\t\tunpayPooling = 0;\n\t\tlosePooling = 0;\n\t\twinPooling = 0;\n\t\tsamePooling = 0;\n\n        _result = true;\n    }\n\t\n    event OnSetOdd(uint indexed _gameID, uint _winOdd, uint _loseOdd, uint _sameOdd, uint _eventTime, uint eventId);\n\tfunction setOdd(uint _winOdd, uint _loseOdd, uint _sameOdd) onlyBanker public{\t\t\n\t\twinOdd = _winOdd;\n\t\tloseOdd = _loseOdd;\n\t\tsameOdd = _sameOdd;\t\n\t\temit OnSetOdd(gameID, winOdd, loseOdd, sameOdd, now, getEventId());\n\t}\n\n    struct betInfo\n    {\n        uint Odd;\n        address Player;\n        uint BetNum;\n        uint256 BetAmount;\n\t\tuint loseToken;\n        bool IsReturnAward;\n    }\n\n    mapping (uint => betInfo) public playerBetInfoOf;\n\n    event OnPlay(uint indexed _gameID, string _gameName, address _player, uint odd, string _team1, uint _betNum, uint256 _betAmount, uint _playNo, uint _eventTime, uint eventId);\n    function play(uint _betNum, uint256 _betAmount) public returns(bool _result){ \n        _result = _play(_betNum, _betAmount);\n    }\n\n    function _play(uint _betNum, uint256 _betAmount) private  returns(bool _result){\n        _result = false;\n        require(!gameOver);\n\n        require(_betNum == loseNum || _betNum == winNum || _betNum == sameNum);\n        require(msg.sender != currentBanker);\n\n        require(now < betLastTime);\n\t\t\n\t\trequire(_betAmount >= gameMinBetAmount);\n        if (_betAmount > gameMaxBetAmount){\n            _betAmount = gameMaxBetAmount;\n        }\n\n\t\t_betAmount = _betAmount / 100 * 100;\n\n        if(userTokenOf[msg.sender] < _betAmount){\n            depositToken(_betAmount.sub(userTokenOf[msg.sender]));\n        }\n        \n        uint BankerAmount = _betAmount.mul(bankerDepositPer).div(100);\n        require(userTokenOf[msg.sender] >= _betAmount);\n        require(userTokenOf[currentBanker] >= BankerAmount);\n\n\n        uint _odd = seekOdd(_betNum,_betAmount);\n\n        betInfo memory bi= betInfo({\n            Odd :_odd,\n            Player :  msg.sender,\n            BetNum : _betNum,\n            BetAmount : _betAmount,\n            loseToken : 0,\n            IsReturnAward: false\n        });\n\n        playerBetInfoOf[playNo] = bi;\n        userTokenOf[msg.sender] = userTokenOf[msg.sender].sub(_betAmount);\n\t\tuserTokenOf[this] = userTokenOf[this].add(_betAmount);\n        userTokenOf[currentBanker] = userTokenOf[currentBanker].sub(BankerAmount);\n\t\tuserTokenOf[this] = userTokenOf[this].add(BankerAmount);\n        emit OnPlay(gameID, gameName, msg.sender, _odd, team1, _betNum, _betAmount, playNo, now, getEventId());\n\n        playNo = playNo.add(1); \n\t\tif(now < donGameGiftLineTime){\n            DonQuixoteToken.logPlaying(msg.sender);\n        }\n\t\t\n        _result = true;\n    }\n\t\n\tfunction seekOdd(uint _betNum, uint _betAmount) private returns (uint _odd){\n\t\tuint allAmount = 0;\n\t\tif(_betNum == 3){\n\t\t\tallAmount = _betAmount.mul(winOdd).div(100);//allAmount = _betAmount*winOdd/100\n\t\t\twinPooling = winPooling.add(allAmount);\n\t\t\t_odd  = winOdd;\n\t\t}else if(_betNum == 1){\n\t\t\tallAmount = _betAmount.mul(loseOdd).div(100);//allAmount = _betAmount*loseOdd/100\n\t\t\tlosePooling = losePooling.add(allAmount);\n\t\t\t_odd = loseOdd;\n\t\t}else if(_betNum == 0){\n\t\t\tallAmount = _betAmount.mul(sameOdd).div(100);//allAmount = _betAmount*sameOdd/100\n\t\t\tsamePooling = samePooling.add(allAmount);\n\t\t\t_odd = sameOdd;\n\t\t}\n    }\n\t\n    event OnOpenGameResult(uint indexed _gameID,uint indexed _palyNo, address _player, uint _gameResult, uint _eventTime, uint eventId);\n    function openGameLoop() public returns(bool _result){\n\t\tlock();\n        _result =  _openGameLoop();\n        unLock();\n    }\n\n    function _openGameLoop() private returns(bool _result){\n        _result = false;\n        _checkOpenGame();\n\t\tuint256 allAmount = 0;\n\t\tfor(uint i = 0; nextRewardPlayNo < playNo && i < currentRewardNum; i++ ){\n\t\t\tbetInfo storage p = playerBetInfoOf[nextRewardPlayNo];\n\t\t\tif(!p.IsReturnAward){\n\t\t\t\t_cashPrize(p, allAmount,nextRewardPlayNo);\n\t\t\t}\n\t\t\tnextRewardPlayNo = nextRewardPlayNo.add(1);\n\t\t}\n\t\tif(unpayPooling == 0 && _canSetGameOver()){\n\t\t\tuserTokenOf[currentBanker] = userTokenOf[currentBanker].add(userTokenOf[this]);\n\t\t\tuserTokenOf[this] = 0;\n\t\t\tgameOver = true;\n\t\t}\n\t\t_result = true;\n    }\n\t\n\tfunction openGamePlayNo(uint _playNo) public returns(bool _result){\n\t\tlock();\n        _result =  _openGamePlayNo(_playNo);\n        unLock();\n    }\n\t\n    function _openGamePlayNo(uint _playNo) private returns(bool _result){\n        _result = false;\n\t\trequire(_playNo >= gameBeginPlayNo && _playNo < playNo);\n\t\t_checkOpenGame();\n\t\t\n\t\tbetInfo storage p = playerBetInfoOf[_playNo];\n\t\trequire(!p.IsReturnAward);\n\t\t\n\t\tuint256 allAmount = 0;\n\t\t_cashPrize(p, allAmount,_playNo);\n\t\t\n\t\tif(unpayPooling == 0 && _canSetGameOver()){\n\t\t\tuserTokenOf[currentBanker] = userTokenOf[currentBanker].add(userTokenOf[this]);\n\t\t\tuserTokenOf[this] = 0;\n\t\t\tgameOver = true;\n\t\t}\n\t\t_result = true;\n    }\n\t\n\tfunction openGamePlayNos(uint[] _playNos) public returns(bool _result){\n\t\tlock();\n        _result =  _openGamePlayNos(_playNos);\n        unLock();\n    }\n\t\n    function _openGamePlayNos(uint[] _playNos) private returns(bool _result){\n        _result = false;\n        _checkOpenGame();\n\t\tuint256 allAmount = 0;\n\t\tfor (uint _index = 0; _index < _playNos.length; _index++) {\n\t\t\tuint _playNo = _playNos[_index];\n\t\t\tif(_playNo >= gameBeginPlayNo && _playNo < playNo){\n\t\t\t\tbetInfo storage p = playerBetInfoOf[_playNo];\n\t\t\t\tif(!p.IsReturnAward){\n\t\t\t\t\t_cashPrize(p, allAmount,_playNo);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(unpayPooling == 0 && _canSetGameOver()){\n\t\t\tuserTokenOf[currentBanker] = userTokenOf[currentBanker].add(userTokenOf[this]);\n\t\t\tuserTokenOf[this] = 0;\n\t\t\tgameOver = true;\n\t\t}\n\t\t_result = true;\n    }\n\t\n\tfunction openGameRange(uint _beginPlayNo, uint _endPlayNo) public returns(bool _result){\n\t\tlock();\n        _result =  _openGameRange(_beginPlayNo, _endPlayNo);\n        unLock();\n    }\n\t\n    function _openGameRange(uint _beginPlayNo, uint _endPlayNo) private returns(bool _result){\n        _result = false;\n\t\trequire(_beginPlayNo < _endPlayNo);\n\t\trequire(_beginPlayNo >= gameBeginPlayNo && _endPlayNo < playNo);\n\t\t\n\t\t_checkOpenGame();\n\t\tuint256 allAmount = 0;\n\t\tfor (uint _indexPlayNo = _beginPlayNo; _indexPlayNo <= _endPlayNo; _indexPlayNo++) {\n\t\t\tbetInfo storage p = playerBetInfoOf[_indexPlayNo];\n\t\t\tif(!p.IsReturnAward){\n\t\t\t\t_cashPrize(p, allAmount,_indexPlayNo);\n\t\t\t}\n\t\t}\n\t\tif(unpayPooling == 0 && _canSetGameOver()){\n\t\t\tuserTokenOf[currentBanker] = userTokenOf[currentBanker].add(userTokenOf[this]);\n\t\t\tuserTokenOf[this] = 0;\n\t\t\tgameOver = true;\n\t\t}\n\t\t_result = true;\n    }\n\t\n\tfunction _checkOpenGame() private{\n\t\trequire(!gameOver);\n\t\trequire( gameResult == loseNum || gameResult == winNum || gameResult == sameNum);\n\t\trequire(betLastTime + 90 minutes < now);\n\t\t\n\t\tif(unpayPooling > userTokenOf[this]){\n\t\t\tuint shortOf = unpayPooling.sub(userTokenOf[this]);\n\t\t\tif(shortOf > userTokenOf[currentBanker]){\n\t\t\t\tshortOf = userTokenOf[currentBanker];\n\t\t\t}\n\t\t\tuserTokenOf[currentBanker] = userTokenOf[currentBanker].sub(shortOf);\n\t\t\tuserTokenOf[this] = userTokenOf[this].add(shortOf);\n\t\t}\n\t}\n\t\n\tfunction _cashPrize(betInfo storage _p, uint256 _allAmount,uint _playNo) private{\n\t\tif(_p.BetNum == gameResult){\n\t\t\t_allAmount = _p.BetAmount.mul(_p.Odd).div(100);\n\t\t\t_allAmount = _allAmount.sub(_p.loseToken);\n\t\t\tif(userTokenOf[this] >= _allAmount){\n\t\t\t\t_p.IsReturnAward = true;\n\t\t\t\tuserTokenOf[_p.Player] = userTokenOf[_p.Player].add(_allAmount);\n\t\t\t\tuserTokenOf[this] = userTokenOf[this].sub(_allAmount);\n\t\t\t\tunpayPooling = unpayPooling.sub(_allAmount);\n\t\t\t\temit OnOpenGameResult(gameID,_playNo, msg.sender, gameResult, now, getEventId());\n\t\t\t\tif(_p.BetNum == 3){\n\t\t\t\t\twinPooling = winPooling.sub(_allAmount);\n\t\t\t\t}else if(_p.BetNum == 1){\n\t\t\t\t\tlosePooling = losePooling.sub(_allAmount);\n\t\t\t\t}else if(_p.BetNum == 0){\n\t\t\t\t\tsamePooling = samePooling.sub(_allAmount);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t_p.loseToken = _p.loseToken.add(userTokenOf[this]);\n\t\t\t\tuserTokenOf[_p.Player] = userTokenOf[_p.Player].add(userTokenOf[this]);\n\t\t\t\tunpayPooling = unpayPooling.sub(userTokenOf[this]);\n\t\t\t\tif(_p.BetNum == 3){\n\t\t\t\t\twinPooling = winPooling.sub(userTokenOf[this]);\n\t\t\t\t}else if(_p.BetNum == 1){\n\t\t\t\t\tlosePooling = losePooling.sub(userTokenOf[this]);\n\t\t\t\t}else if(_p.BetNum == 0){\n\t\t\t\t\tsamePooling = samePooling.sub(userTokenOf[this]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tuserTokenOf[this] = 0;\n\t\t\t}\n\t\t}else{\n\t\t\t_p.IsReturnAward = true;\n\t\t\temit OnOpenGameResult(gameID,_playNo, msg.sender, gameResult, now, getEventId());\n\t\t\t_allAmount = _p.BetAmount.mul(_p.Odd).div(100);\n\t\t\t//_allAmount = _allAmount.sub(_p.loseToken);\n\t\t\tif(_p.BetNum == 3){\n\t\t\t\twinPooling = winPooling.sub(_allAmount);\n\t\t\t}else if(_p.BetNum == 1){\n\t\t\t\tlosePooling = losePooling.sub(_allAmount);\n\t\t\t}else if(_p.BetNum == 0){\n\t\t\t\tsamePooling = samePooling.sub(_allAmount);\n\t\t\t}\n\t\t\t\n\t\t\tif(now < donGameGiftLineTime){\n\t\t\t\tDonQuixoteToken.sendGameGift(_p.Player);\n\t\t\t}\n\t\t}\n\t}\n\t\n\n\tfunction _canSetGameOver() private view returns(bool){\n\t\treturn winPooling<100 && losePooling<100 && samePooling<100;//todo\n\t}\n\t\n    function _withdrawToken(address _from, uint256 _amount) internal {\n        require(_from != 0x0);\n\t\trequire(_from != currentBanker || gameOver);\n\t\tif(_amount > 0 && _amount <= userTokenOf[_from]){  \n\t\t\tuserTokenOf[_from] = userTokenOf[_from].sub(_amount);\n\t\t\tDonQuixoteToken.transfer(_from, _amount);\n\t\t}\n    }\n\t\n\t\n\tfunction transEther() public onlyOwner()\n    {\n        msg.sender.transfer(address(this).balance);\n    }\n\t\n\tfunction () public payable {        //fall back function\n    }\n\n}",
        "debug": "calldata_SoccerBet_4 + calldata_SoccerBet_4: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_8: 0x0\ncaller: 0x0\ncalldata_SoccerBet_0: 0x26c4fa3d00000000000000000000000000000000000000000000000000000000\ncalldatasize_SoccerBet: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setOfficialGameUrl(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/34/0x1ce41d9f3e2c211d3ff301dcc4b4776151e4a9ed.sol",
        "function": "setOfficialGameUrl(string)",
        "lineno": 143,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 20175,
        "code": "QuixoteToken != 0x0);\n\t\tgameName = _gameName;\n\t\tbankerDepositPer = _bankerDepositPer;\n        DonQuixoteToken = IDonQuixoteToken(_DonQuixoteToken);\n        owner = msg.sender;\n    }\n\n\tuint public unpayPooling = 0;\n\tuint public losePooling = 0;\n\tuint public winPooling = 0;\n\tuint public samePooling = 0;\n\t\n\tuint public bankerDepositPer = 20;\n\n    address public auction;\n\tfunction setAuction(address _newAuction) public onlyOwner{\n        auction = _newAuction;\n    }\n    modifier onlyAuction {\n\t    require(msg.sender == auction);\n        _;\n    }\n\t\n    modifier onlyBanker {\n        require(msg.sender == currentBanker);\n        require(bankerBeginTime <= now);\n        require(now < bankerEndTime);\n        _;\n    }    \n\t\n\tfunction canSetBanker() public view returns (bool _result){\n        _result =  false;\n\t\tif(now < bankerEndTime){\n\t\t\treturn;\n\t\t}\n\t\tif(userTokenOf[this] == 0){\n\t\t\t_result = true;\n\t\t}\n    }\n\t\n\tevent OnSetNewBanker(uint indexed _gameID , address _caller, address _banker, uint _beginTime, uint _endTime, uint _errInfo, uint _eventTime, uint eventId);\n    function setBanker(address _banker, uint _beginTime, uint _endTime) public onlyAuction returns(bool _result)\n    {\n        _result = false;\n        require(_banker != 0x0);\n\n        if(now < bankerEndTime){\n            emit OnSetNewBanker(gameID, msg.sender, _banker,  _beginTime,  _endTime, 1, now, getEventId());//\"bankerEndTime > now\"\n            return;\n        }\n\t\t\n\t\tif(userTokenOf[this] > 0){\n\t\t\temit OnSetNewBanker(gameID, msg.sender, _banker,  _beginTime,  _endTime, 5, now, getEventId());//\"userTokenOf[this] > 0\"\n\t\t\treturn;\n\t\t}\n        \n        if(_beginTime > now){\n\t\t\temit OnSetNewBanker(gameID, msg.sender, _banker,  _beginTime,  _endTime, 3, now, getEventId());//'_beginTime > now'\n            return;\n        }\n\n        if(_endTime <= now){\n\t\t\temit OnSetNewBanker(gameID, msg.sender, _banker,  _beginTime,  _endTime, 4, now, getEventId());//'_endTime <= now'\n            return;\n        }\n\t\t\n\t\tif(now < donGameGiftLineTime){\n            DonQuixoteToken.logPlaying(_banker);\n        }\n        currentBanker = _banker;\n        bankerBeginTime = _beginTime;\n        bankerEndTime =  _endTime;\n\t\n\t\tunpayPooling = 0;\n\t\tlosePooling = 0;\n\t\twinPooling = 0;\n\t\tsamePooling = 0;\n\t\t\n\t\tgameResult = 9;\n\t\t\n\t\tgameOver = true;\n\n\t\temit OnSetNewBanker(gameID, msg.sender, _banker,  _beginTime,  _endTime, 0, now, getEventId());\n        _result = true;\n    }\n\n\tstring public team1;\n    string public team2;\n\t\n    uint public constant loseNum = 1;\n    uint public constant winNum = 3;\n    uint public constant sameNum = 0;\n\n    uint public loseOdd;\n    uint public winOdd;\n    uint public sameOdd;\n\n    uint public betLastTime;\n\n    uint public playNo = 1;\n    uint public gameID = 0;\n\n    uint public gameBeginPlayNo;\n\n    uint public gameResult = 9;\n\n    uint  public gameBeginTime;\n\n    uint256 public gameMaxBetAmount;\n    uint256 public gameMinBetAmount;\n    bool public gameOver = true;\n\t\n\tuint public nextRewardPlayNo=1;\n    uint public currentRewardNum = 100;\n\t\n\tuint public donGameGiftLineTime =  now + 90 days;\n\t\n\taddress public decider;\n    function setDecider(address _decider) public onlyOwner{\t\n        decider = _decider;\n    }\n    modifier onlyDecider{\n        require(msg.sender == decider);\n        _;\n    }\n\tfunction setGameResult(uint _gameResult) public onlyDecider{\n\t\trequire(!gameOver);\n\t\trequire(betLastTime + 90 minutes < now);\n\t\trequire(gameResult == 9);\n\t\trequire( _gameResult == loseNum || _gameResult == winNum || _gameResult == sameNum);\n\t\tgameResult = _gameResult;\n\t\tif(gameResult == 3){\n\t\t\tunpayPooling = winPooling;\n\t\t}else if(gameResult == 1){\n\t\t\tunpayPooling = losePooling;\n\t\t}else if(gameResult == 0){\n\t\t\tunpayPooling = samePooling;\n\t\t}\n\t}\n\n    event OnNewGame(uint indexed _gameID, address _banker , uint _betLastTime, uint _gameBeginTime, uint256 _gameMinBetAmount, uint256 _gameMaxBetAmount, uint _eventTime, uint eventId);\n\tevent OnGameInfo(uint indexed _gameID, string _team1, string _team2, uint _loseOdd, uint _winOdd, uint _sameOdd, uint _eventTime, uint eventId);\n    function newGame(string _team1, string _team2, uint _loseOdd, uint _winOdd, uint _sameOdd, uint _betLastTime, uint256 _gameMinBetAmount, uint256 _gameMaxBetAmount) public onlyBanker returns(bool _result){ //\u5f00\u5c40\n        require(bytes(_team1).length < 100);\n\t\trequire(bytes(_team2).length < 100);\n\t\t\n\t\trequire(gameOver);\n        require(now > bankerBeginTime);\n\t\trequire(_gameMinBetAmount >= 10000000);\n        require(_gameMaxBetAmount >= _gameMinBetAmount);\n\t\trequire(now < _betLastTime);\n\t\trequire(_betLastTime+ 1 days < bankerEndTime);\n\n        _result = _newGame(_team1, _team2, _loseOdd, _winOdd, _sameOdd, _betLastTime, _gameMinBetAmount,  _gameMaxBetAmount);\n    }\n\n    function _newGame(string _team1, string _team2, uint _loseOdd, uint _winOdd, uint _sameOdd, uint _betLastTime, uint256 _gameMinBetAmount, uint256 _gameMaxBetAmount) private  returns(bool _result){\n        _result = false;\n\t\tgameID = gameID.add(1);\n\t\t\n\t\tteam1 = _team1;\n        team2 = _team2;\n\t\tloseOdd = _loseOdd;\n\t\twinOdd = _winOdd;\n\t\tsameOdd = _sameOdd;\n\t\temit OnGameInfo(gameID, team1, team2, loseOdd, winOdd, sameOdd, now, getEventId());\n\t\t\n\t\tbetLastTime = _betLastTime;\n        gameBeginTime = now;\n\t\tgameMinBetAmount = _gameMinBetAmount;\n        gameMaxBetAmount = _gameMaxBetAmount;\n\t\temit OnNewGame(gameID, msg.sender, betLastTime,  gameBeginTime, gameMinBetAmount,   gameMaxBetAmount, now, getEventId());\n        \n        gameBeginPlayNo = playNo;\n        gameResult = 9;\n        gameOver = false;\n\t\tunpayPooling = 0;\n\t\tlosePooling = 0;\n\t\twinPooling = 0;\n\t\tsamePooling = 0;\n\n        _result = true;\n    }\n\t\n    event OnSetOdd(uint indexed _gameID, uint _winOdd, uint _loseOdd, uint _sameOdd, uint _eventTime, uint eventId);\n\tfunction setOdd(uint _winOdd, uint _loseOdd, uint _sameOdd) onlyBanker public{\t\t\n\t\twinOdd = _winOdd;\n\t\tloseOdd = _loseOdd;\n\t\tsameOdd = _sameOdd;\t\n\t\temit OnSetOdd(gameID, winOdd, loseOdd, sameOdd, now, getEventId());\n\t}\n\n    struct betInfo\n    {\n        uint Odd;\n        address Player;\n        uint BetNum;\n        uint256 BetAmount;\n\t\tuint loseToken;\n        bool IsReturnAward;\n    }\n\n    mapping (uint => betInfo) public playerBetInfoOf;\n\n    event OnPlay(uint indexed _gameID, string _gameName, address _player, uint odd, string _team1, uint _betNum, uint256 _betAmount, uint _playNo, uint _eventTime, uint eventId);\n    function play(uint _betNum, uint256 _betAmount) public returns(bool _result){ \n        _result = _play(_betNum, _betAmount);\n    }\n\n    function _play(uint _betNum, uint256 _betAmount) private  returns(bool _result){\n        _result = false;\n        require(!gameOver);\n\n        require(_betNum == loseNum || _betNum == winNum || _betNum == sameNum);\n        require(msg.sender != currentBanker);\n\n        require(now < betLastTime);\n\t\t\n\t\trequire(_betAmount >= gameMinBetAmount);\n        if (_betAmount > gameMaxBetAmount){\n            _betAmount = gameMaxBetAmount;\n        }\n\n\t\t_betAmount = _betAmount / 100 * 100;\n\n        if(userTokenOf[msg.sender] < _betAmount){\n            depositToken(_betAmount.sub(userTokenOf[msg.sender]));\n        }\n        \n        uint BankerAmount = _betAmount.mul(bankerDepositPer).div(100);\n        require(userTokenOf[msg.sender] >= _betAmount);\n        require(userTokenOf[currentBanker] >= BankerAmount);\n\n\n        uint _odd = seekOdd(_betNum,_betAmount);\n\n        betInfo memory bi= betInfo({\n            Odd :_odd,\n            Player :  msg.sender,\n            BetNum : _betNum,\n            BetAmount : _betAmount,\n            loseToken : 0,\n            IsReturnAward: false\n        });\n\n        playerBetInfoOf[playNo] = bi;\n        userTokenOf[msg.sender] = userTokenOf[msg.sender].sub(_betAmount);\n\t\tuserTokenOf[this] = userTokenOf[this].add(_betAmount);\n        userTokenOf[currentBanker] = userTokenOf[currentBanker].sub(BankerAmount);\n\t\tuserTokenOf[this] = userTokenOf[this].add(BankerAmount);\n        emit OnPlay(gameID, gameName, msg.sender, _odd, team1, _betNum, _betAmount, playNo, now, getEventId());\n\n        playNo = playNo.add(1); \n\t\tif(now < donGameGiftLineTime){\n            DonQuixoteToken.logPlaying(msg.sender);\n        }\n\t\t\n        _result = true;\n    }\n\t\n\tfunction seekOdd(uint _betNum, uint _betAmount) private returns (uint _odd){\n\t\tuint allAmount = 0;\n\t\tif(_betNum == 3){\n\t\t\tallAmount = _betAmount.mul(winOdd).div(100);//allAmount = _betAmount*winOdd/100\n\t\t\twinPooling = winPooling.add(allAmount);\n\t\t\t_odd  = winOdd;\n\t\t}else if(_betNum == 1){\n\t\t\tallAmount = _betAmount.mul(loseOdd).div(100);//allAmount = _betAmount*loseOdd/100\n\t\t\tlosePooling = losePooling.add(allAmount);\n\t\t\t_odd = loseOdd;\n\t\t}else if(_betNum == 0){\n\t\t\tallAmount = _betAmount.mul(sameOdd).div(100);//allAmount = _betAmount*sameOdd/100\n\t\t\tsamePooling = samePooling.add(allAmount);\n\t\t\t_odd = sameOdd;\n\t\t}\n    }\n\t\n    event OnOpenGameResult(uint indexed _gameID,uint indexed _palyNo, address _player, uint _gameResult, uint _eventTime, uint eventId);\n    function openGameLoop() public returns(bool _result){\n\t\tlock();\n        _result =  _openGameLoop();\n        unLock();\n    }\n\n    function _openGameLoop() private returns(bool _result){\n        _result = false;\n        _checkOpenGame();\n\t\tuint256 allAmount = 0;\n\t\tfor(uint i = 0; nextRewardPlayNo < playNo && i < currentRewardNum; i++ ){\n\t\t\tbetInfo storage p = playerBetInfoOf[nextRewardPlayNo];\n\t\t\tif(!p.IsReturnAward){\n\t\t\t\t_cashPrize(p, allAmount,nextRewardPlayNo);\n\t\t\t}\n\t\t\tnextRewardPlayNo = nextRewardPlayNo.add(1);\n\t\t}\n\t\tif(unpayPooling == 0 && _canSetGameOver()){\n\t\t\tuserTokenOf[currentBanker] = userTokenOf[currentBanker].add(userTokenOf[this]);\n\t\t\tuserTokenOf[this] = 0;\n\t\t\tgameOver = true;\n\t\t}\n\t\t_result = true;\n    }\n\t\n\tfunction openGamePlayNo(uint _playNo) public returns(bool _result){\n\t\tlock();\n        _result =  _openGamePlayNo(_playNo);\n        unLock();\n    }\n\t\n    function _openGamePlayNo(uint _playNo) private returns(bool _result){\n        _result = false;\n\t\trequire(_playNo >= gameBeginPlayNo && _playNo < playNo);\n\t\t_checkOpenGame();\n\t\t\n\t\tbetInfo storage p = playerBetInfoOf[_playNo];\n\t\trequire(!p.IsReturnAward);\n\t\t\n\t\tuint256 allAmount = 0;\n\t\t_cashPrize(p, allAmount,_playNo);\n\t\t\n\t\tif(unpayPooling == 0 && _canSetGameOver()){\n\t\t\tuserTokenOf[currentBanker] = userTokenOf[currentBanker].add(userTokenOf[this]);\n\t\t\tuserTokenOf[this] = 0;\n\t\t\tgameOver = true;\n\t\t}\n\t\t_result = true;\n    }\n\t\n\tfunction openGamePlayNos(uint[] _playNos) public returns(bool _result){\n\t\tlock();\n        _result =  _openGamePlayNos(_playNos);\n        unLock();\n    }\n\t\n    function _openGamePlayNos(uint[] _playNos) private returns(bool _result){\n        _result = false;\n        _checkOpenGame();\n\t\tuint256 allAmount = 0;\n\t\tfor (uint _index = 0; _index < _playNos.length; _index++) {\n\t\t\tuint _playNo = _playNos[_index];\n\t\t\tif(_playNo >= gameBeginPlayNo && _playNo < playNo){\n\t\t\t\tbetInfo storage p = playerBetInfoOf[_playNo];\n\t\t\t\tif(!p.IsReturnAward){\n\t\t\t\t\t_cashPrize(p, allAmount,_playNo);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(unpayPooling == 0 && _canSetGameOver()){\n\t\t\tuserTokenOf[currentBanker] = userTokenOf[currentBanker].add(userTokenOf[this]);\n\t\t\tuserTokenOf[this] = 0;\n\t\t\tgameOver = true;\n\t\t}\n\t\t_result = true;\n    }\n\t\n\tfunction openGameRange(uint _beginPlayNo, uint _endPlayNo) public returns(bool _result){\n\t\tlock();\n        _result =  _openGameRange(_beginPlayNo, _endPlayNo);\n        unLock();\n    }\n\t\n    function _openGameRange(uint _beginPlayNo, uint _endPlayNo) private returns(bool _result){\n        _result = false;\n\t\trequire(_beginPlayNo < _endPlayNo);\n\t\trequire(_beginPlayNo >= gameBeginPlayNo && _endPlayNo < playNo);\n\t\t\n\t\t_checkOpenGame();\n\t\tuint256 allAmount = 0;\n\t\tfor (uint _indexPlayNo = _beginPlayNo; _indexPlayNo <= _endPlayNo; _indexPlayNo++) {\n\t\t\tbetInfo storage p = playerBetInfoOf[_indexPlayNo];\n\t\t\tif(!p.IsReturnAward){\n\t\t\t\t_cashPrize(p, allAmount,_indexPlayNo);\n\t\t\t}\n\t\t}\n\t\tif(unpayPooling == 0 && _canSetGameOver()){\n\t\t\tuserTokenOf[currentBanker] = userTokenOf[currentBanker].add(userTokenOf[this]);\n\t\t\tuserTokenOf[this] = 0;\n\t\t\tgameOver = true;\n\t\t}\n\t\t_result = true;\n    }\n\t\n\tfunction _checkOpenGame() private{\n\t\trequire(!gameOver);\n\t\trequire( gameResult == loseNum || gameResult == winNum || gameResult == sameNum);\n\t\trequire(betLastTime + 90 minutes < now);\n\t\t\n\t\tif(unpayPooling > userTokenOf[this]){\n\t\t\tuint shortOf = unpayPooling.sub(userTokenOf[this]);\n\t\t\tif(shortOf > userTokenOf[currentBanker]){\n\t\t\t\tshortOf = userTokenOf[currentBanker];\n\t\t\t}\n\t\t\tuserTokenOf[currentBanker] = userTokenOf[currentBanker].sub(shortOf);\n\t\t\tuserTokenOf[this] = userTokenOf[this].add(shortOf);\n\t\t}\n\t}\n\t\n\tfunction _cashPrize(betInfo storage _p, uint256 _allAmount,uint _playNo) private{\n\t\tif(_p.BetNum == gameResult){\n\t\t\t_allAmount = _p.BetAmount.mul(_p.Odd).div(100);\n\t\t\t_allAmount = _allAmount.sub(_p.loseToken);\n\t\t\tif(userTokenOf[this] >= _allAmount){\n\t\t\t\t_p.IsReturnAward = true;\n\t\t\t\tuserTokenOf[_p.Player] = userTokenOf[_p.Player].add(_allAmount);\n\t\t\t\tuserTokenOf[this] = userTokenOf[this].sub(_allAmount);\n\t\t\t\tunpayPooling = unpayPooling.sub(_allAmount);\n\t\t\t\temit OnOpenGameResult(gameID,_playNo, msg.sender, gameResult, now, getEventId());\n\t\t\t\tif(_p.BetNum == 3){\n\t\t\t\t\twinPooling = winPooling.sub(_allAmount);\n\t\t\t\t}else if(_p.BetNum == 1){\n\t\t\t\t\tlosePooling = losePooling.sub(_allAmount);\n\t\t\t\t}else if(_p.BetNum == 0){\n\t\t\t\t\tsamePooling = samePooling.sub(_allAmount);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t_p.loseToken = _p.loseToken.add(userTokenOf[this]);\n\t\t\t\tuserTokenOf[_p.Player] = userTokenOf[_p.Player].add(userTokenOf[this]);\n\t\t\t\tunpayPooling = unpayPooling.sub(userTokenOf[this]);\n\t\t\t\tif(_p.BetNum == 3){\n\t\t\t\t\twinPooling = winPooling.sub(userTokenOf[this]);\n\t\t\t\t}else if(_p.BetNum == 1){\n\t\t\t\t\tlosePooling = losePooling.sub(userTokenOf[this]);\n\t\t\t\t}else if(_p.BetNum == 0){\n\t\t\t\t\tsamePooling = samePooling.sub(userTokenOf[this]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tuserTokenOf[this] = 0;\n\t\t\t}\n\t\t}else{\n\t\t\t_p.IsReturnAward = true;\n\t\t\temit OnOpenGameResult(gameID,_playNo, msg.sender, gameResult, now, getEventId());\n\t\t\t_allAmount = _p.BetAmount.mul(_p.Odd).div(100);\n\t\t\t//_allAmount = _allAmount.sub(_p.loseToken);\n\t\t\tif(_p.BetNum == 3){\n\t\t\t\twinPooling = winPooling.sub(_allAmount);\n\t\t\t}else if(_p.BetNum == 1){\n\t\t\t\tlosePooling = losePooling.sub(_allAmount);\n\t\t\t}else if(_p.BetNum == 0){\n\t\t\t\tsamePooling = samePooling.sub(_allAmount);\n\t\t\t}\n\t\t\t\n\t\t\tif(now < donGameGiftLineTime){\n\t\t\t\tDonQuixoteToken.sendGameGift(_p.Player);\n\t\t\t}\n\t\t}\n\t}\n\t\n\n\tfunction _canSetGameOver() private view returns(bool){\n\t\treturn winPooling<100 && losePooling<100 && samePooling<100;//todo\n\t}\n\t\n    function _withdrawToken(address _from, uint256 _amount) internal {\n        require(_from != 0x0);\n\t\trequire(_from != currentBanker || gameOver);\n\t\tif(_amount > 0 && _amount <= userTokenOf[_from]){  \n\t\t\tuserTokenOf[_from] = userTokenOf[_from].sub(_amount);\n\t\t\tDonQuixoteToken.transfer(_from, _amount);\n\t\t}\n    }\n\t\n\t\n\tfunction transEther() public onlyOwner()\n    {\n        msg.sender.transfer(address(this).balance);\n    }\n\t\n\tfunction () public payable {        //fall back function\n    }\n\n}",
        "debug": "calldata_SoccerBet_4 + calldata_SoccerBet_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_8: 0x0\ncaller: 0x0\ncalldata_SoccerBet_0: 0x26c4fa3d00000000000000000000000000000000000000000000000000000000\ncalldatasize_SoccerBet: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setOfficialGameUrl(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/34/0x1ce41d9f3e2c211d3ff301dcc4b4776151e4a9ed.sol",
        "function": "setOfficialGameUrl(string)",
        "lineno": 143,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}