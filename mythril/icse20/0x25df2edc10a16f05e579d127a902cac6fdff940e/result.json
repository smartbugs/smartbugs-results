{
  "contract": "0x25df2edc10a16f05e579d127a902cac6fdff940e",
  "tool": "mythril",
  "start": 1563230164.2327785,
  "end": 1563230239.3415844,
  "duration": 75.10880589485168,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 594,
        "code": "        }\n    }  \n    \n\t// pause the sale\n    \n    function pause() ifDelegate external {\n        active = false;\n        Paused();\n    }\n    \n    // activate the sale\n\n    function activate() ifDelegate external {\n ",
        "debug": "calldata_SaleCallbackInterface_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_SaleCallbackInterface_0: 0x266ba0200000000000000000000000000000000000000000000000000000000\ncalldatasize_SaleCallbackInterface: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `list(address[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x25df2edc10a16f05e579d127a902cac6fdff940e.sol",
        "function": "list(address[])",
        "lineno": 494,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1084,
        "code": "te(address _delegate) ifCreator external {\n        delegate = _delegate;\n    }\n    \n    function setRestricted(bool _restricted) ifDelegate external {\n        restricted = _restricted;\n    }\n    \n    function setMarketpla",
        "debug": "calldata_SaleCallbackInterface_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_SaleCallbackInterface_0: 0x32cd048700000000000000000000000000000000000000000000000000000000\ncalldatasize_SaleCallbackInterface: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `delist(address[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x25df2edc10a16f05e579d127a902cac6fdff940e.sol",
        "function": "delist(address[])",
        "lineno": 511,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1143,
        "code": "uint256 iterativeTimestamp;\n        uint256 iterativeBonus;\n        \n        // within bonuses, even number",
        "debug": "calldata_SaleCallbackInterface_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_SaleCallbackInterface_0: 0x34bf97ea00000000000000000000000000000000000000000000000000000000\ncalldatasize_SaleCallbackInterface: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setBonuses(uint256[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x25df2edc10a16f05e579d127a902cac6fdff940e.sol",
        "function": "setBonuses(uint256[])",
        "lineno": 541,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1149,
        "code": "uint256 iterativeTimestamp;\n        uint256 iterativeBonus;\n        \n        // within bonuses, even number",
        "debug": "calldata_SaleCallbackInterface_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc\ncalldata_SaleCallbackInterface_0: 0x34bf97ea00000000000000000000000000000000000000000000000000000000\ncalldatasize_SaleCallbackInterface: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setBonuses(uint256[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x25df2edc10a16f05e579d127a902cac6fdff940e.sol",
        "function": "setBonuses(uint256[])",
        "lineno": 541,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 11812,
        "code": "   // address of the contract's creator\n    address public delegate;\t\t// address of an entity allowed to perform administrative functions on behalf of the creator\n    \n    address public marketplace;\t    // address of another smart contract that manages the token and Smart Exchange\n    \n    uint256 public start;\t\t\t// timestamp that the sale begins\n    uint256 public finish;\t\t\t// timestamp that the sale ends\n    uint256 public release;\t\t\t// timestamp that sale participants may \"claim\" their tokens (will be after the finish)\n    \n    uint256 public pricer;\t\t\t// a multiplier (>= 1) used to determine how many tokens (or, really, 10^18 sub-units of that token) to give purchasers\n    uint256 public size;\t\t\t// maximum number of 10^18 sub-units of tokens that can be purchased/granted during the sale\n    \n    bool public restricted;\t\t    // whether purchasers and recipients of tokens must be whitelisted manually prior to participating in the sale\n\n    bool public active;\t\t\t    // whether individuals are allowed to purchase tokens -- if false, they cannot.  if true, they can or cannot.  \n    \t\t\t\t\t\t\t\t// other factors, like start/finish, size, and others can restrict participation as well, even if active = true.\n    \t\t\t\t\t\t\t\t// this also can remain true indefinitely, even if the token sale has been cancelled or has completed.\n    \t\t\t\t\t\t\t\t\n    \n    int8 public progress;\t\t\t// -1 = token sale cancelled, 0 = token sale ongoing, 1 = token sale certified (can withdraw ETH while sale is live), 2 = token sale completed\n    \n    uint256 public tokens;\t\t\t// number of sub-tokens that have been purchased/granted during the sale.  purchases/grants can be reversed while progress = 0 || progress = 1 resulting in tokens going down\n    uint256 public value;\t\t\t// number of sub-ether (wei) that have been contributed during the sale.  purchases can be resversed while progress = 0 || progress = 1 resulting in value going down\n    \n    uint256 public withdrawls;\t\t// the number of sub-ether (wei) that have been withdrawn by the contract owner\n    uint256 public reserves;\t\t// the number of sub-ether (wei) that have been sent to serve as reserve in the marketplace\n    \n    mapping(address => bool) public participants;\t\t\t// mapping to record who has participated in the sale (purchased/granted)\n    address[] public participantIndex;\t\t\t\t\t\t// index of participants\n    \n    mapping(address => uint256) public participantTokens;\t// sub-tokens purchased/granted to each participant\n    mapping(address => uint256) public participantValues;\t// sub-ether contributed by each participant\n    \n    mapping(address => bool) public participantRefunds;\t    // mapping to record who has been awarded a refund after a cancelled sale\n    mapping(address => bool) public participantClaims;\t\t// mapping to record who has claimed their tokens after a completed sale\n    \n    mapping(address => bool) public whitelist;\t\t\t\t// mapping to record who has been approved to participate in a \"restricted\" sale\n    \n    uint256[] public bonuses;\t\t\t\t\t\t\t\t// stores bonus percentages, where even numbered elements store timestamps and odd numbered elements store bonus percentages\n    \n    bool public mutable;\t\t\t\t\t\t\t\t\t// whether certain properties (like finish and release) of the sale can be updated to increase the liklihood of a successful token sale for all parties involved\n    \n    modifier ifCreator { require(msg.sender == creator); _; }\t\t// if the caller created the contract...\n    modifier ifDelegate { require(msg.sender == delegate); _; }\t\t// if the caller is currently the appointed delegate...\n    modifier ifMutable { require(mutable); _; }\t\t\t\t\t\t// if the certain properties of the sale can be changed....\n    \n    event Created();\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the contract was created\n    event Bought(address indexed _buyer, address indexed _recipient, uint256 _tokens, uint256 _value);\t\t// an individual bought tokens\n    event Claimed(address indexed _recipient, uint256 _tokens);\t\t\t\t\t\t\t\t\t\t\t\t// an individual claimed tokens after the completion of the sale and after tokens were scheduled for release\n    event Refunded(address indexed _recipient, uint256 _value);\t\t\t\t\t\t\t\t\t\t\t\t// an individual requested a refund of the ETH they contributed after a cancelled token sale\n    event Reversed(address indexed _recipient, uint256 _tokens, uint256 _value);\t\t\t\t\t\t\t// an individual was sent the ETH they contributed to the sale and will not receive tokens\n    event Granted(address indexed _recipient, uint256 _tokens);\t\t\t\t\t\t\t\t\t\t\t\t// an individual was granted tokens, without contributing ETH\n    event Withdrew(address _recipient, uint256 _value);\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the contract creator withdrew ETH from the token sale\n    event Completed(uint256 _tokens, uint256 _value, uint256 _reserves);\t\t\t\t\t\t\t\t\t// the contract creator signaled that the sale completed successfuly\n    event Certified(uint256 _tokens, uint256 _value);\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the contract creator certified the sale\n    event Cancelled(uint256 _tokens, uint256 _value);\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the contract creator cancelled the sale\n    event Listed(address _participant);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// an individual was added to the whitelist\n    event Delisted(address _participant);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// an individual was removed from the whitelist\n    event Paused();\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the sale was paused (active = false)\n    event Activated();    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the sale was activated (active = true)\n\n    function Sale() {\n        \n        creator = msg.sender;\n        delegate = msg.sender;\n        \n        start = 1;\t\t\t\t\t            // contributions may be made as soon as the contract is published\n        finish = 1535760000;\t\t\t\t    // the sale continues through 09/01/2018 @ 00:00:00\n        release = 1536969600;\t\t\t\t    // tokens will be available to participants starting 09/15/2018 @ 00:00:00\n        \n        pricer = 100000;\t\t\t\t\t    // each ETH is worth 100,000 tokens\n        \n        size = 10 ** 18 * pricer * 2000 * 2;\t// 2,000 ETH, plus a 100% buffer to account for the possibility of a 50% decrease in ETH value during the sale\n\n        restricted = false;                     // the sale accepts contributions from everyone.  \n                                                // however, participants who do not submit formal KYC verification before the end of the token sale will have their contributions reverted\n    \n        bonuses = [1, 20];                      // the bonus during the pre-sale starts at 20%\n        \n        mutable = true;                         // certain attributes, such as token sale finish and release dates, may be updated to increase the liklihood of a successful token sale for all parties involved\n        active = true;                          // the token sale is active from the point the contract is published in the form of a pre-sale         \n        \n        Created();\n        Activated();\n    }\n    \n    // returns the number of sub-tokens the calling account purchased/was granted\n    \n    function getMyTokenBalance() external constant returns (uint256) {\n        return participantTokens[msg.sender];\n    }\n    \n    // allows an individual to buy tokens (which will not be issued immediately)\n    // individual instructs the tokens to be delivered to a specific account, which may be different than msg.sender\n    \n    function buy(address _recipient) public payable {\n        \n        // _recipient address must not be all 0's\n        \n        require(_recipient != address(0x0));\n\n\t\t// contributor must send more than 1/10 ETH\n\t\t\n        require(msg.value >= 10 ** 17);\n\n\t\t// sale must be considered active\n\t\t\n        require(active);\n\n\t\t// sale must be ongoing or certified\n\n        require(progress == 0 || progress == 1);\n\n\t\t// current timestamp must be greater than or equal to the start of the token sale\n\t\t\n        require(block.timestamp >= start);\n\n\t\t// current timestamp must be less than the end of the token sale\n\t\t\n        require(block.timestamp < finish);\n\t\t\n\t\t// either the token sale isn't restricted, or the sender is on the whitelist\n\n        require((! restricted) || whitelist[msg.sender]);\n        \n        // either the token sale isn't restricted, or the recipient is on the whitelist\n\n        require((! restricted) || whitelist[_recipient]);\n        \n        // multiply sub-ether by the pricer (which will be a whole number >= 1) to get sub-tokens\n\n        uint256 baseTokens = safeMul(msg.value, pricer);\n        \n        // determine how many bonus sub-tokens to award and add that to the base tokens\n        \n        uint256 totalTokens = safeAdd(baseTokens, safeDiv(safeMul(baseTokens, getBonusPercentage()), 100));\n\n\t\t// ensure the purchase does not cause the sale to exceed its maximum size\n\t\t\n        require(safeAdd(tokens, totalTokens) <= size);\n        \n        // if the recipient is new, add them as a participant\n\n        if (! participants[_recipient]) {\n            participants[_recipient] = true;\n            participantIndex.push(_recipient);\n        }\n        \n        // increment the participant's sub-tokens and sub-ether\n\n        participantTokens[_recipient] = safeAdd(participantTokens[_recipient], totalTokens);\n        participantValues[_recipient] = safeAdd(participantValues[_recipient], msg.value);\n\n\t\t// increment sale sub-tokens and sub-ether\n\n        tokens = safeAdd(tokens, totalTokens);\n        value = safeAdd(value, msg.value);\n        \n        // log purchase event\n\n        Bought(msg.sender, _recipient, totalTokens, msg.value);\n    }\n    \n    // token sale participants call this to claim their tokens after the sale is completed and tokens are scheduled for release\n    \n    function claim() external {\n\t    \n\t    // sale must be completed\n        \n        require(progress == 2);\n        \n        // tokens must be scheduled for release\n        \n        require(block.timestamp >= release);\n        \n        // participant must have tokens to claim\n        \n        require(participantTokens[msg.sender] > 0);\n        \n        // participant must not have already claimed tokens\n        \n        require(! participantClaims[msg.sender]);\n        \n\t\t// record that the participant claimed their tokens\n\n        participantClaims[msg.sender] = true;\n        \n        // log the event\n        \n        Claimed(msg.sender, participantTokens[msg.sender]);\n        \n        // call the marketplace contract, which will actually issue the tokens to the participant\n        \n        SaleCallbackInterface(marketplace).handleSaleClaimCallback(msg.sender, participantTokens[msg.sender]);\n    }\n    \n    // token sale participants call this to request a refund if the sale was cancelled\n    \n    function refund() external {\n        \n        // the sale must be cancelled\n        \n        require(progress == -1);\n        \n        // the participant must have contributed ETH\n        \n        require(participantValues[msg.sender] > 0);\n        \n        // the participant must not have already requested a refund\n        \n        require(! participantRefunds[msg.sender]);\n        \n\t\t// record that the participant requested a refund\n        \n        participantRefunds[msg.sender] = true;\n        \n        // log the event\n        \n        Refunded(msg.sender, participantValues[msg.sender]);\n        \n        // transfer contributed ETH back to the participant\n    \n        address(msg.sender).transfer(participantValues[msg.sender]);\n    }    \n    \n    // the contract creator calls this to withdraw contributed ETH to a specific address\n    \n    function withdraw(uint256 _sanity, address _recipient, uint256 _value) ifCreator external {\n        \n        // avoid unintended transaction calls\n        \n        require(_sanity == 100010001);\n        \n        // address must not be 0-value\n        \n        require(_recipient != address(0x0));\n        \n        // token sale must be certified or completed\n        \n        require(progress == 1 || progress == 2);\n        \n        // the amount of ETH in the contract must be greater than the amount the creator is attempting to withdraw\n        \n        require(this.balance >= _value);\n        \n        // increment the amount that's been withdrawn\n        \n        withdrawls = safeAdd(withdrawls, _value);\n        \n        // log the withdrawl\n        \n        Withdrew(_recipient, _value);\n        \n        // send the ETH to the recipient\n        \n        address(_recipient).transfer(_value);\n    } \n    \n    // the contract owner calls this to complete (finalize/wrap up, etc.) the sale\n    \n    function complete(uint256 _sanity, uint256 _value) ifCreator external {\n        \n        // avoid unintended transaction calls\n        \n        require(_sanity == 101010101);\n\t    \n\t    // the sale must be marked as ongoing or certified (aka, not cancelled -1)\n        \n        require(progress == 0 || progress == 1);\n        \n        // the sale can only be completed after the finish time\n        \n        require(block.timestamp >= finish);\n        \n        // ETH is withdrawn in the process and sent to the marketplace contract.  ensure the amount that is being withdrawn is greater than the balance in the smart contract.\n        \n        require(this.balance >= _value);\n        \n        // mark the sale as completed\n        \n        progress = 2;\n        \n        // the amount that is sent to the other contract is added to the ETH reserve.  denote this amount as reserves.\n        \n        reserves = safeAdd(reserves, _value);\n        \n        // log the completion of the sale, including the number of sub-tokens created by the sale, the amount of net sub-eth received during the sale, and the amount of sub-eth to be added to the reserve\n        \n        Completed(tokens, value, _value);\n        \n        // call the marketplace contract, sending the ETH for the reserve and including the number of sub-tokens \n        \n        SaleCallbackInterface(marketplace).handleSaleCompletionCallback.value(_value)(tokens);\n    }    \n    \n    // the creator can certify a sale, meaning it cannot be cancelled, and ETH can be withdrawn from the sale by the creator\n    \n    function certify(uint256 _sanity) ifCreator external {\n        \n        // avoid unintended transaction calls\n        \n        require(_sanity == 101011111);\n\t    \n\t    // the sale must be ongoing\n\t    \n        require(progress == 0);\n        \n        // the sale must have started\n        \n        require(block.timestamp >= start);\n        \n        // record that the sale is certified\n        \n        progress = 1;\n        \n        // log the certification\n        \n        Certified(tokens, value);\n    }\n    \n    // the creator can cancel a sale \n    \n    function cancel(uint256 _sanity) ifCreator external {\n        \n        // avoid unintended transaction calls\n        \n        require(_sanity == 111110101);\n\t    \n\t    // the sale must be ongoing\n\t    \n        require(progress == 0);\n        \n        // record that the sale is cancelled\n        \n        progress = -1;\n        \n        // log the cancellation\n        \n        Cancelled(tokens, value);\n    }    \n    \n    // called by the delegate to reverse purchases/grants for a particular contributor\n    \n    function reverse(address _recipient) ifDelegate external {\n        \n        // the recipient address must not be all 0's\n        \n        require(_recipient != address(0x0));\n        \n        // the sale must be ongoing or certified\n        \n        require(progress == 0 || progress == 1);\n        \n        // the recipient must have contributed ETH and/or received tokens\n        \n        require(participantTokens[_recipient] > 0 || participantValues[_recipient] > 0);\n        \n        uint256 initialParticipantTokens = participantTokens[_recipient];\n        uint256 initialParticipantValue = participantValues[_recipient];\n        \n        // subtract sub-tokens and sub-ether from sale totals\n        \n        tokens = safeSub(tokens, initialParticipantTokens);\n        value = safeSub(value, initialParticipantValue);\n        \n        // reset participant sub-tokens and sub-ether\n        \n        participantTokens[_recipient] = 0;\n        participantValues[_recipient] = 0;\n        \n        // log the reversal, including the initial sub-tokens and initial sub-ether\n        \n        Reversed(_recipient, initialParticipantTokens, initialParticipantValue);\n        \n        // if the participant previously sent ETH, return it\n        \n        if (initialParticipantValue > 0) {\n            address(_recipient).transfer(initialParticipantValue);\n        }\n    }\n    \n    // called by the delegate to grant tokens to a recipient\n    \n    function grant(address _recipient, uint256 _tokens) ifDelegate external {\n        \n       \t// the recipient's address cannot be 0-value\n       \n        require(_recipient != address(0x0));\n\t\t\n\t\t// the sale must be ongoing or certified\n\t\t\n        require(progress == 0 || progress == 1);\n        \n        // if the recipient has not participated previously, add them as a participant\n        \n        if (! participants[_recipient]) {\n            participants[_recipient] = true;\n            participantIndex.push(_recipient);\n        }\n        \n        // add sub-tokens to the recipient's balance\n        \n        participantTokens[_recipient] = safeAdd(participantTokens[_recipient], _tokens);\n        \n        // add sub-tokens to the sale's total\n        \n        tokens = safeAdd(tokens, _tokens);\n        \n        // log the grant\n        \n        Granted(_recipient, _tokens);\n    }    \n    \n    // adds a set of addresses to the whitelist\n    \n    function list(address[] _addresses) ifDelegate external {\n        for (uint256 i = 0; i < _addresses.length; i++) {\n            whitelist[_addresses[i]] = true;\n            Listed(_addresses[i]);\n        }\n    }\n    \n    // removes a set of addresses from the whitelist\n    \n    function delist(address[] _addresses) ifDelegate external {\n        for (uint256 i = 0; i < _addresses.length; i++) {\n            whitelist[_addresses[i]] = false;\n            Delisted(_addresses[i]);\n        }\n    }  \n    \n\t// pause the sale\n    \n    function pause() ifDelegate external {\n        active = false;\n        Paused();\n    }\n    \n    // activate the sale\n\n    function activate() ifDelegate external {\n        active = true;\n        Activated();\n    }\n\n    function setDelegate(address _delegate) ifCreator external {\n        delegate = _delegate;\n    }\n    \n    function setRestricted(bool _restricted) ifDelegate external {\n        restricted = _restricted;\n    }\n    \n    function setMarketplace(address _marketplace) ifCreator ifMutable external {\n        marketplace = _marketplace;\n    }\n    \n    function setBonuses(uint256[] _bonuses) ifDelegate ifMutable external {\n        bonuses = _bonuses;\n    }\n    \n    function setFinish(uint256 _finish) ifDelegate ifMutable external {\n        finish = _finish;\n    }\n\n    function setRelease(uint256 _release) ifDelegate ifMutable external {\n        release = _release;\n    }     \n    \n    // get the current bonus percentage, as a whole number\n    \n    function getBonusPercentage() public constant returns (uint256) {\n        \n        uint256 finalBonus;\n        \n        uint256 iterativeTimestamp;\n        uint256 iterativeBonus;\n        \n        // within bonuses, even numbered elements store timestamps and odd numbered elements store bonus percentages\n        // timestamps are in order from oldest to newest\n        // iterates over the elements and if the timestamp has been surpassed, the bonus percentage is denoted\n        // the last bonus percentage that was denoted, if one was denoted at all, is the correct bonus percentage at this time\n        \n        for (uint256 i = 0; i < bonuses.length; i++) {\n            if (i % 2 == 0) {\n                iterativeTimestamp = bonuses[i];\n            } else {\n                iterativeBonus = bonuses[i];\n                if (block.timestamp >= iterativeTimestamp) {\n                    finalBonus = iterativeBonus;\n                }\n            }\n        } \n        \n        return finalBonus;\n    }    \n    \n    function() public payable {\n        buy(msg.sender);\n    }\n    \n}",
        "debug": "storage_20: 0x31cf72560642a5c9e6c0bc10000000000000000047000001f19807fb80000010\nstorage_21: 0xff00\nstorage_1: 0x0\ncaller: 0x0\ncalldata_SaleCallbackInterface_0: 0x34bf97ea00000000000000000000000000000000000000000000000000000000\ncalldatasize_SaleCallbackInterface: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setBonuses(uint256[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x25df2edc10a16f05e579d127a902cac6fdff940e.sol",
        "function": "setBonuses(uint256[])",
        "lineno": 66,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 11823,
        "code": "   // address of the contract's creator\n    address public delegate;\t\t// address of an entity allowed to perform administrative functions on behalf of the creator\n    \n    address public marketplace;\t    // address of another smart contract that manages the token and Smart Exchange\n    \n    uint256 public start;\t\t\t// timestamp that the sale begins\n    uint256 public finish;\t\t\t// timestamp that the sale ends\n    uint256 public release;\t\t\t// timestamp that sale participants may \"claim\" their tokens (will be after the finish)\n    \n    uint256 public pricer;\t\t\t// a multiplier (>= 1) used to determine how many tokens (or, really, 10^18 sub-units of that token) to give purchasers\n    uint256 public size;\t\t\t// maximum number of 10^18 sub-units of tokens that can be purchased/granted during the sale\n    \n    bool public restricted;\t\t    // whether purchasers and recipients of tokens must be whitelisted manually prior to participating in the sale\n\n    bool public active;\t\t\t    // whether individuals are allowed to purchase tokens -- if false, they cannot.  if true, they can or cannot.  \n    \t\t\t\t\t\t\t\t// other factors, like start/finish, size, and others can restrict participation as well, even if active = true.\n    \t\t\t\t\t\t\t\t// this also can remain true indefinitely, even if the token sale has been cancelled or has completed.\n    \t\t\t\t\t\t\t\t\n    \n    int8 public progress;\t\t\t// -1 = token sale cancelled, 0 = token sale ongoing, 1 = token sale certified (can withdraw ETH while sale is live), 2 = token sale completed\n    \n    uint256 public tokens;\t\t\t// number of sub-tokens that have been purchased/granted during the sale.  purchases/grants can be reversed while progress = 0 || progress = 1 resulting in tokens going down\n    uint256 public value;\t\t\t// number of sub-ether (wei) that have been contributed during the sale.  purchases can be resversed while progress = 0 || progress = 1 resulting in value going down\n    \n    uint256 public withdrawls;\t\t// the number of sub-ether (wei) that have been withdrawn by the contract owner\n    uint256 public reserves;\t\t// the number of sub-ether (wei) that have been sent to serve as reserve in the marketplace\n    \n    mapping(address => bool) public participants;\t\t\t// mapping to record who has participated in the sale (purchased/granted)\n    address[] public participantIndex;\t\t\t\t\t\t// index of participants\n    \n    mapping(address => uint256) public participantTokens;\t// sub-tokens purchased/granted to each participant\n    mapping(address => uint256) public participantValues;\t// sub-ether contributed by each participant\n    \n    mapping(address => bool) public participantRefunds;\t    // mapping to record who has been awarded a refund after a cancelled sale\n    mapping(address => bool) public participantClaims;\t\t// mapping to record who has claimed their tokens after a completed sale\n    \n    mapping(address => bool) public whitelist;\t\t\t\t// mapping to record who has been approved to participate in a \"restricted\" sale\n    \n    uint256[] public bonuses;\t\t\t\t\t\t\t\t// stores bonus percentages, where even numbered elements store timestamps and odd numbered elements store bonus percentages\n    \n    bool public mutable;\t\t\t\t\t\t\t\t\t// whether certain properties (like finish and release) of the sale can be updated to increase the liklihood of a successful token sale for all parties involved\n    \n    modifier ifCreator { require(msg.sender == creator); _; }\t\t// if the caller created the contract...\n    modifier ifDelegate { require(msg.sender == delegate); _; }\t\t// if the caller is currently the appointed delegate...\n    modifier ifMutable { require(mutable); _; }\t\t\t\t\t\t// if the certain properties of the sale can be changed....\n    \n    event Created();\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the contract was created\n    event Bought(address indexed _buyer, address indexed _recipient, uint256 _tokens, uint256 _value);\t\t// an individual bought tokens\n    event Claimed(address indexed _recipient, uint256 _tokens);\t\t\t\t\t\t\t\t\t\t\t\t// an individual claimed tokens after the completion of the sale and after tokens were scheduled for release\n    event Refunded(address indexed _recipient, uint256 _value);\t\t\t\t\t\t\t\t\t\t\t\t// an individual requested a refund of the ETH they contributed after a cancelled token sale\n    event Reversed(address indexed _recipient, uint256 _tokens, uint256 _value);\t\t\t\t\t\t\t// an individual was sent the ETH they contributed to the sale and will not receive tokens\n    event Granted(address indexed _recipient, uint256 _tokens);\t\t\t\t\t\t\t\t\t\t\t\t// an individual was granted tokens, without contributing ETH\n    event Withdrew(address _recipient, uint256 _value);\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the contract creator withdrew ETH from the token sale\n    event Completed(uint256 _tokens, uint256 _value, uint256 _reserves);\t\t\t\t\t\t\t\t\t// the contract creator signaled that the sale completed successfuly\n    event Certified(uint256 _tokens, uint256 _value);\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the contract creator certified the sale\n    event Cancelled(uint256 _tokens, uint256 _value);\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the contract creator cancelled the sale\n    event Listed(address _participant);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// an individual was added to the whitelist\n    event Delisted(address _participant);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// an individual was removed from the whitelist\n    event Paused();\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the sale was paused (active = false)\n    event Activated();    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the sale was activated (active = true)\n\n    function Sale() {\n        \n        creator = msg.sender;\n        delegate = msg.sender;\n        \n        start = 1;\t\t\t\t\t            // contributions may be made as soon as the contract is published\n        finish = 1535760000;\t\t\t\t    // the sale continues through 09/01/2018 @ 00:00:00\n        release = 1536969600;\t\t\t\t    // tokens will be available to participants starting 09/15/2018 @ 00:00:00\n        \n        pricer = 100000;\t\t\t\t\t    // each ETH is worth 100,000 tokens\n        \n        size = 10 ** 18 * pricer * 2000 * 2;\t// 2,000 ETH, plus a 100% buffer to account for the possibility of a 50% decrease in ETH value during the sale\n\n        restricted = false;                     // the sale accepts contributions from everyone.  \n                                                // however, participants who do not submit formal KYC verification before the end of the token sale will have their contributions reverted\n    \n        bonuses = [1, 20];                      // the bonus during the pre-sale starts at 20%\n        \n        mutable = true;                         // certain attributes, such as token sale finish and release dates, may be updated to increase the liklihood of a successful token sale for all parties involved\n        active = true;                          // the token sale is active from the point the contract is published in the form of a pre-sale         \n        \n        Created();\n        Activated();\n    }\n    \n    // returns the number of sub-tokens the calling account purchased/was granted\n    \n    function getMyTokenBalance() external constant returns (uint256) {\n        return participantTokens[msg.sender];\n    }\n    \n    // allows an individual to buy tokens (which will not be issued immediately)\n    // individual instructs the tokens to be delivered to a specific account, which may be different than msg.sender\n    \n    function buy(address _recipient) public payable {\n        \n        // _recipient address must not be all 0's\n        \n        require(_recipient != address(0x0));\n\n\t\t// contributor must send more than 1/10 ETH\n\t\t\n        require(msg.value >= 10 ** 17);\n\n\t\t// sale must be considered active\n\t\t\n        require(active);\n\n\t\t// sale must be ongoing or certified\n\n        require(progress == 0 || progress == 1);\n\n\t\t// current timestamp must be greater than or equal to the start of the token sale\n\t\t\n        require(block.timestamp >= start);\n\n\t\t// current timestamp must be less than the end of the token sale\n\t\t\n        require(block.timestamp < finish);\n\t\t\n\t\t// either the token sale isn't restricted, or the sender is on the whitelist\n\n        require((! restricted) || whitelist[msg.sender]);\n        \n        // either the token sale isn't restricted, or the recipient is on the whitelist\n\n        require((! restricted) || whitelist[_recipient]);\n        \n        // multiply sub-ether by the pricer (which will be a whole number >= 1) to get sub-tokens\n\n        uint256 baseTokens = safeMul(msg.value, pricer);\n        \n        // determine how many bonus sub-tokens to award and add that to the base tokens\n        \n        uint256 totalTokens = safeAdd(baseTokens, safeDiv(safeMul(baseTokens, getBonusPercentage()), 100));\n\n\t\t// ensure the purchase does not cause the sale to exceed its maximum size\n\t\t\n        require(safeAdd(tokens, totalTokens) <= size);\n        \n        // if the recipient is new, add them as a participant\n\n        if (! participants[_recipient]) {\n            participants[_recipient] = true;\n            participantIndex.push(_recipient);\n        }\n        \n        // increment the participant's sub-tokens and sub-ether\n\n        participantTokens[_recipient] = safeAdd(participantTokens[_recipient], totalTokens);\n        participantValues[_recipient] = safeAdd(participantValues[_recipient], msg.value);\n\n\t\t// increment sale sub-tokens and sub-ether\n\n        tokens = safeAdd(tokens, totalTokens);\n        value = safeAdd(value, msg.value);\n        \n        // log purchase event\n\n        Bought(msg.sender, _recipient, totalTokens, msg.value);\n    }\n    \n    // token sale participants call this to claim their tokens after the sale is completed and tokens are scheduled for release\n    \n    function claim() external {\n\t    \n\t    // sale must be completed\n        \n        require(progress == 2);\n        \n        // tokens must be scheduled for release\n        \n        require(block.timestamp >= release);\n        \n        // participant must have tokens to claim\n        \n        require(participantTokens[msg.sender] > 0);\n        \n        // participant must not have already claimed tokens\n        \n        require(! participantClaims[msg.sender]);\n        \n\t\t// record that the participant claimed their tokens\n\n        participantClaims[msg.sender] = true;\n        \n        // log the event\n        \n        Claimed(msg.sender, participantTokens[msg.sender]);\n        \n        // call the marketplace contract, which will actually issue the tokens to the participant\n        \n        SaleCallbackInterface(marketplace).handleSaleClaimCallback(msg.sender, participantTokens[msg.sender]);\n    }\n    \n    // token sale participants call this to request a refund if the sale was cancelled\n    \n    function refund() external {\n        \n        // the sale must be cancelled\n        \n        require(progress == -1);\n        \n        // the participant must have contributed ETH\n        \n        require(participantValues[msg.sender] > 0);\n        \n        // the participant must not have already requested a refund\n        \n        require(! participantRefunds[msg.sender]);\n        \n\t\t// record that the participant requested a refund\n        \n        participantRefunds[msg.sender] = true;\n        \n        // log the event\n        \n        Refunded(msg.sender, participantValues[msg.sender]);\n        \n        // transfer contributed ETH back to the participant\n    \n        address(msg.sender).transfer(participantValues[msg.sender]);\n    }    \n    \n    // the contract creator calls this to withdraw contributed ETH to a specific address\n    \n    function withdraw(uint256 _sanity, address _recipient, uint256 _value) ifCreator external {\n        \n        // avoid unintended transaction calls\n        \n        require(_sanity == 100010001);\n        \n        // address must not be 0-value\n        \n        require(_recipient != address(0x0));\n        \n        // token sale must be certified or completed\n        \n        require(progress == 1 || progress == 2);\n        \n        // the amount of ETH in the contract must be greater than the amount the creator is attempting to withdraw\n        \n        require(this.balance >= _value);\n        \n        // increment the amount that's been withdrawn\n        \n        withdrawls = safeAdd(withdrawls, _value);\n        \n        // log the withdrawl\n        \n        Withdrew(_recipient, _value);\n        \n        // send the ETH to the recipient\n        \n        address(_recipient).transfer(_value);\n    } \n    \n    // the contract owner calls this to complete (finalize/wrap up, etc.) the sale\n    \n    function complete(uint256 _sanity, uint256 _value) ifCreator external {\n        \n        // avoid unintended transaction calls\n        \n        require(_sanity == 101010101);\n\t    \n\t    // the sale must be marked as ongoing or certified (aka, not cancelled -1)\n        \n        require(progress == 0 || progress == 1);\n        \n        // the sale can only be completed after the finish time\n        \n        require(block.timestamp >= finish);\n        \n        // ETH is withdrawn in the process and sent to the marketplace contract.  ensure the amount that is being withdrawn is greater than the balance in the smart contract.\n        \n        require(this.balance >= _value);\n        \n        // mark the sale as completed\n        \n        progress = 2;\n        \n        // the amount that is sent to the other contract is added to the ETH reserve.  denote this amount as reserves.\n        \n        reserves = safeAdd(reserves, _value);\n        \n        // log the completion of the sale, including the number of sub-tokens created by the sale, the amount of net sub-eth received during the sale, and the amount of sub-eth to be added to the reserve\n        \n        Completed(tokens, value, _value);\n        \n        // call the marketplace contract, sending the ETH for the reserve and including the number of sub-tokens \n        \n        SaleCallbackInterface(marketplace).handleSaleCompletionCallback.value(_value)(tokens);\n    }    \n    \n    // the creator can certify a sale, meaning it cannot be cancelled, and ETH can be withdrawn from the sale by the creator\n    \n    function certify(uint256 _sanity) ifCreator external {\n        \n        // avoid unintended transaction calls\n        \n        require(_sanity == 101011111);\n\t    \n\t    // the sale must be ongoing\n\t    \n        require(progress == 0);\n        \n        // the sale must have started\n        \n        require(block.timestamp >= start);\n        \n        // record that the sale is certified\n        \n        progress = 1;\n        \n        // log the certification\n        \n        Certified(tokens, value);\n    }\n    \n    // the creator can cancel a sale \n    \n    function cancel(uint256 _sanity) ifCreator external {\n        \n        // avoid unintended transaction calls\n        \n        require(_sanity == 111110101);\n\t    \n\t    // the sale must be ongoing\n\t    \n        require(progress == 0);\n        \n        // record that the sale is cancelled\n        \n        progress = -1;\n        \n        // log the cancellation\n        \n        Cancelled(tokens, value);\n    }    \n    \n    // called by the delegate to reverse purchases/grants for a particular contributor\n    \n    function reverse(address _recipient) ifDelegate external {\n        \n        // the recipient address must not be all 0's\n        \n        require(_recipient != address(0x0));\n        \n        // the sale must be ongoing or certified\n        \n        require(progress == 0 || progress == 1);\n        \n        // the recipient must have contributed ETH and/or received tokens\n        \n        require(participantTokens[_recipient] > 0 || participantValues[_recipient] > 0);\n        \n        uint256 initialParticipantTokens = participantTokens[_recipient];\n        uint256 initialParticipantValue = participantValues[_recipient];\n        \n        // subtract sub-tokens and sub-ether from sale totals\n        \n        tokens = safeSub(tokens, initialParticipantTokens);\n        value = safeSub(value, initialParticipantValue);\n        \n        // reset participant sub-tokens and sub-ether\n        \n        participantTokens[_recipient] = 0;\n        participantValues[_recipient] = 0;\n        \n        // log the reversal, including the initial sub-tokens and initial sub-ether\n        \n        Reversed(_recipient, initialParticipantTokens, initialParticipantValue);\n        \n        // if the participant previously sent ETH, return it\n        \n        if (initialParticipantValue > 0) {\n            address(_recipient).transfer(initialParticipantValue);\n        }\n    }\n    \n    // called by the delegate to grant tokens to a recipient\n    \n    function grant(address _recipient, uint256 _tokens) ifDelegate external {\n        \n       \t// the recipient's address cannot be 0-value\n       \n        require(_recipient != address(0x0));\n\t\t\n\t\t// the sale must be ongoing or certified\n\t\t\n        require(progress == 0 || progress == 1);\n        \n        // if the recipient has not participated previously, add them as a participant\n        \n        if (! participants[_recipient]) {\n            participants[_recipient] = true;\n            participantIndex.push(_recipient);\n        }\n        \n        // add sub-tokens to the recipient's balance\n        \n        participantTokens[_recipient] = safeAdd(participantTokens[_recipient], _tokens);\n        \n        // add sub-tokens to the sale's total\n        \n        tokens = safeAdd(tokens, _tokens);\n        \n        // log the grant\n        \n        Granted(_recipient, _tokens);\n    }    \n    \n    // adds a set of addresses to the whitelist\n    \n    function list(address[] _addresses) ifDelegate external {\n        for (uint256 i = 0; i < _addresses.length; i++) {\n            whitelist[_addresses[i]] = true;\n            Listed(_addresses[i]);\n        }\n    }\n    \n    // removes a set of addresses from the whitelist\n    \n    function delist(address[] _addresses) ifDelegate external {\n        for (uint256 i = 0; i < _addresses.length; i++) {\n            whitelist[_addresses[i]] = false;\n            Delisted(_addresses[i]);\n        }\n    }  \n    \n\t// pause the sale\n    \n    function pause() ifDelegate external {\n        active = false;\n        Paused();\n    }\n    \n    // activate the sale\n\n    function activate() ifDelegate external {\n        active = true;\n        Activated();\n    }\n\n    function setDelegate(address _delegate) ifCreator external {\n        delegate = _delegate;\n    }\n    \n    function setRestricted(bool _restricted) ifDelegate external {\n        restricted = _restricted;\n    }\n    \n    function setMarketplace(address _marketplace) ifCreator ifMutable external {\n        marketplace = _marketplace;\n    }\n    \n    function setBonuses(uint256[] _bonuses) ifDelegate ifMutable external {\n        bonuses = _bonuses;\n    }\n    \n    function setFinish(uint256 _finish) ifDelegate ifMutable external {\n        finish = _finish;\n    }\n\n    function setRelease(uint256 _release) ifDelegate ifMutable external {\n        release = _release;\n    }     \n    \n    // get the current bonus percentage, as a whole number\n    \n    function getBonusPercentage() public constant returns (uint256) {\n        \n        uint256 finalBonus;\n        \n        uint256 iterativeTimestamp;\n        uint256 iterativeBonus;\n        \n        // within bonuses, even numbered elements store timestamps and odd numbered elements store bonus percentages\n        // timestamps are in order from oldest to newest\n        // iterates over the elements and if the timestamp has been surpassed, the bonus percentage is denoted\n        // the last bonus percentage that was denoted, if one was denoted at all, is the correct bonus percentage at this time\n        \n        for (uint256 i = 0; i < bonuses.length; i++) {\n            if (i % 2 == 0) {\n                iterativeTimestamp = bonuses[i];\n            } else {\n                iterativeBonus = bonuses[i];\n                if (block.timestamp >= iterativeTimestamp) {\n                    finalBonus = iterativeBonus;\n                }\n            }\n        } \n        \n        return finalBonus;\n    }    \n    \n    function() public payable {\n        buy(msg.sender);\n    }\n    \n}",
        "debug": "calldata_SaleCallbackInterface_4 + calldata_SaleCallbackInterface_4: 0x8421003f084001f4210815cf88407c00000000000000037c1d000e8d178001f\nstorage_21: 0xff00\nstorage_1: 0x0\ncaller: 0x0\ncalldata_SaleCallbackInterface_0: 0x34bf97ea00000000000000000000000000000000000000000000000000000000\ncalldatasize_SaleCallbackInterface: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setBonuses(uint256[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x25df2edc10a16f05e579d127a902cac6fdff940e.sol",
        "function": "setBonuses(uint256[])",
        "lineno": 66,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 11825,
        "code": "   // address of the contract's creator\n    address public delegate;\t\t// address of an entity allowed to perform administrative functions on behalf of the creator\n    \n    address public marketplace;\t    // address of another smart contract that manages the token and Smart Exchange\n    \n    uint256 public start;\t\t\t// timestamp that the sale begins\n    uint256 public finish;\t\t\t// timestamp that the sale ends\n    uint256 public release;\t\t\t// timestamp that sale participants may \"claim\" their tokens (will be after the finish)\n    \n    uint256 public pricer;\t\t\t// a multiplier (>= 1) used to determine how many tokens (or, really, 10^18 sub-units of that token) to give purchasers\n    uint256 public size;\t\t\t// maximum number of 10^18 sub-units of tokens that can be purchased/granted during the sale\n    \n    bool public restricted;\t\t    // whether purchasers and recipients of tokens must be whitelisted manually prior to participating in the sale\n\n    bool public active;\t\t\t    // whether individuals are allowed to purchase tokens -- if false, they cannot.  if true, they can or cannot.  \n    \t\t\t\t\t\t\t\t// other factors, like start/finish, size, and others can restrict participation as well, even if active = true.\n    \t\t\t\t\t\t\t\t// this also can remain true indefinitely, even if the token sale has been cancelled or has completed.\n    \t\t\t\t\t\t\t\t\n    \n    int8 public progress;\t\t\t// -1 = token sale cancelled, 0 = token sale ongoing, 1 = token sale certified (can withdraw ETH while sale is live), 2 = token sale completed\n    \n    uint256 public tokens;\t\t\t// number of sub-tokens that have been purchased/granted during the sale.  purchases/grants can be reversed while progress = 0 || progress = 1 resulting in tokens going down\n    uint256 public value;\t\t\t// number of sub-ether (wei) that have been contributed during the sale.  purchases can be resversed while progress = 0 || progress = 1 resulting in value going down\n    \n    uint256 public withdrawls;\t\t// the number of sub-ether (wei) that have been withdrawn by the contract owner\n    uint256 public reserves;\t\t// the number of sub-ether (wei) that have been sent to serve as reserve in the marketplace\n    \n    mapping(address => bool) public participants;\t\t\t// mapping to record who has participated in the sale (purchased/granted)\n    address[] public participantIndex;\t\t\t\t\t\t// index of participants\n    \n    mapping(address => uint256) public participantTokens;\t// sub-tokens purchased/granted to each participant\n    mapping(address => uint256) public participantValues;\t// sub-ether contributed by each participant\n    \n    mapping(address => bool) public participantRefunds;\t    // mapping to record who has been awarded a refund after a cancelled sale\n    mapping(address => bool) public participantClaims;\t\t// mapping to record who has claimed their tokens after a completed sale\n    \n    mapping(address => bool) public whitelist;\t\t\t\t// mapping to record who has been approved to participate in a \"restricted\" sale\n    \n    uint256[] public bonuses;\t\t\t\t\t\t\t\t// stores bonus percentages, where even numbered elements store timestamps and odd numbered elements store bonus percentages\n    \n    bool public mutable;\t\t\t\t\t\t\t\t\t// whether certain properties (like finish and release) of the sale can be updated to increase the liklihood of a successful token sale for all parties involved\n    \n    modifier ifCreator { require(msg.sender == creator); _; }\t\t// if the caller created the contract...\n    modifier ifDelegate { require(msg.sender == delegate); _; }\t\t// if the caller is currently the appointed delegate...\n    modifier ifMutable { require(mutable); _; }\t\t\t\t\t\t// if the certain properties of the sale can be changed....\n    \n    event Created();\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the contract was created\n    event Bought(address indexed _buyer, address indexed _recipient, uint256 _tokens, uint256 _value);\t\t// an individual bought tokens\n    event Claimed(address indexed _recipient, uint256 _tokens);\t\t\t\t\t\t\t\t\t\t\t\t// an individual claimed tokens after the completion of the sale and after tokens were scheduled for release\n    event Refunded(address indexed _recipient, uint256 _value);\t\t\t\t\t\t\t\t\t\t\t\t// an individual requested a refund of the ETH they contributed after a cancelled token sale\n    event Reversed(address indexed _recipient, uint256 _tokens, uint256 _value);\t\t\t\t\t\t\t// an individual was sent the ETH they contributed to the sale and will not receive tokens\n    event Granted(address indexed _recipient, uint256 _tokens);\t\t\t\t\t\t\t\t\t\t\t\t// an individual was granted tokens, without contributing ETH\n    event Withdrew(address _recipient, uint256 _value);\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the contract creator withdrew ETH from the token sale\n    event Completed(uint256 _tokens, uint256 _value, uint256 _reserves);\t\t\t\t\t\t\t\t\t// the contract creator signaled that the sale completed successfuly\n    event Certified(uint256 _tokens, uint256 _value);\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the contract creator certified the sale\n    event Cancelled(uint256 _tokens, uint256 _value);\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the contract creator cancelled the sale\n    event Listed(address _participant);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// an individual was added to the whitelist\n    event Delisted(address _participant);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// an individual was removed from the whitelist\n    event Paused();\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the sale was paused (active = false)\n    event Activated();    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the sale was activated (active = true)\n\n    function Sale() {\n        \n        creator = msg.sender;\n        delegate = msg.sender;\n        \n        start = 1;\t\t\t\t\t            // contributions may be made as soon as the contract is published\n        finish = 1535760000;\t\t\t\t    // the sale continues through 09/01/2018 @ 00:00:00\n        release = 1536969600;\t\t\t\t    // tokens will be available to participants starting 09/15/2018 @ 00:00:00\n        \n        pricer = 100000;\t\t\t\t\t    // each ETH is worth 100,000 tokens\n        \n        size = 10 ** 18 * pricer * 2000 * 2;\t// 2,000 ETH, plus a 100% buffer to account for the possibility of a 50% decrease in ETH value during the sale\n\n        restricted = false;                     // the sale accepts contributions from everyone.  \n                                                // however, participants who do not submit formal KYC verification before the end of the token sale will have their contributions reverted\n    \n        bonuses = [1, 20];                      // the bonus during the pre-sale starts at 20%\n        \n        mutable = true;                         // certain attributes, such as token sale finish and release dates, may be updated to increase the liklihood of a successful token sale for all parties involved\n        active = true;                          // the token sale is active from the point the contract is published in the form of a pre-sale         \n        \n        Created();\n        Activated();\n    }\n    \n    // returns the number of sub-tokens the calling account purchased/was granted\n    \n    function getMyTokenBalance() external constant returns (uint256) {\n        return participantTokens[msg.sender];\n    }\n    \n    // allows an individual to buy tokens (which will not be issued immediately)\n    // individual instructs the tokens to be delivered to a specific account, which may be different than msg.sender\n    \n    function buy(address _recipient) public payable {\n        \n        // _recipient address must not be all 0's\n        \n        require(_recipient != address(0x0));\n\n\t\t// contributor must send more than 1/10 ETH\n\t\t\n        require(msg.value >= 10 ** 17);\n\n\t\t// sale must be considered active\n\t\t\n        require(active);\n\n\t\t// sale must be ongoing or certified\n\n        require(progress == 0 || progress == 1);\n\n\t\t// current timestamp must be greater than or equal to the start of the token sale\n\t\t\n        require(block.timestamp >= start);\n\n\t\t// current timestamp must be less than the end of the token sale\n\t\t\n        require(block.timestamp < finish);\n\t\t\n\t\t// either the token sale isn't restricted, or the sender is on the whitelist\n\n        require((! restricted) || whitelist[msg.sender]);\n        \n        // either the token sale isn't restricted, or the recipient is on the whitelist\n\n        require((! restricted) || whitelist[_recipient]);\n        \n        // multiply sub-ether by the pricer (which will be a whole number >= 1) to get sub-tokens\n\n        uint256 baseTokens = safeMul(msg.value, pricer);\n        \n        // determine how many bonus sub-tokens to award and add that to the base tokens\n        \n        uint256 totalTokens = safeAdd(baseTokens, safeDiv(safeMul(baseTokens, getBonusPercentage()), 100));\n\n\t\t// ensure the purchase does not cause the sale to exceed its maximum size\n\t\t\n        require(safeAdd(tokens, totalTokens) <= size);\n        \n        // if the recipient is new, add them as a participant\n\n        if (! participants[_recipient]) {\n            participants[_recipient] = true;\n            participantIndex.push(_recipient);\n        }\n        \n        // increment the participant's sub-tokens and sub-ether\n\n        participantTokens[_recipient] = safeAdd(participantTokens[_recipient], totalTokens);\n        participantValues[_recipient] = safeAdd(participantValues[_recipient], msg.value);\n\n\t\t// increment sale sub-tokens and sub-ether\n\n        tokens = safeAdd(tokens, totalTokens);\n        value = safeAdd(value, msg.value);\n        \n        // log purchase event\n\n        Bought(msg.sender, _recipient, totalTokens, msg.value);\n    }\n    \n    // token sale participants call this to claim their tokens after the sale is completed and tokens are scheduled for release\n    \n    function claim() external {\n\t    \n\t    // sale must be completed\n        \n        require(progress == 2);\n        \n        // tokens must be scheduled for release\n        \n        require(block.timestamp >= release);\n        \n        // participant must have tokens to claim\n        \n        require(participantTokens[msg.sender] > 0);\n        \n        // participant must not have already claimed tokens\n        \n        require(! participantClaims[msg.sender]);\n        \n\t\t// record that the participant claimed their tokens\n\n        participantClaims[msg.sender] = true;\n        \n        // log the event\n        \n        Claimed(msg.sender, participantTokens[msg.sender]);\n        \n        // call the marketplace contract, which will actually issue the tokens to the participant\n        \n        SaleCallbackInterface(marketplace).handleSaleClaimCallback(msg.sender, participantTokens[msg.sender]);\n    }\n    \n    // token sale participants call this to request a refund if the sale was cancelled\n    \n    function refund() external {\n        \n        // the sale must be cancelled\n        \n        require(progress == -1);\n        \n        // the participant must have contributed ETH\n        \n        require(participantValues[msg.sender] > 0);\n        \n        // the participant must not have already requested a refund\n        \n        require(! participantRefunds[msg.sender]);\n        \n\t\t// record that the participant requested a refund\n        \n        participantRefunds[msg.sender] = true;\n        \n        // log the event\n        \n        Refunded(msg.sender, participantValues[msg.sender]);\n        \n        // transfer contributed ETH back to the participant\n    \n        address(msg.sender).transfer(participantValues[msg.sender]);\n    }    \n    \n    // the contract creator calls this to withdraw contributed ETH to a specific address\n    \n    function withdraw(uint256 _sanity, address _recipient, uint256 _value) ifCreator external {\n        \n        // avoid unintended transaction calls\n        \n        require(_sanity == 100010001);\n        \n        // address must not be 0-value\n        \n        require(_recipient != address(0x0));\n        \n        // token sale must be certified or completed\n        \n        require(progress == 1 || progress == 2);\n        \n        // the amount of ETH in the contract must be greater than the amount the creator is attempting to withdraw\n        \n        require(this.balance >= _value);\n        \n        // increment the amount that's been withdrawn\n        \n        withdrawls = safeAdd(withdrawls, _value);\n        \n        // log the withdrawl\n        \n        Withdrew(_recipient, _value);\n        \n        // send the ETH to the recipient\n        \n        address(_recipient).transfer(_value);\n    } \n    \n    // the contract owner calls this to complete (finalize/wrap up, etc.) the sale\n    \n    function complete(uint256 _sanity, uint256 _value) ifCreator external {\n        \n        // avoid unintended transaction calls\n        \n        require(_sanity == 101010101);\n\t    \n\t    // the sale must be marked as ongoing or certified (aka, not cancelled -1)\n        \n        require(progress == 0 || progress == 1);\n        \n        // the sale can only be completed after the finish time\n        \n        require(block.timestamp >= finish);\n        \n        // ETH is withdrawn in the process and sent to the marketplace contract.  ensure the amount that is being withdrawn is greater than the balance in the smart contract.\n        \n        require(this.balance >= _value);\n        \n        // mark the sale as completed\n        \n        progress = 2;\n        \n        // the amount that is sent to the other contract is added to the ETH reserve.  denote this amount as reserves.\n        \n        reserves = safeAdd(reserves, _value);\n        \n        // log the completion of the sale, including the number of sub-tokens created by the sale, the amount of net sub-eth received during the sale, and the amount of sub-eth to be added to the reserve\n        \n        Completed(tokens, value, _value);\n        \n        // call the marketplace contract, sending the ETH for the reserve and including the number of sub-tokens \n        \n        SaleCallbackInterface(marketplace).handleSaleCompletionCallback.value(_value)(tokens);\n    }    \n    \n    // the creator can certify a sale, meaning it cannot be cancelled, and ETH can be withdrawn from the sale by the creator\n    \n    function certify(uint256 _sanity) ifCreator external {\n        \n        // avoid unintended transaction calls\n        \n        require(_sanity == 101011111);\n\t    \n\t    // the sale must be ongoing\n\t    \n        require(progress == 0);\n        \n        // the sale must have started\n        \n        require(block.timestamp >= start);\n        \n        // record that the sale is certified\n        \n        progress = 1;\n        \n        // log the certification\n        \n        Certified(tokens, value);\n    }\n    \n    // the creator can cancel a sale \n    \n    function cancel(uint256 _sanity) ifCreator external {\n        \n        // avoid unintended transaction calls\n        \n        require(_sanity == 111110101);\n\t    \n\t    // the sale must be ongoing\n\t    \n        require(progress == 0);\n        \n        // record that the sale is cancelled\n        \n        progress = -1;\n        \n        // log the cancellation\n        \n        Cancelled(tokens, value);\n    }    \n    \n    // called by the delegate to reverse purchases/grants for a particular contributor\n    \n    function reverse(address _recipient) ifDelegate external {\n        \n        // the recipient address must not be all 0's\n        \n        require(_recipient != address(0x0));\n        \n        // the sale must be ongoing or certified\n        \n        require(progress == 0 || progress == 1);\n        \n        // the recipient must have contributed ETH and/or received tokens\n        \n        require(participantTokens[_recipient] > 0 || participantValues[_recipient] > 0);\n        \n        uint256 initialParticipantTokens = participantTokens[_recipient];\n        uint256 initialParticipantValue = participantValues[_recipient];\n        \n        // subtract sub-tokens and sub-ether from sale totals\n        \n        tokens = safeSub(tokens, initialParticipantTokens);\n        value = safeSub(value, initialParticipantValue);\n        \n        // reset participant sub-tokens and sub-ether\n        \n        participantTokens[_recipient] = 0;\n        participantValues[_recipient] = 0;\n        \n        // log the reversal, including the initial sub-tokens and initial sub-ether\n        \n        Reversed(_recipient, initialParticipantTokens, initialParticipantValue);\n        \n        // if the participant previously sent ETH, return it\n        \n        if (initialParticipantValue > 0) {\n            address(_recipient).transfer(initialParticipantValue);\n        }\n    }\n    \n    // called by the delegate to grant tokens to a recipient\n    \n    function grant(address _recipient, uint256 _tokens) ifDelegate external {\n        \n       \t// the recipient's address cannot be 0-value\n       \n        require(_recipient != address(0x0));\n\t\t\n\t\t// the sale must be ongoing or certified\n\t\t\n        require(progress == 0 || progress == 1);\n        \n        // if the recipient has not participated previously, add them as a participant\n        \n        if (! participants[_recipient]) {\n            participants[_recipient] = true;\n            participantIndex.push(_recipient);\n        }\n        \n        // add sub-tokens to the recipient's balance\n        \n        participantTokens[_recipient] = safeAdd(participantTokens[_recipient], _tokens);\n        \n        // add sub-tokens to the sale's total\n        \n        tokens = safeAdd(tokens, _tokens);\n        \n        // log the grant\n        \n        Granted(_recipient, _tokens);\n    }    \n    \n    // adds a set of addresses to the whitelist\n    \n    function list(address[] _addresses) ifDelegate external {\n        for (uint256 i = 0; i < _addresses.length; i++) {\n            whitelist[_addresses[i]] = true;\n            Listed(_addresses[i]);\n        }\n    }\n    \n    // removes a set of addresses from the whitelist\n    \n    function delist(address[] _addresses) ifDelegate external {\n        for (uint256 i = 0; i < _addresses.length; i++) {\n            whitelist[_addresses[i]] = false;\n            Delisted(_addresses[i]);\n        }\n    }  \n    \n\t// pause the sale\n    \n    function pause() ifDelegate external {\n        active = false;\n        Paused();\n    }\n    \n    // activate the sale\n\n    function activate() ifDelegate external {\n        active = true;\n        Activated();\n    }\n\n    function setDelegate(address _delegate) ifCreator external {\n        delegate = _delegate;\n    }\n    \n    function setRestricted(bool _restricted) ifDelegate external {\n        restricted = _restricted;\n    }\n    \n    function setMarketplace(address _marketplace) ifCreator ifMutable external {\n        marketplace = _marketplace;\n    }\n    \n    function setBonuses(uint256[] _bonuses) ifDelegate ifMutable external {\n        bonuses = _bonuses;\n    }\n    \n    function setFinish(uint256 _finish) ifDelegate ifMutable external {\n        finish = _finish;\n    }\n\n    function setRelease(uint256 _release) ifDelegate ifMutable external {\n        release = _release;\n    }     \n    \n    // get the current bonus percentage, as a whole number\n    \n    function getBonusPercentage() public constant returns (uint256) {\n        \n        uint256 finalBonus;\n        \n        uint256 iterativeTimestamp;\n        uint256 iterativeBonus;\n        \n        // within bonuses, even numbered elements store timestamps and odd numbered elements store bonus percentages\n        // timestamps are in order from oldest to newest\n        // iterates over the elements and if the timestamp has been surpassed, the bonus percentage is denoted\n        // the last bonus percentage that was denoted, if one was denoted at all, is the correct bonus percentage at this time\n        \n        for (uint256 i = 0; i < bonuses.length; i++) {\n            if (i % 2 == 0) {\n                iterativeTimestamp = bonuses[i];\n            } else {\n                iterativeBonus = bonuses[i];\n                if (block.timestamp >= iterativeTimestamp) {\n                    finalBonus = iterativeBonus;\n                }\n            }\n        } \n        \n        return finalBonus;\n    }    \n    \n    function() public payable {\n        buy(msg.sender);\n    }\n    \n}",
        "debug": "calldata_SaleCallbackInterface_4 + calldata_SaleCallbackInterface_4: 0x7ffffffffffffcb76b8d0f83fb8ffef7fffffdfffffffffd11cdb5dffffffff\ncalldata_SaleCallbackInterface_4: 0x670c96825de4b7e4babe61c100020000000001dc64945ffffffffc\nstorage_21: 0xff00\nstorage_1: 0x0\ncaller: 0x0\ncalldata_SaleCallbackInterface_0: 0x34bf97ea00000000000000000000000000000000000000000000000000000000\ncalldatasize_SaleCallbackInterface: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setBonuses(uint256[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x25df2edc10a16f05e579d127a902cac6fdff940e.sol",
        "function": "setBonuses(uint256[])",
        "lineno": 66,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}